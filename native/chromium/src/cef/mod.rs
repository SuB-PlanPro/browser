/* automatically generated by rust-bindgen 0.59.2 */

#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
use chromium_jni_macro::FromJava;
use chromium_jni_utils::FromJava;
use chromium_jni_utils::FromJavaMember;
use jni::JNIEnv;
use jni::objects::JObject;
#[cfg(windows)] pub mod win;
#[cfg(windows)] pub use self::win::_cef_window_info_t;
#[cfg(windows)] pub use self::win::_cef_main_args_t;
#[cfg(windows)] pub type wchar_t = u16;
#[cfg(windows)] pub type char16 = u16;
#[cfg(windows)] pub type time_t = i64;
#[cfg(windows)] pub type int64 = ::std::os::raw::c_longlong;
#[cfg(windows)] pub type uint64 = ::std::os::raw::c_ulonglong;

pub type int32 = ::std::os::raw::c_int;
pub type uint32 = ::std::os::raw::c_uint;
#[doc = " CEF string type definitions. Whomever allocates |str| is responsible for"]
#[doc = " providing an appropriate |dtor| implementation that will free the string in"]
#[doc = " the same memory space. When reusing an existing string structure make sure"]
#[doc = " to call |dtor| for the old value before assigning new |str| and |dtor|"]
#[doc = " values. Static strings will have a NULL |dtor| value. Using the below"]
#[doc = " functions if you want this managed for you."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_wide_t {
    pub str_: *mut wchar_t,
    pub length: usize,
    pub dtor: ::std::option::Option<unsafe extern "C" fn(str_: *mut wchar_t)>,
}
#[doc = " CEF string type definitions. Whomever allocates |str| is responsible for"]
#[doc = " providing an appropriate |dtor| implementation that will free the string in"]
#[doc = " the same memory space. When reusing an existing string structure make sure"]
#[doc = " to call |dtor| for the old value before assigning new |str| and |dtor|"]
#[doc = " values. Static strings will have a NULL |dtor| value. Using the below"]
#[doc = " functions if you want this managed for you."]
pub type cef_string_wide_t = _cef_string_wide_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_utf8_t {
    pub str_: *mut ::std::os::raw::c_char,
    pub length: usize,
    pub dtor: ::std::option::Option<unsafe extern "C" fn(str_: *mut ::std::os::raw::c_char)>,
}
pub type cef_string_utf8_t = _cef_string_utf8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_utf16_t {
    pub str_: *mut char16,
    pub length: usize,
    pub dtor: ::std::option::Option<unsafe extern "C" fn(str_: *mut char16)>,
}
pub type cef_string_utf16_t = _cef_string_utf16_t;
extern "C" {
    #[doc = ""]
    #[doc = " These functions set string values. If |copy| is true (1) the value will be"]
    #[doc = " copied instead of referenced. It is up to the user to properly manage"]
    #[doc = " the lifespan of references."]
    #[doc = ""]
    pub fn cef_string_wide_set(
        src: *const wchar_t,
        src_len: usize,
        output: *mut cef_string_wide_t,
        copy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf8_set(
        src: *const ::std::os::raw::c_char,
        src_len: usize,
        output: *mut cef_string_utf8_t,
        copy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_set(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_utf16_t,
        copy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions clear string values. The structure itself is not freed."]
    #[doc = ""]
    pub fn cef_string_wide_clear(str_: *mut cef_string_wide_t);
}
extern "C" {
    pub fn cef_string_utf8_clear(str_: *mut cef_string_utf8_t);
}
extern "C" {
    pub fn cef_string_utf16_clear(str_: *mut cef_string_utf16_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions compare two string values with the same results as strcmp()."]
    #[doc = ""]
    pub fn cef_string_wide_cmp(
        str1: *const cef_string_wide_t,
        str2: *const cef_string_wide_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf8_cmp(
        str1: *const cef_string_utf8_t,
        str2: *const cef_string_utf8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_cmp(
        str1: *const cef_string_utf16_t,
        str2: *const cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions convert between UTF-8, -16, and -32 strings. They are"]
    #[doc = " potentially slow so unnecessary conversions should be avoided. The best"]
    #[doc = " possible result will always be written to |output| with the boolean return"]
    #[doc = " value indicating whether the conversion is 100% valid."]
    #[doc = ""]
    pub fn cef_string_wide_to_utf8(
        src: *const wchar_t,
        src_len: usize,
        output: *mut cef_string_utf8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf8_to_wide(
        src: *const ::std::os::raw::c_char,
        src_len: usize,
        output: *mut cef_string_wide_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_wide_to_utf16(
        src: *const wchar_t,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_to_wide(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_wide_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf8_to_utf16(
        src: *const ::std::os::raw::c_char,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_to_utf8(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_utf8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions convert an ASCII string, typically a hardcoded constant, to a"]
    #[doc = " Wide/UTF16 string. Use instead of the UTF8 conversion routines if you know"]
    #[doc = " the string is ASCII."]
    #[doc = ""]
    pub fn cef_string_ascii_to_wide(
        src: *const ::std::os::raw::c_char,
        src_len: usize,
        output: *mut cef_string_wide_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_ascii_to_utf16(
        src: *const ::std::os::raw::c_char,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " It is sometimes necessary for the system to allocate string structures with"]
#[doc = " the expectation that the user will free them. The userfree types act as a"]
#[doc = " hint that the user is responsible for freeing the structure."]
#[doc = ""]
pub type cef_string_userfree_wide_t = *mut cef_string_wide_t;
pub type cef_string_userfree_utf8_t = *mut cef_string_utf8_t;
pub type cef_string_userfree_utf16_t = *mut cef_string_utf16_t;
extern "C" {
    #[doc = ""]
    #[doc = " These functions allocate a new string structure. They must be freed by"]
    #[doc = " calling the associated free function."]
    #[doc = ""]
    pub fn cef_string_userfree_wide_alloc() -> cef_string_userfree_wide_t;
}
extern "C" {
    pub fn cef_string_userfree_utf8_alloc() -> cef_string_userfree_utf8_t;
}
extern "C" {
    pub fn cef_string_userfree_utf16_alloc() -> cef_string_userfree_utf16_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions free the string structure allocated by the associated"]
    #[doc = " alloc function. Any string contents will first be cleared."]
    #[doc = ""]
    pub fn cef_string_userfree_wide_free(str_: cef_string_userfree_wide_t);
}
extern "C" {
    pub fn cef_string_userfree_utf8_free(str_: cef_string_userfree_utf8_t);
}
extern "C" {
    pub fn cef_string_userfree_utf16_free(str_: cef_string_userfree_utf16_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions convert utf16 string case using the current ICU locale. This"]
    #[doc = " may change the length of the string in some cases."]
    #[doc = ""]
    pub fn cef_string_utf16_to_lower(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_to_upper(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
pub type cef_string_userfree_t = cef_string_userfree_utf16_t;
pub type cef_string_t = cef_string_utf16_t;
#[doc = ""]
#[doc = " Structure representing window information."]
#[doc = ""]
pub type cef_window_info_t = _cef_window_info_t;
#[doc = ""]
#[doc = " CEF string maps are a set of key/value string pairs."]
#[doc = ""]
pub type cef_string_list_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = ""]
    #[doc = " Allocate a new string map."]
    #[doc = ""]
    pub fn cef_string_list_alloc() -> cef_string_list_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the number of elements in the string list."]
    #[doc = ""]
    pub fn cef_string_list_size(list: cef_string_list_t) -> usize;
}
extern "C" {
    #[doc = ""]
    #[doc = " Retrieve the value at the specified zero-based string list index. Returns"]
    #[doc = " true (1) if the value was successfully retrieved."]
    #[doc = ""]
    pub fn cef_string_list_value(
        list: cef_string_list_t,
        index: usize,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Append a new value at the end of the string list."]
    #[doc = ""]
    pub fn cef_string_list_append(list: cef_string_list_t, value: *const cef_string_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Clear the string list."]
    #[doc = ""]
    pub fn cef_string_list_clear(list: cef_string_list_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Free the string list."]
    #[doc = ""]
    pub fn cef_string_list_free(list: cef_string_list_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Creates a copy of an existing string list."]
    #[doc = ""]
    pub fn cef_string_list_copy(list: cef_string_list_t) -> cef_string_list_t;
}
#[doc = ""]
#[doc = " Time information. Values should always be in UTC."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_time_t {
    #[doc = " Four or five digit year \"2007\" (1601 to 30827 on"]
    #[doc = "   Windows, 1970 to 2038 on 32-bit POSIX)"]
    pub year: ::std::os::raw::c_int,
    #[doc = " 1-based month (values 1 = January, etc.)"]
    pub month: ::std::os::raw::c_int,
    #[doc = " 0-based day of week (0 = Sunday, etc.)"]
    pub day_of_week: ::std::os::raw::c_int,
    #[doc = " 1-based day of month (1-31)"]
    pub day_of_month: ::std::os::raw::c_int,
    #[doc = " Hour within the current day (0-23)"]
    pub hour: ::std::os::raw::c_int,
    #[doc = " Minute within the current hour (0-59)"]
    pub minute: ::std::os::raw::c_int,
    #[doc = " Second within the current minute (0-59 plus leap"]
    #[doc = "   seconds which may take it up to 60)."]
    pub second: ::std::os::raw::c_int,
    #[doc = " Milliseconds within the current second (0-999)"]
    pub millisecond: ::std::os::raw::c_int,
}
#[doc = ""]
#[doc = " Time information. Values should always be in UTC."]
#[doc = ""]
pub type cef_time_t = _cef_time_t;
extern "C" {
    #[doc = ""]
    #[doc = " Converts cef_time_t to/from time_t. Returns true (1) on success and false (0)"]
    #[doc = " on failure."]
    #[doc = ""]
    pub fn cef_time_to_timet(
        cef_time: *const cef_time_t,
        time: *mut time_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_time_from_timet(time: time_t, cef_time: *mut cef_time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Converts cef_time_t to/from a double which is the number of seconds since"]
    #[doc = " epoch (Jan 1, 1970). Webkit uses this format to represent time. A value of 0"]
    #[doc = " means \"not initialized\". Returns true (1) on success and false (0) on"]
    #[doc = " failure."]
    #[doc = ""]
    pub fn cef_time_to_doublet(
        cef_time: *const cef_time_t,
        time: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_time_from_doublet(time: f64, cef_time: *mut cef_time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Retrieve the current system time."]
    #[doc = ""]
    pub fn cef_time_now(cef_time: *mut cef_time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Retrieve the delta in milliseconds between two time values."]
    #[doc = ""]
    pub fn cef_time_delta(
        cef_time1: *const cef_time_t,
        cef_time2: *const cef_time_t,
        delta: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " 32-bit ARGB color value, not premultiplied. The color components are always"]
#[doc = " in a known order. Equivalent to the SkColor type."]
pub type cef_color_t = uint32;
#[repr(i32)]
#[doc = ""]
#[doc = " Log severity levels."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_log_severity_t {
    #[doc = ""]
    #[doc = " Default logging (currently INFO logging)."]
    #[doc = ""]
    LOGSEVERITY_DEFAULT = 0,
    #[doc = ""]
    #[doc = " Verbose logging."]
    #[doc = ""]
    LOGSEVERITY_VERBOSE = 1,
    #[doc = ""]
    #[doc = " INFO logging."]
    #[doc = ""]
    LOGSEVERITY_INFO = 2,
    #[doc = ""]
    #[doc = " WARNING logging."]
    #[doc = ""]
    LOGSEVERITY_WARNING = 3,
    #[doc = ""]
    #[doc = " ERROR logging."]
    #[doc = ""]
    LOGSEVERITY_ERROR = 4,
    #[doc = ""]
    #[doc = " Completely disable logging."]
    #[doc = ""]
    LOGSEVERITY_DISABLE = 99,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Represents the state of a setting."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_state_t {
    #[doc = ""]
    #[doc = " Use the default state for the setting."]
    #[doc = ""]
    STATE_DEFAULT = 0,
    #[doc = ""]
    #[doc = " Enable or allow the setting."]
    #[doc = ""]
    STATE_ENABLED = 1,
    #[doc = ""]
    #[doc = " Disable or disallow the setting."]
    #[doc = ""]
    STATE_DISABLED = 2,
}
#[doc = ""]
#[doc = " Initialization settings. Specify NULL or 0 to get the recommended default"]
#[doc = " values. Many of these and other settings can also configured using command-"]
#[doc = " line switches."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_settings_t {
    #[doc = ""]
    #[doc = " Size of this structure."]
    #[doc = ""]
    pub size: usize,
    #[doc = ""]
    #[doc = " Set to true (1) to use a single process for the browser and renderer. This"]
    #[doc = " run mode is not officially supported by Chromium and is less stable than"]
    #[doc = " the multi-process default. Also configurable using the \"single-process\""]
    #[doc = " command-line switch."]
    #[doc = ""]
    pub single_process: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to disable the sandbox for sub-processes. See"]
    #[doc = " cef_sandbox_win.h for requirements to enable the sandbox on Windows. Also"]
    #[doc = " configurable using the \"no-sandbox\" command-line switch."]
    #[doc = ""]
    pub no_sandbox: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The path to a separate executable that will be launched for sub-processes."]
    #[doc = " If this value is empty on Windows or Linux then the main process executable"]
    #[doc = " will be used. If this value is empty on macOS then a helper executable must"]
    #[doc = " exist at \"Contents/Frameworks/<app> Helper.app/Contents/MacOS/<app> Helper\""]
    #[doc = " in the top-level app bundle. See the comments on CefExecuteProcess() for"]
    #[doc = " details. Also configurable using the \"browser-subprocess-path\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub browser_subprocess_path: cef_string_t,
    #[doc = ""]
    #[doc = " The path to the CEF framework directory on macOS. If this value is empty"]
    #[doc = " then the framework must exist at \"Contents/Frameworks/Chromium Embedded"]
    #[doc = " Framework.framework\" in the top-level app bundle. Also configurable using"]
    #[doc = " the \"framework-dir-path\" command-line switch."]
    #[doc = ""]
    pub framework_dir_path: cef_string_t,
    #[doc = ""]
    #[doc = " Set to true (1) to have the browser process message loop run in a separate"]
    #[doc = " thread. If false (0) than the CefDoMessageLoopWork() function must be"]
    #[doc = " called from your application message loop. This option is only supported on"]
    #[doc = " Windows."]
    #[doc = ""]
    pub multi_threaded_message_loop: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to control browser process main (UI) thread message pump"]
    #[doc = " scheduling via the CefBrowserProcessHandler::OnScheduleMessagePumpWork()"]
    #[doc = " callback. This option is recommended for use in combination with the"]
    #[doc = " CefDoMessageLoopWork() function in cases where the CEF message loop must be"]
    #[doc = " integrated into an existing application message loop (see additional"]
    #[doc = " comments and warnings on CefDoMessageLoopWork). Enabling this option is not"]
    #[doc = " recommended for most users; leave this option disabled and use either the"]
    #[doc = " CefRunMessageLoop() function or multi_threaded_message_loop if possible."]
    #[doc = ""]
    pub external_message_pump: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to enable windowless (off-screen) rendering support. Do not"]
    #[doc = " enable this value if the application does not use windowless rendering as"]
    #[doc = " it may reduce rendering performance on some systems."]
    #[doc = ""]
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to disable configuration of browser process features using"]
    #[doc = " standard CEF and Chromium command-line arguments. Configuration can still"]
    #[doc = " be specified using CEF data structures or via the"]
    #[doc = " CefApp::OnBeforeCommandLineProcessing() method."]
    #[doc = ""]
    pub command_line_args_disabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The location where cache data will be stored on disk. If empty then"]
    #[doc = " browsers will be created in \"incognito mode\" where in-memory caches are"]
    #[doc = " used for storage and no data is persisted to disk. HTML5 databases such as"]
    #[doc = " localStorage will only persist across sessions if a cache path is"]
    #[doc = " specified. Can be overridden for individual CefRequestContext instances via"]
    #[doc = " the CefRequestContextSettings.cache_path value."]
    #[doc = ""]
    pub cache_path: cef_string_t,
    #[doc = ""]
    #[doc = " The location where user data such as spell checking dictionary files will"]
    #[doc = " be stored on disk. If empty then the default platform-specific user data"]
    #[doc = " directory will be used (\"~/.cef_user_data\" directory on Linux,"]
    #[doc = " \"~/Library/Application Support/CEF/User Data\" directory on Mac OS X,"]
    #[doc = " \"Local Settings\\Application Data\\CEF\\User Data\" directory under the user"]
    #[doc = " profile directory on Windows)."]
    #[doc = ""]
    pub user_data_path: cef_string_t,
    #[doc = ""]
    #[doc = " To persist session cookies (cookies without an expiry date or validity"]
    #[doc = " interval) by default when using the global cookie manager set this value to"]
    #[doc = " true (1). Session cookies are generally intended to be transient and most"]
    #[doc = " Web browsers do not persist them. A |cache_path| value must also be"]
    #[doc = " specified to enable this feature. Also configurable using the"]
    #[doc = " \"persist-session-cookies\" command-line switch. Can be overridden for"]
    #[doc = " individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.persist_session_cookies value."]
    #[doc = ""]
    pub persist_session_cookies: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " To persist user preferences as a JSON file in the cache path directory set"]
    #[doc = " this value to true (1). A |cache_path| value must also be specified"]
    #[doc = " to enable this feature. Also configurable using the"]
    #[doc = " \"persist-user-preferences\" command-line switch. Can be overridden for"]
    #[doc = " individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.persist_user_preferences value."]
    #[doc = ""]
    pub persist_user_preferences: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Value that will be returned as the User-Agent HTTP header. If empty the"]
    #[doc = " default User-Agent string will be used. Also configurable using the"]
    #[doc = " \"user-agent\" command-line switch."]
    #[doc = ""]
    pub user_agent: cef_string_t,
    #[doc = ""]
    #[doc = " Value that will be inserted as the product portion of the default"]
    #[doc = " User-Agent string. If empty the Chromium product version will be used. If"]
    #[doc = " |userAgent| is specified this value will be ignored. Also configurable"]
    #[doc = " using the \"product-version\" command-line switch."]
    #[doc = ""]
    pub product_version: cef_string_t,
    #[doc = ""]
    #[doc = " The locale string that will be passed to WebKit. If empty the default"]
    #[doc = " locale of \"en-US\" will be used. This value is ignored on Linux where locale"]
    #[doc = " is determined using environment variable parsing with the precedence order:"]
    #[doc = " LANGUAGE, LC_ALL, LC_MESSAGES and LANG. Also configurable using the \"lang\""]
    #[doc = " command-line switch."]
    #[doc = ""]
    pub locale: cef_string_t,
    #[doc = ""]
    #[doc = " The directory and file name to use for the debug log. If empty a default"]
    #[doc = " log file name and location will be used. On Windows and Linux a \"debug.log\""]
    #[doc = " file will be written in the main executable directory. On Mac OS X a"]
    #[doc = " \"~/Library/Logs/<app name>_debug.log\" file will be written where <app name>"]
    #[doc = " is the name of the main app executable. Also configurable using the"]
    #[doc = " \"log-file\" command-line switch."]
    #[doc = ""]
    pub log_file: cef_string_t,
    #[doc = ""]
    #[doc = " The log severity. Only messages of this severity level or higher will be"]
    #[doc = " logged. Also configurable using the \"log-severity\" command-line switch with"]
    #[doc = " a value of \"verbose\", \"info\", \"warning\", \"error\", \"error-report\" or"]
    #[doc = " \"disable\"."]
    #[doc = ""]
    pub log_severity: cef_log_severity_t,
    #[doc = ""]
    #[doc = " Custom flags that will be used when initializing the V8 JavaScript engine."]
    #[doc = " The consequences of using custom flags may not be well tested. Also"]
    #[doc = " configurable using the \"js-flags\" command-line switch."]
    #[doc = ""]
    pub javascript_flags: cef_string_t,
    #[doc = ""]
    #[doc = " The fully qualified path for the resources directory. If this value is"]
    #[doc = " empty the cef.pak and/or devtools_resources.pak files must be located in"]
    #[doc = " the module directory on Windows/Linux or the app bundle Resources directory"]
    #[doc = " on Mac OS X. Also configurable using the \"resources-dir-path\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub resources_dir_path: cef_string_t,
    #[doc = ""]
    #[doc = " The fully qualified path for the locales directory. If this value is empty"]
    #[doc = " the locales directory must be located in the module directory. This value"]
    #[doc = " is ignored on Mac OS X where pack files are always loaded from the app"]
    #[doc = " bundle Resources directory. Also configurable using the \"locales-dir-path\""]
    #[doc = " command-line switch."]
    #[doc = ""]
    pub locales_dir_path: cef_string_t,
    #[doc = ""]
    #[doc = " Set to true (1) to disable loading of pack files for resources and locales."]
    #[doc = " A resource bundle handler must be provided for the browser and render"]
    #[doc = " processes via CefApp::GetResourceBundleHandler() if loading of pack files"]
    #[doc = " is disabled. Also configurable using the \"disable-pack-loading\" command-"]
    #[doc = " line switch."]
    #[doc = ""]
    pub pack_loading_disabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to a value between 1024 and 65535 to enable remote debugging on the"]
    #[doc = " specified port. For example, if 8080 is specified the remote debugging URL"]
    #[doc = " will be http://localhost:8080. CEF can be remotely debugged from any CEF or"]
    #[doc = " Chrome browser window. Also configurable using the \"remote-debugging-port\""]
    #[doc = " command-line switch."]
    #[doc = ""]
    pub remote_debugging_port: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The number of stack trace frames to capture for uncaught exceptions."]
    #[doc = " Specify a positive value to enable the CefRenderProcessHandler::"]
    #[doc = " OnUncaughtException() callback. Specify 0 (default value) and"]
    #[doc = " OnUncaughtException() will not be called. Also configurable using the"]
    #[doc = " \"uncaught-exception-stack-size\" command-line switch."]
    #[doc = ""]
    pub uncaught_exception_stack_size: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to ignore errors related to invalid SSL certificates."]
    #[doc = " Enabling this setting can lead to potential security vulnerabilities like"]
    #[doc = " \"man in the middle\" attacks. Applications that load content from the"]
    #[doc = " internet should not enable this setting. Also configurable using the"]
    #[doc = " \"ignore-certificate-errors\" command-line switch. Can be overridden for"]
    #[doc = " individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.ignore_certificate_errors value."]
    #[doc = ""]
    pub ignore_certificate_errors: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to enable date-based expiration of built in network"]
    #[doc = " security information (i.e. certificate transparency logs, HSTS preloading"]
    #[doc = " and pinning information). Enabling this option improves network security"]
    #[doc = " but may cause HTTPS load failures when using CEF binaries built more than"]
    #[doc = " 10 weeks in the past. See https://www.certificate-transparency.org/ and"]
    #[doc = " https://www.chromium.org/hsts for details. Also configurable using the"]
    #[doc = " \"enable-net-security-expiration\" command-line switch. Can be overridden for"]
    #[doc = " individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.enable_net_security_expiration value."]
    #[doc = ""]
    pub enable_net_security_expiration: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Background color used for the browser before a document is loaded and when"]
    #[doc = " no document color is specified. The alpha component must be either fully"]
    #[doc = " opaque (0xFF) or fully transparent (0x00). If the alpha component is fully"]
    #[doc = " opaque then the RGB components will be used as the background color. If the"]
    #[doc = " alpha component is fully transparent for a windowed browser then the"]
    #[doc = " default value of opaque white be used. If the alpha component is fully"]
    #[doc = " transparent for a windowless (off-screen) browser then transparent painting"]
    #[doc = " will be enabled."]
    #[doc = ""]
    pub background_color: cef_color_t,
    #[doc = ""]
    #[doc = " Comma delimited ordered list of language codes without any whitespace that"]
    #[doc = " will be used in the \"Accept-Language\" HTTP header. May be overridden on a"]
    #[doc = " per-browser basis using the CefBrowserSettings.accept_language_list value."]
    #[doc = " If both values are empty then \"en-US,en\" will be used. Can be overridden"]
    #[doc = " for individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.accept_language_list value."]
    #[doc = ""]
    pub accept_language_list: cef_string_t,
}
#[doc = ""]
#[doc = " Request context initialization settings. Specify NULL or 0 to get the"]
#[doc = " recommended default values."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_settings_t {
    #[doc = ""]
    #[doc = " Size of this structure."]
    #[doc = ""]
    pub size: usize,
    #[doc = ""]
    #[doc = " The location where cache data will be stored on disk. If empty then"]
    #[doc = " browsers will be created in \"incognito mode\" where in-memory caches are"]
    #[doc = " used for storage and no data is persisted to disk. HTML5 databases such as"]
    #[doc = " localStorage will only persist across sessions if a cache path is"]
    #[doc = " specified. To share the global browser cache and related configuration set"]
    #[doc = " this value to match the CefSettings.cache_path value."]
    #[doc = ""]
    pub cache_path: cef_string_t,
    #[doc = ""]
    #[doc = " To persist session cookies (cookies without an expiry date or validity"]
    #[doc = " interval) by default when using the global cookie manager set this value to"]
    #[doc = " true (1). Session cookies are generally intended to be transient and most"]
    #[doc = " Web browsers do not persist them. Can be set globally using the"]
    #[doc = " CefSettings.persist_session_cookies value. This value will be ignored if"]
    #[doc = " |cache_path| is empty or if it matches the CefSettings.cache_path value."]
    #[doc = ""]
    pub persist_session_cookies: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " To persist user preferences as a JSON file in the cache path directory set"]
    #[doc = " this value to true (1). Can be set globally using the"]
    #[doc = " CefSettings.persist_user_preferences value. This value will be ignored if"]
    #[doc = " |cache_path| is empty or if it matches the CefSettings.cache_path value."]
    #[doc = ""]
    pub persist_user_preferences: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to ignore errors related to invalid SSL certificates."]
    #[doc = " Enabling this setting can lead to potential security vulnerabilities like"]
    #[doc = " \"man in the middle\" attacks. Applications that load content from the"]
    #[doc = " internet should not enable this setting. Can be set globally using the"]
    #[doc = " CefSettings.ignore_certificate_errors value. This value will be ignored if"]
    #[doc = " |cache_path| matches the CefSettings.cache_path value."]
    #[doc = ""]
    pub ignore_certificate_errors: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to enable date-based expiration of built in network"]
    #[doc = " security information (i.e. certificate transparency logs, HSTS preloading"]
    #[doc = " and pinning information). Enabling this option improves network security"]
    #[doc = " but may cause HTTPS load failures when using CEF binaries built more than"]
    #[doc = " 10 weeks in the past. See https://www.certificate-transparency.org/ and"]
    #[doc = " https://www.chromium.org/hsts for details. Can be set globally using the"]
    #[doc = " CefSettings.enable_net_security_expiration value."]
    #[doc = ""]
    pub enable_net_security_expiration: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Comma delimited ordered list of language codes without any whitespace that"]
    #[doc = " will be used in the \"Accept-Language\" HTTP header. Can be set globally"]
    #[doc = " using the CefSettings.accept_language_list value or overridden on a per-"]
    #[doc = " browser basis using the CefBrowserSettings.accept_language_list value. If"]
    #[doc = " all values are empty then \"en-US,en\" will be used. This value will be"]
    #[doc = " ignored if |cache_path| matches the CefSettings.cache_path value."]
    #[doc = ""]
    pub accept_language_list: cef_string_t,
}
#[doc = ""]
#[doc = " Browser initialization settings. Specify NULL or 0 to get the recommended"]
#[doc = " default values. The consequences of using custom values may not be well"]
#[doc = " tested. Many of these and other settings can also configured using command-"]
#[doc = " line switches."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_settings_t {
    #[doc = ""]
    #[doc = " Size of this structure."]
    #[doc = ""]
    pub size: usize,
    #[doc = ""]
    #[doc = " The maximum rate in frames per second (fps) that CefRenderHandler::OnPaint"]
    #[doc = " will be called for a windowless browser. The actual fps may be lower if"]
    #[doc = " the browser cannot generate frames at the requested rate. The minimum"]
    #[doc = " value is 1 and the maximum value is 60 (default 30). This value can also be"]
    #[doc = " changed dynamically via CefBrowserHost::SetWindowlessFrameRate."]
    #[doc = ""]
    pub windowless_frame_rate: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Font settings."]
    #[doc = ""]
    pub standard_font_family: cef_string_t,
    pub fixed_font_family: cef_string_t,
    pub serif_font_family: cef_string_t,
    pub sans_serif_font_family: cef_string_t,
    pub cursive_font_family: cef_string_t,
    pub fantasy_font_family: cef_string_t,
    pub default_font_size: ::std::os::raw::c_int,
    pub default_fixed_font_size: ::std::os::raw::c_int,
    pub minimum_font_size: ::std::os::raw::c_int,
    pub minimum_logical_font_size: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Default encoding for Web content. If empty \"ISO-8859-1\" will be used. Also"]
    #[doc = " configurable using the \"default-encoding\" command-line switch."]
    #[doc = ""]
    pub default_encoding: cef_string_t,
    #[doc = ""]
    #[doc = " Controls the loading of fonts from remote sources. Also configurable using"]
    #[doc = " the \"disable-remote-fonts\" command-line switch."]
    #[doc = ""]
    pub remote_fonts: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether JavaScript can be executed. Also configurable using the"]
    #[doc = " \"disable-javascript\" command-line switch."]
    #[doc = ""]
    pub javascript: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether JavaScript can be used for opening windows. Also"]
    #[doc = " configurable using the \"disable-javascript-open-windows\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub javascript_open_windows: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether JavaScript can be used to close windows that were not"]
    #[doc = " opened via JavaScript. JavaScript can still be used to close windows that"]
    #[doc = " were opened via JavaScript or that have no back/forward history. Also"]
    #[doc = " configurable using the \"disable-javascript-close-windows\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub javascript_close_windows: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether JavaScript can access the clipboard. Also configurable"]
    #[doc = " using the \"disable-javascript-access-clipboard\" command-line switch."]
    #[doc = ""]
    pub javascript_access_clipboard: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether DOM pasting is supported in the editor via"]
    #[doc = " execCommand(\"paste\"). The |javascript_access_clipboard| setting must also"]
    #[doc = " be enabled. Also configurable using the \"disable-javascript-dom-paste\""]
    #[doc = " command-line switch."]
    #[doc = ""]
    pub javascript_dom_paste: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether any plugins will be loaded. Also configurable using the"]
    #[doc = " \"disable-plugins\" command-line switch."]
    #[doc = ""]
    pub plugins: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether file URLs will have access to all URLs. Also configurable"]
    #[doc = " using the \"allow-universal-access-from-files\" command-line switch."]
    #[doc = ""]
    pub universal_access_from_file_urls: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether file URLs will have access to other file URLs. Also"]
    #[doc = " configurable using the \"allow-access-from-files\" command-line switch."]
    #[doc = ""]
    pub file_access_from_file_urls: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether web security restrictions (same-origin policy) will be"]
    #[doc = " enforced. Disabling this setting is not recommend as it will allow risky"]
    #[doc = " security behavior such as cross-site scripting (XSS). Also configurable"]
    #[doc = " using the \"disable-web-security\" command-line switch."]
    #[doc = ""]
    pub web_security: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether image URLs will be loaded from the network. A cached image"]
    #[doc = " will still be rendered if requested. Also configurable using the"]
    #[doc = " \"disable-image-loading\" command-line switch."]
    #[doc = ""]
    pub image_loading: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether standalone images will be shrunk to fit the page. Also"]
    #[doc = " configurable using the \"image-shrink-standalone-to-fit\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub image_shrink_standalone_to_fit: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether text areas can be resized. Also configurable using the"]
    #[doc = " \"disable-text-area-resize\" command-line switch."]
    #[doc = ""]
    pub text_area_resize: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether the tab key can advance focus to links. Also configurable"]
    #[doc = " using the \"disable-tab-to-links\" command-line switch."]
    #[doc = ""]
    pub tab_to_links: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether local storage can be used. Also configurable using the"]
    #[doc = " \"disable-local-storage\" command-line switch."]
    #[doc = ""]
    pub local_storage: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether databases can be used. Also configurable using the"]
    #[doc = " \"disable-databases\" command-line switch."]
    #[doc = ""]
    pub databases: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether the application cache can be used. Also configurable using"]
    #[doc = " the \"disable-application-cache\" command-line switch."]
    #[doc = ""]
    pub application_cache: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether WebGL can be used. Note that WebGL requires hardware"]
    #[doc = " support and may not work on all systems even when enabled. Also"]
    #[doc = " configurable using the \"disable-webgl\" command-line switch."]
    #[doc = ""]
    pub webgl: cef_state_t,
    #[doc = ""]
    #[doc = " Background color used for the browser before a document is loaded and when"]
    #[doc = " no document color is specified. The alpha component must be either fully"]
    #[doc = " opaque (0xFF) or fully transparent (0x00). If the alpha component is fully"]
    #[doc = " opaque then the RGB components will be used as the background color. If the"]
    #[doc = " alpha component is fully transparent for a windowed browser then the"]
    #[doc = " CefSettings.background_color value will be used. If the alpha component is"]
    #[doc = " fully transparent for a windowless (off-screen) browser then transparent"]
    #[doc = " painting will be enabled."]
    #[doc = ""]
    pub background_color: cef_color_t,
    #[doc = ""]
    #[doc = " Comma delimited ordered list of language codes without any whitespace that"]
    #[doc = " will be used in the \"Accept-Language\" HTTP header. May be set globally"]
    #[doc = " using the CefBrowserSettings.accept_language_list value. If both values are"]
    #[doc = " empty then \"en-US,en\" will be used."]
    #[doc = ""]
    pub accept_language_list: cef_string_t,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Return value types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_return_value_t {
    #[doc = ""]
    #[doc = " Cancel immediately."]
    #[doc = ""]
    RV_CANCEL = 0,
    #[doc = ""]
    #[doc = " Continue immediately."]
    #[doc = ""]
    RV_CONTINUE = 1,
    #[doc = ""]
    #[doc = " Continue asynchronously (usually via a callback)."]
    #[doc = ""]
    RV_CONTINUE_ASYNC = 2,
}
#[doc = ""]
#[doc = " Cookie information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_t {
    #[doc = ""]
    #[doc = " The cookie name."]
    #[doc = ""]
    pub name: cef_string_t,
    #[doc = ""]
    #[doc = " The cookie value."]
    #[doc = ""]
    pub value: cef_string_t,
    #[doc = ""]
    #[doc = " If |domain| is empty a host cookie will be created instead of a domain"]
    #[doc = " cookie. Domain cookies are stored with a leading \".\" and are visible to"]
    #[doc = " sub-domains whereas host cookies are not."]
    #[doc = ""]
    pub domain: cef_string_t,
    #[doc = ""]
    #[doc = " If |path| is non-empty only URLs at or below the path will get the cookie"]
    #[doc = " value."]
    #[doc = ""]
    pub path: cef_string_t,
    #[doc = ""]
    #[doc = " If |secure| is true the cookie will only be sent for HTTPS requests."]
    #[doc = ""]
    pub secure: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " If |httponly| is true the cookie will only be sent for HTTP requests."]
    #[doc = ""]
    pub httponly: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The cookie creation date. This is automatically populated by the system on"]
    #[doc = " cookie creation."]
    #[doc = ""]
    pub creation: cef_time_t,
    #[doc = ""]
    #[doc = " The cookie last access date. This is automatically populated by the system"]
    #[doc = " on access."]
    #[doc = ""]
    pub last_access: cef_time_t,
    #[doc = ""]
    #[doc = " The cookie expiration date is only valid if |has_expires| is true."]
    #[doc = ""]
    pub has_expires: ::std::os::raw::c_int,
    pub expires: cef_time_t,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Process termination status values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_termination_status_t {
    #[doc = ""]
    #[doc = " Non-zero exit status."]
    #[doc = ""]
    TS_ABNORMAL_TERMINATION = 0,
    #[doc = ""]
    #[doc = " SIGKILL or task manager kill."]
    #[doc = ""]
    TS_PROCESS_WAS_KILLED = 1,
    #[doc = ""]
    #[doc = " Segmentation fault."]
    #[doc = ""]
    TS_PROCESS_CRASHED = 2,
}
impl cef_errorcode_t {
    pub const ERR_CERT_BEGIN: cef_errorcode_t = cef_errorcode_t::ERR_CERT_COMMON_NAME_INVALID;
}
impl cef_errorcode_t {
    pub const ERR_CERT_END: cef_errorcode_t = cef_errorcode_t::ERR_CERT_VALIDITY_TOO_LONG;
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported error code values. See net\\base\\net_error_list.h for complete"]
#[doc = " descriptions of the error codes."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_errorcode_t {
    ERR_NONE = 0,
    ERR_FAILED = -2,
    ERR_ABORTED = -3,
    ERR_INVALID_ARGUMENT = -4,
    ERR_INVALID_HANDLE = -5,
    ERR_FILE_NOT_FOUND = -6,
    ERR_TIMED_OUT = -7,
    ERR_FILE_TOO_BIG = -8,
    ERR_UNEXPECTED = -9,
    ERR_ACCESS_DENIED = -10,
    ERR_NOT_IMPLEMENTED = -11,
    ERR_CONNECTION_CLOSED = -100,
    ERR_CONNECTION_RESET = -101,
    ERR_CONNECTION_REFUSED = -102,
    ERR_CONNECTION_ABORTED = -103,
    ERR_CONNECTION_FAILED = -104,
    ERR_NAME_NOT_RESOLVED = -105,
    ERR_INTERNET_DISCONNECTED = -106,
    ERR_SSL_PROTOCOL_ERROR = -107,
    ERR_ADDRESS_INVALID = -108,
    ERR_ADDRESS_UNREACHABLE = -109,
    ERR_SSL_CLIENT_AUTH_CERT_NEEDED = -110,
    ERR_TUNNEL_CONNECTION_FAILED = -111,
    ERR_NO_SSL_VERSIONS_ENABLED = -112,
    ERR_SSL_VERSION_OR_CIPHER_MISMATCH = -113,
    ERR_SSL_RENEGOTIATION_REQUESTED = -114,
    ERR_CERT_COMMON_NAME_INVALID = -200,
    ERR_CERT_DATE_INVALID = -201,
    ERR_CERT_AUTHORITY_INVALID = -202,
    ERR_CERT_CONTAINS_ERRORS = -203,
    ERR_CERT_NO_REVOCATION_MECHANISM = -204,
    ERR_CERT_UNABLE_TO_CHECK_REVOCATION = -205,
    ERR_CERT_REVOKED = -206,
    ERR_CERT_INVALID = -207,
    ERR_CERT_WEAK_SIGNATURE_ALGORITHM = -208,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_CERT_NON_UNIQUE_NAME = -210,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_CERT_WEAK_KEY = -211,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_CERT_NAME_CONSTRAINT_VIOLATION = -212,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_CERT_VALIDITY_TOO_LONG = -213,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_INVALID_URL = -300,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_DISALLOWED_URL_SCHEME = -301,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_UNKNOWN_URL_SCHEME = -302,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_TOO_MANY_REDIRECTS = -310,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_UNSAFE_REDIRECT = -311,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_UNSAFE_PORT = -312,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_INVALID_RESPONSE = -320,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_INVALID_CHUNKED_ENCODING = -321,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_METHOD_NOT_SUPPORTED = -322,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_UNEXPECTED_PROXY_AUTH = -323,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_EMPTY_RESPONSE = -324,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_RESPONSE_HEADERS_TOO_BIG = -325,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_CACHE_MISS = -400,
    #[doc = " -209 is available: was ERR_CERT_NOT_IN_DNS."]
    ERR_INSECURE_RESPONSE = -501,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported certificate status code values. See net\\cert\\cert_status_flags.h"]
#[doc = " for more information. CERT_STATUS_NONE is new in CEF because we use an"]
#[doc = " enum while cert_status_flags.h uses a typedef and static const variables."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_cert_status_t {
    CERT_STATUS_NONE = 0,
    CERT_STATUS_COMMON_NAME_INVALID = 1,
    CERT_STATUS_DATE_INVALID = 2,
    CERT_STATUS_AUTHORITY_INVALID = 4,
    #[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
    CERT_STATUS_NO_REVOCATION_MECHANISM = 16,
    #[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
    CERT_STATUS_UNABLE_TO_CHECK_REVOCATION = 32,
    #[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
    CERT_STATUS_REVOKED = 64,
    #[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
    CERT_STATUS_INVALID = 128,
    #[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
    CERT_STATUS_WEAK_SIGNATURE_ALGORITHM = 256,
    #[doc = " 1 << 9 was used for CERT_STATUS_NOT_IN_DNS"]
    CERT_STATUS_NON_UNIQUE_NAME = 1024,
    #[doc = " 1 << 9 was used for CERT_STATUS_NOT_IN_DNS"]
    CERT_STATUS_WEAK_KEY = 2048,
    #[doc = " 1 << 12 was used for CERT_STATUS_WEAK_DH_KEY"]
    CERT_STATUS_PINNED_KEY_MISSING = 8192,
    #[doc = " 1 << 12 was used for CERT_STATUS_WEAK_DH_KEY"]
    CERT_STATUS_NAME_CONSTRAINT_VIOLATION = 16384,
    #[doc = " 1 << 12 was used for CERT_STATUS_WEAK_DH_KEY"]
    CERT_STATUS_VALIDITY_TOO_LONG = 32768,
    #[doc = " Bits 16 to 31 are for non-error statuses."]
    CERT_STATUS_IS_EV = 65536,
    #[doc = " Bits 16 to 31 are for non-error statuses."]
    CERT_STATUS_REV_CHECKING_ENABLED = 131072,
    #[doc = " Bit 18 was CERT_STATUS_IS_DNSSEC"]
    CERT_STATUS_SHA1_SIGNATURE_PRESENT = 524288,
    #[doc = " Bit 18 was CERT_STATUS_IS_DNSSEC"]
    CERT_STATUS_CT_COMPLIANCE_FAILED = 1048576,
}
#[repr(i32)]
#[doc = ""]
#[doc = " The manner in which a link click should be opened. These constants match"]
#[doc = " their equivalents in Chromium's window_open_disposition.h and should not be"]
#[doc = " renumbered."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_window_open_disposition_t {
    WOD_UNKNOWN = 0,
    WOD_CURRENT_TAB = 1,
    WOD_SINGLETON_TAB = 2,
    WOD_NEW_FOREGROUND_TAB = 3,
    WOD_NEW_BACKGROUND_TAB = 4,
    WOD_NEW_POPUP = 5,
    WOD_NEW_WINDOW = 6,
    WOD_SAVE_TO_DISK = 7,
    WOD_OFF_THE_RECORD = 8,
    WOD_IGNORE_ACTION = 9,
}
#[repr(i32)]
#[doc = ""]
#[doc = " \"Verb\" of a drag-and-drop operation as negotiated between the source and"]
#[doc = " destination. These constants match their equivalents in WebCore's"]
#[doc = " DragActions.h and should not be renumbered."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_drag_operations_mask_t {
    DRAG_OPERATION_NONE = 0,
    DRAG_OPERATION_COPY = 1,
    DRAG_OPERATION_LINK = 2,
    DRAG_OPERATION_GENERIC = 4,
    DRAG_OPERATION_PRIVATE = 8,
    DRAG_OPERATION_MOVE = 16,
    DRAG_OPERATION_DELETE = 32,
    DRAG_OPERATION_EVERY = -1,
}
#[repr(i32)]
#[doc = ""]
#[doc = " V8 access control values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_v8_accesscontrol_t {
    V8_ACCESS_CONTROL_DEFAULT = 0,
    V8_ACCESS_CONTROL_ALL_CAN_READ = 1,
    V8_ACCESS_CONTROL_ALL_CAN_WRITE = 2,
    V8_ACCESS_CONTROL_PROHIBITS_OVERWRITING = 4,
}
#[repr(i32)]
#[doc = ""]
#[doc = " V8 property attribute values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_v8_propertyattribute_t {
    #[doc = " Writeable, Enumerable,"]
    #[doc = "   Configurable"]
    V8_PROPERTY_ATTRIBUTE_NONE = 0,
    #[doc = " Not writeable"]
    V8_PROPERTY_ATTRIBUTE_READONLY = 1,
    #[doc = " Not enumerable"]
    V8_PROPERTY_ATTRIBUTE_DONTENUM = 2,
    #[doc = " Not configurable"]
    V8_PROPERTY_ATTRIBUTE_DONTDELETE = 4,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Post data elements may represent either bytes or files."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_postdataelement_type_t {
    PDE_TYPE_EMPTY = 0,
    PDE_TYPE_BYTES = 1,
    PDE_TYPE_FILE = 2,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Resource type for a request."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_resource_type_t {
    #[doc = ""]
    #[doc = " Top level page."]
    #[doc = ""]
    RT_MAIN_FRAME = 0,
    #[doc = ""]
    #[doc = " Frame or iframe."]
    #[doc = ""]
    RT_SUB_FRAME = 1,
    #[doc = ""]
    #[doc = " CSS stylesheet."]
    #[doc = ""]
    RT_STYLESHEET = 2,
    #[doc = ""]
    #[doc = " External script."]
    #[doc = ""]
    RT_SCRIPT = 3,
    #[doc = ""]
    #[doc = " Image (jpg/gif/png/etc)."]
    #[doc = ""]
    RT_IMAGE = 4,
    #[doc = ""]
    #[doc = " Font."]
    #[doc = ""]
    RT_FONT_RESOURCE = 5,
    #[doc = ""]
    #[doc = " Some other subresource. This is the default type if the actual type is"]
    #[doc = " unknown."]
    #[doc = ""]
    RT_SUB_RESOURCE = 6,
    #[doc = ""]
    #[doc = " Object (or embed) tag for a plugin, or a resource that a plugin requested."]
    #[doc = ""]
    RT_OBJECT = 7,
    #[doc = ""]
    #[doc = " Media resource."]
    #[doc = ""]
    RT_MEDIA = 8,
    #[doc = ""]
    #[doc = " Main resource of a dedicated worker."]
    #[doc = ""]
    RT_WORKER = 9,
    #[doc = ""]
    #[doc = " Main resource of a shared worker."]
    #[doc = ""]
    RT_SHARED_WORKER = 10,
    #[doc = ""]
    #[doc = " Explicitly requested prefetch."]
    #[doc = ""]
    RT_PREFETCH = 11,
    #[doc = ""]
    #[doc = " Favicon."]
    #[doc = ""]
    RT_FAVICON = 12,
    #[doc = ""]
    #[doc = " XMLHttpRequest."]
    #[doc = ""]
    RT_XHR = 13,
    #[doc = ""]
    #[doc = " A request for a <ping>"]
    #[doc = ""]
    RT_PING = 14,
    #[doc = ""]
    #[doc = " Main resource of a service worker."]
    #[doc = ""]
    RT_SERVICE_WORKER = 15,
    #[doc = ""]
    #[doc = " A report of Content Security Policy violations."]
    #[doc = ""]
    RT_CSP_REPORT = 16,
    #[doc = ""]
    #[doc = " A resource that a plugin requested."]
    #[doc = ""]
    RT_PLUGIN_RESOURCE = 17,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Transition type for a request. Made up of one source value and 0 or more"]
#[doc = " qualifiers."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_transition_type_t {
    #[doc = ""]
    #[doc = " Source is a link click or the JavaScript window.open function. This is"]
    #[doc = " also the default value for requests like sub-resource loads that are not"]
    #[doc = " navigations."]
    #[doc = ""]
    TT_LINK = 0,
    #[doc = ""]
    #[doc = " Source is some other \"explicit\" navigation action such as creating a new"]
    #[doc = " browser or using the LoadURL function. This is also the default value"]
    #[doc = " for navigations where the actual type is unknown."]
    #[doc = ""]
    TT_EXPLICIT = 1,
    #[doc = ""]
    #[doc = " Source is a subframe navigation. This is any content that is automatically"]
    #[doc = " loaded in a non-toplevel frame. For example, if a page consists of several"]
    #[doc = " frames containing ads, those ad URLs will have this transition type."]
    #[doc = " The user may not even realize the content in these pages is a separate"]
    #[doc = " frame, so may not care about the URL."]
    #[doc = ""]
    TT_AUTO_SUBFRAME = 3,
    #[doc = ""]
    #[doc = " Source is a subframe navigation explicitly requested by the user that will"]
    #[doc = " generate new navigation entries in the back/forward list. These are"]
    #[doc = " probably more important than frames that were automatically loaded in"]
    #[doc = " the background because the user probably cares about the fact that this"]
    #[doc = " link was loaded."]
    #[doc = ""]
    TT_MANUAL_SUBFRAME = 4,
    #[doc = ""]
    #[doc = " Source is a form submission by the user. NOTE: In some situations"]
    #[doc = " submitting a form does not result in this transition type. This can happen"]
    #[doc = " if the form uses a script to submit the contents."]
    #[doc = ""]
    TT_FORM_SUBMIT = 7,
    #[doc = ""]
    #[doc = " Source is a \"reload\" of the page via the Reload function or by re-visiting"]
    #[doc = " the same URL. NOTE: This is distinct from the concept of whether a"]
    #[doc = " particular load uses \"reload semantics\" (i.e. bypasses cached data)."]
    #[doc = ""]
    TT_RELOAD = 8,
    #[doc = ""]
    #[doc = " General mask defining the bits used for the source values."]
    #[doc = ""]
    TT_SOURCE_MASK = 255,
    #[doc = ""]
    #[doc = " Attempted to visit a URL but was blocked."]
    #[doc = ""]
    TT_BLOCKED_FLAG = 8388608,
    #[doc = ""]
    #[doc = " Used the Forward or Back function to navigate among browsing history."]
    #[doc = ""]
    TT_FORWARD_BACK_FLAG = 16777216,
    #[doc = ""]
    #[doc = " The beginning of a navigation chain."]
    #[doc = ""]
    TT_CHAIN_START_FLAG = 268435456,
    #[doc = ""]
    #[doc = " The last transition in a redirect chain."]
    #[doc = ""]
    TT_CHAIN_END_FLAG = 536870912,
    #[doc = ""]
    #[doc = " Redirects caused by JavaScript or a meta refresh tag on the page."]
    #[doc = ""]
    TT_CLIENT_REDIRECT_FLAG = 1073741824,
    #[doc = ""]
    #[doc = " Redirects sent from the server by HTTP headers."]
    #[doc = ""]
    TT_SERVER_REDIRECT_FLAG = -2147483648,
    #[doc = ""]
    #[doc = " Used to test whether a transition involves a redirect."]
    #[doc = ""]
    TT_IS_REDIRECT_MASK = -1073741824,
    #[doc = ""]
    #[doc = " General mask defining the bits used for the qualifiers."]
    #[doc = ""]
    TT_QUALIFIER_MASK = -256,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Flags that represent CefURLRequest status."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_urlrequest_status_t {
    #[doc = ""]
    #[doc = " Unknown status."]
    #[doc = ""]
    UR_UNKNOWN = 0,
    #[doc = ""]
    #[doc = " Request succeeded."]
    #[doc = ""]
    UR_SUCCESS = 1,
    #[doc = ""]
    #[doc = " An IO request is pending, and the caller will be informed when it is"]
    #[doc = " completed."]
    #[doc = ""]
    UR_IO_PENDING = 2,
    #[doc = ""]
    #[doc = " Request was canceled programatically."]
    #[doc = ""]
    UR_CANCELED = 3,
    #[doc = ""]
    #[doc = " Request failed for some reason."]
    #[doc = ""]
    UR_FAILED = 4,
}
#[doc = ""]
#[doc = " Structure representing a point."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_point_t {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[doc = ""]
#[doc = " Structure representing a point."]
#[doc = ""]
pub type cef_point_t = _cef_point_t;
#[doc = ""]
#[doc = " Structure representing a rectangle."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_rect_t {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[doc = ""]
#[doc = " Structure representing a rectangle."]
#[doc = ""]
pub type cef_rect_t = _cef_rect_t;
#[doc = ""]
#[doc = " Structure representing a size."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_size_t {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[doc = ""]
#[doc = " Structure representing a size."]
#[doc = ""]
pub type cef_size_t = _cef_size_t;
#[doc = ""]
#[doc = " Structure representing a range."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_range_t {
    pub from: ::std::os::raw::c_int,
    pub to: ::std::os::raw::c_int,
}
#[doc = ""]
#[doc = " Structure representing a range."]
#[doc = ""]
pub type cef_range_t = _cef_range_t;
#[doc = ""]
#[doc = " Structure representing a draggable region."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_draggable_region_t {
    #[doc = ""]
    #[doc = " Bounds of the region."]
    #[doc = ""]
    pub bounds: cef_rect_t,
    #[doc = ""]
    #[doc = " True (1) this this region is draggable and false (0) otherwise."]
    #[doc = ""]
    pub draggable: ::std::os::raw::c_int,
}
#[doc = ""]
#[doc = " Structure representing a draggable region."]
#[doc = ""]
pub type cef_draggable_region_t = _cef_draggable_region_t;
#[repr(i32)]
#[doc = ""]
#[doc = " Existing process IDs."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_process_id_t {
    #[doc = ""]
    #[doc = " Browser process."]
    #[doc = ""]
    PID_BROWSER = 0,
    #[doc = ""]
    #[doc = " Renderer process."]
    #[doc = ""]
    PID_RENDERER = 1,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Existing thread IDs."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_thread_id_t {
    #[doc = ""]
    #[doc = " The main thread in the browser. This will be the same as the main"]
    #[doc = " application thread if CefInitialize() is called with a"]
    #[doc = " CefSettings.multi_threaded_message_loop value of false."]
    #[doc = ""]
    TID_UI = 0,
    #[doc = ""]
    #[doc = " Used to interact with the database."]
    #[doc = ""]
    TID_DB = 1,
    #[doc = ""]
    #[doc = " Used to interact with the file system."]
    #[doc = ""]
    TID_FILE = 2,
    #[doc = ""]
    #[doc = " Used for file system operations that block user interactions."]
    #[doc = " Responsiveness of this thread affects users."]
    #[doc = ""]
    TID_FILE_USER_BLOCKING = 3,
    #[doc = ""]
    #[doc = " Used to launch and terminate browser processes."]
    #[doc = ""]
    TID_PROCESS_LAUNCHER = 4,
    #[doc = ""]
    #[doc = " Used to handle slow HTTP cache operations."]
    #[doc = ""]
    TID_CACHE = 5,
    #[doc = ""]
    #[doc = " Used to process IPC and network messages."]
    #[doc = ""]
    TID_IO = 6,
    #[doc = ""]
    #[doc = " The main thread in the renderer. Used for all WebKit and V8 interaction."]
    #[doc = ""]
    TID_RENDERER = 7,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported value types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_value_type_t {
    VTYPE_INVALID = 0,
    VTYPE_NULL = 1,
    VTYPE_BOOL = 2,
    VTYPE_INT = 3,
    VTYPE_DOUBLE = 4,
    VTYPE_STRING = 5,
    VTYPE_BINARY = 6,
    VTYPE_DICTIONARY = 7,
    VTYPE_LIST = 8,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported JavaScript dialog types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_jsdialog_type_t {
    JSDIALOGTYPE_ALERT = 0,
    JSDIALOGTYPE_CONFIRM = 1,
    JSDIALOGTYPE_PROMPT = 2,
}
#[doc = ""]
#[doc = " Screen information used when window rendering is disabled. This structure is"]
#[doc = " passed as a parameter to CefRenderHandler::GetScreenInfo and should be filled"]
#[doc = " in by the client."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_screen_info_t {
    #[doc = ""]
    #[doc = " Device scale factor. Specifies the ratio between physical and logical"]
    #[doc = " pixels."]
    #[doc = ""]
    pub device_scale_factor: f32,
    #[doc = ""]
    #[doc = " The screen depth in bits per pixel."]
    #[doc = ""]
    pub depth: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The bits per color component. This assumes that the colors are balanced"]
    #[doc = " equally."]
    #[doc = ""]
    pub depth_per_component: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " This can be true for black and white printers."]
    #[doc = ""]
    pub is_monochrome: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " This is set from the rcMonitor member of MONITORINFOEX, to whit:"]
    #[doc = "   \"A RECT structure that specifies the display monitor rectangle,"]
    #[doc = "   expressed in virtual-screen coordinates. Note that if the monitor"]
    #[doc = "   is not the primary display monitor, some of the rectangle's"]
    #[doc = "   coordinates may be negative values.\""]
    #[doc = ""]
    #[doc = " The |rect| and |available_rect| properties are used to determine the"]
    #[doc = " available surface for rendering popup views."]
    #[doc = ""]
    pub rect: cef_rect_t,
    #[doc = ""]
    #[doc = " This is set from the rcWork member of MONITORINFOEX, to whit:"]
    #[doc = "   \"A RECT structure that specifies the work area rectangle of the"]
    #[doc = "   display monitor that can be used by applications, expressed in"]
    #[doc = "   virtual-screen coordinates. Windows uses this rectangle to"]
    #[doc = "   maximize an application on the monitor. The rest of the area in"]
    #[doc = "   rcMonitor contains system windows such as the task bar and side"]
    #[doc = "   bars. Note that if the monitor is not the primary display monitor,"]
    #[doc = "   some of the rectangle's coordinates may be negative values\"."]
    #[doc = ""]
    #[doc = " The |rect| and |available_rect| properties are used to determine the"]
    #[doc = " available surface for rendering popup views."]
    #[doc = ""]
    pub available_rect: cef_rect_t,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Mouse button types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_mouse_button_type_t {
    MBT_LEFT = 0,
    MBT_MIDDLE = 1,
    MBT_RIGHT = 2,
}
#[doc = ""]
#[doc = " Structure representing mouse event information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_mouse_event_t {
    #[doc = ""]
    #[doc = " X coordinate relative to the left side of the view."]
    #[doc = ""]
    pub x: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Y coordinate relative to the top side of the view."]
    #[doc = ""]
    pub y: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Bit flags describing any pressed modifier keys. See"]
    #[doc = " cef_event_flags_t for values."]
    #[doc = ""]
    pub modifiers: uint32,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Paint element types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_paint_element_type_t {
    PET_VIEW = 0,
    PET_POPUP = 1,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported event bit flags."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_event_flags_t {
    EVENTFLAG_NONE = 0,
    EVENTFLAG_CAPS_LOCK_ON = 1,
    EVENTFLAG_SHIFT_DOWN = 2,
    EVENTFLAG_CONTROL_DOWN = 4,
    EVENTFLAG_ALT_DOWN = 8,
    EVENTFLAG_LEFT_MOUSE_BUTTON = 16,
    EVENTFLAG_MIDDLE_MOUSE_BUTTON = 32,
    EVENTFLAG_RIGHT_MOUSE_BUTTON = 64,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_COMMAND_DOWN = 128,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_NUM_LOCK_ON = 256,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_IS_KEY_PAD = 512,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_IS_LEFT = 1024,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_IS_RIGHT = 2048,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported menu item types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_menu_item_type_t {
    MENUITEMTYPE_NONE = 0,
    MENUITEMTYPE_COMMAND = 1,
    MENUITEMTYPE_CHECK = 2,
    MENUITEMTYPE_RADIO = 3,
    MENUITEMTYPE_SEPARATOR = 4,
    MENUITEMTYPE_SUBMENU = 5,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported context menu type flags."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_context_menu_type_flags_t {
    #[doc = ""]
    #[doc = " No node is selected."]
    #[doc = ""]
    CM_TYPEFLAG_NONE = 0,
    #[doc = ""]
    #[doc = " The top page is selected."]
    #[doc = ""]
    CM_TYPEFLAG_PAGE = 1,
    #[doc = ""]
    #[doc = " A subframe page is selected."]
    #[doc = ""]
    CM_TYPEFLAG_FRAME = 2,
    #[doc = ""]
    #[doc = " A link is selected."]
    #[doc = ""]
    CM_TYPEFLAG_LINK = 4,
    #[doc = ""]
    #[doc = " A media node is selected."]
    #[doc = ""]
    CM_TYPEFLAG_MEDIA = 8,
    #[doc = ""]
    #[doc = " There is a textual or mixed selection that is selected."]
    #[doc = ""]
    CM_TYPEFLAG_SELECTION = 16,
    #[doc = ""]
    #[doc = " An editable element is selected."]
    #[doc = ""]
    CM_TYPEFLAG_EDITABLE = 32,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported context menu media types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_context_menu_media_type_t {
    #[doc = ""]
    #[doc = " No special node is in context."]
    #[doc = ""]
    CM_MEDIATYPE_NONE = 0,
    #[doc = ""]
    #[doc = " An image node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_IMAGE = 1,
    #[doc = ""]
    #[doc = " A video node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_VIDEO = 2,
    #[doc = ""]
    #[doc = " An audio node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_AUDIO = 3,
    #[doc = ""]
    #[doc = " A file node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_FILE = 4,
    #[doc = ""]
    #[doc = " A plugin node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_PLUGIN = 5,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported context menu media state bit flags."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_context_menu_media_state_flags_t {
    CM_MEDIAFLAG_NONE = 0,
    CM_MEDIAFLAG_ERROR = 1,
    CM_MEDIAFLAG_PAUSED = 2,
    CM_MEDIAFLAG_MUTED = 4,
    CM_MEDIAFLAG_LOOP = 8,
    CM_MEDIAFLAG_CAN_SAVE = 16,
    CM_MEDIAFLAG_HAS_AUDIO = 32,
    CM_MEDIAFLAG_HAS_VIDEO = 64,
    CM_MEDIAFLAG_CONTROL_ROOT_ELEMENT = 128,
    CM_MEDIAFLAG_CAN_PRINT = 256,
    CM_MEDIAFLAG_CAN_ROTATE = 512,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported context menu edit state bit flags."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_context_menu_edit_state_flags_t {
    CM_EDITFLAG_NONE = 0,
    CM_EDITFLAG_CAN_UNDO = 1,
    CM_EDITFLAG_CAN_REDO = 2,
    CM_EDITFLAG_CAN_CUT = 4,
    CM_EDITFLAG_CAN_COPY = 8,
    CM_EDITFLAG_CAN_PASTE = 16,
    CM_EDITFLAG_CAN_DELETE = 32,
    CM_EDITFLAG_CAN_SELECT_ALL = 64,
    CM_EDITFLAG_CAN_TRANSLATE = 128,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Key event types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_key_event_type_t {
    #[doc = ""]
    #[doc = " Notification that a key transitioned from \"up\" to \"down\"."]
    #[doc = ""]
    KEYEVENT_RAWKEYDOWN = 0,
    #[doc = ""]
    #[doc = " Notification that a key was pressed. This does not necessarily correspond"]
    #[doc = " to a character depending on the key and language. Use KEYEVENT_CHAR for"]
    #[doc = " character input."]
    #[doc = ""]
    KEYEVENT_KEYDOWN = 1,
    #[doc = ""]
    #[doc = " Notification that a key was released."]
    #[doc = ""]
    KEYEVENT_KEYUP = 2,
    #[doc = ""]
    #[doc = " Notification that a character was typed. Use this for text input. Key"]
    #[doc = " down events may generate 0, 1, or more than one character event depending"]
    #[doc = " on the key, locale, and operating system."]
    #[doc = ""]
    KEYEVENT_CHAR = 3,
}
#[doc = ""]
#[doc = " Structure representing keyboard event information."]
#[doc = ""]
#[repr(C)]
pub struct _cef_key_event_t {
    #[doc = ""]
    #[doc = " The type of keyboard event."]
    #[doc = ""]
    pub type_: cef_key_event_type_t,
    #[doc = ""]
    #[doc = " Bit flags describing any pressed modifier keys. See"]
    #[doc = " cef_event_flags_t for values."]
    #[doc = ""]
    pub modifiers: uint32,
    #[doc = ""]
    #[doc = " The Windows key code for the key event. This value is used by the DOM"]
    #[doc = " specification. Sometimes it comes directly from the event (i.e. on"]
    #[doc = " Windows) and sometimes it's determined using a mapping function. See"]
    #[doc = " WebCore/platform/chromium/KeyboardCodes.h for the list of values."]
    #[doc = ""]
    pub windows_key_code: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The actual key code genenerated by the platform."]
    #[doc = ""]
    pub native_key_code: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Indicates whether the event is considered a \"system key\" event (see"]
    #[doc = " http://msdn.microsoft.com/en-us/library/ms646286(VS.85).aspx for details)."]
    #[doc = " This value will always be false on non-Windows platforms."]
    #[doc = ""]
    pub is_system_key: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The character generated by the keystroke."]
    #[doc = ""]
    pub character: char16,
    #[doc = ""]
    #[doc = " Same as |character| but unmodified by any concurrently-held modifiers"]
    #[doc = " (except shift). This is useful for working out shortcut keys."]
    #[doc = ""]
    pub unmodified_character: char16,
    #[doc = ""]
    #[doc = " True if the focus is currently on an editable field on the page. This is"]
    #[doc = " useful for determining if standard key events should be intercepted."]
    #[doc = ""]
    pub focus_on_editable_field: ::std::os::raw::c_int,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Focus sources."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_focus_source_t {
    #[doc = ""]
    #[doc = " The source is explicit navigation via the API (LoadURL(), etc)."]
    #[doc = ""]
    FOCUS_SOURCE_NAVIGATION = 0,
    #[doc = ""]
    #[doc = " The source is a system-generated focus event."]
    #[doc = ""]
    FOCUS_SOURCE_SYSTEM = 1,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Navigation types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_navigation_type_t {
    NAVIGATION_LINK_CLICKED = 0,
    NAVIGATION_FORM_SUBMITTED = 1,
    NAVIGATION_BACK_FORWARD = 2,
    NAVIGATION_RELOAD = 3,
    NAVIGATION_FORM_RESUBMITTED = 4,
    NAVIGATION_OTHER = 5,
}
#[doc = ""]
#[doc = " Popup window features."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_popup_features_t {
    pub x: ::std::os::raw::c_int,
    pub xSet: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub ySet: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub widthSet: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub heightSet: ::std::os::raw::c_int,
    pub menuBarVisible: ::std::os::raw::c_int,
    pub statusBarVisible: ::std::os::raw::c_int,
    pub toolBarVisible: ::std::os::raw::c_int,
    pub locationBarVisible: ::std::os::raw::c_int,
    pub scrollbarsVisible: ::std::os::raw::c_int,
    pub resizable: ::std::os::raw::c_int,
    pub fullscreen: ::std::os::raw::c_int,
    pub dialog: ::std::os::raw::c_int,
}
#[repr(i32)]
#[doc = ""]
#[doc = " DOM document types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_dom_document_type_t {
    DOM_DOCUMENT_TYPE_UNKNOWN = 0,
    DOM_DOCUMENT_TYPE_HTML = 1,
    DOM_DOCUMENT_TYPE_XHTML = 2,
    DOM_DOCUMENT_TYPE_PLUGIN = 3,
}
#[repr(i32)]
#[doc = ""]
#[doc = " DOM node types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_dom_node_type_t {
    DOM_NODE_TYPE_UNSUPPORTED = 0,
    DOM_NODE_TYPE_ELEMENT = 1,
    DOM_NODE_TYPE_ATTRIBUTE = 2,
    DOM_NODE_TYPE_TEXT = 3,
    DOM_NODE_TYPE_CDATA_SECTION = 4,
    DOM_NODE_TYPE_PROCESSING_INSTRUCTIONS = 5,
    DOM_NODE_TYPE_COMMENT = 6,
    DOM_NODE_TYPE_DOCUMENT = 7,
    DOM_NODE_TYPE_DOCUMENT_TYPE = 8,
    DOM_NODE_TYPE_DOCUMENT_FRAGMENT = 9,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported file dialog modes."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_file_dialog_mode_t {
    #[doc = ""]
    #[doc = " Requires that the file exists before allowing the user to pick it."]
    #[doc = ""]
    FILE_DIALOG_OPEN = 0,
    #[doc = ""]
    #[doc = " Like Open, but allows picking multiple files to open."]
    #[doc = ""]
    FILE_DIALOG_OPEN_MULTIPLE = 1,
    #[doc = ""]
    #[doc = " Like Open, but selects a folder to open."]
    #[doc = ""]
    FILE_DIALOG_OPEN_FOLDER = 2,
    #[doc = ""]
    #[doc = " Allows picking a nonexistent file, and prompts to overwrite if the file"]
    #[doc = " already exists."]
    #[doc = ""]
    FILE_DIALOG_SAVE = 3,
    #[doc = ""]
    #[doc = " General mask defining the bits used for the type values."]
    #[doc = ""]
    FILE_DIALOG_TYPE_MASK = 255,
    #[doc = ""]
    #[doc = " Prompt to overwrite if the user selects an existing file with the Save"]
    #[doc = " dialog."]
    #[doc = ""]
    FILE_DIALOG_OVERWRITEPROMPT_FLAG = 16777216,
    #[doc = ""]
    #[doc = " Do not display read-only files."]
    #[doc = ""]
    FILE_DIALOG_HIDEREADONLY_FLAG = 33554432,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Print job color mode values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_color_model_t {
    COLOR_MODEL_UNKNOWN = 0,
    COLOR_MODEL_GRAY = 1,
    COLOR_MODEL_COLOR = 2,
    COLOR_MODEL_CMYK = 3,
    COLOR_MODEL_CMY = 4,
    COLOR_MODEL_KCMY = 5,
    #[doc = " CMY_K represents CMY+K."]
    COLOR_MODEL_CMY_K = 6,
    COLOR_MODEL_BLACK = 7,
    COLOR_MODEL_GRAYSCALE = 8,
    COLOR_MODEL_RGB = 9,
    COLOR_MODEL_RGB16 = 10,
    COLOR_MODEL_RGBA = 11,
    #[doc = " Used in samsung printer ppds."]
    COLOR_MODEL_COLORMODE_COLOR = 12,
    #[doc = " Used in samsung printer ppds."]
    COLOR_MODEL_COLORMODE_MONOCHROME = 13,
    #[doc = " Used in HP color printer ppds."]
    COLOR_MODEL_HP_COLOR_COLOR = 14,
    #[doc = " Used in HP color printer ppds."]
    COLOR_MODEL_HP_COLOR_BLACK = 15,
    #[doc = " Used in foomatic ppds."]
    COLOR_MODEL_PRINTOUTMODE_NORMAL = 16,
    #[doc = " Used in foomatic ppds."]
    COLOR_MODEL_PRINTOUTMODE_NORMAL_GRAY = 17,
    #[doc = " Used in canon printer ppds."]
    COLOR_MODEL_PROCESSCOLORMODEL_CMYK = 18,
    #[doc = " Used in canon printer ppds."]
    COLOR_MODEL_PROCESSCOLORMODEL_GREYSCALE = 19,
    #[doc = " Used in canon printer ppds"]
    COLOR_MODEL_PROCESSCOLORMODEL_RGB = 20,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Print job duplex mode values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_duplex_mode_t {
    DUPLEX_MODE_UNKNOWN = -1,
    DUPLEX_MODE_SIMPLEX = 0,
    DUPLEX_MODE_LONG_EDGE = 1,
    DUPLEX_MODE_SHORT_EDGE = 2,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Cursor type values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_cursor_type_t {
    CT_POINTER = 0,
    CT_CROSS = 1,
    CT_HAND = 2,
    CT_IBEAM = 3,
    CT_WAIT = 4,
    CT_HELP = 5,
    CT_EASTRESIZE = 6,
    CT_NORTHRESIZE = 7,
    CT_NORTHEASTRESIZE = 8,
    CT_NORTHWESTRESIZE = 9,
    CT_SOUTHRESIZE = 10,
    CT_SOUTHEASTRESIZE = 11,
    CT_SOUTHWESTRESIZE = 12,
    CT_WESTRESIZE = 13,
    CT_NORTHSOUTHRESIZE = 14,
    CT_EASTWESTRESIZE = 15,
    CT_NORTHEASTSOUTHWESTRESIZE = 16,
    CT_NORTHWESTSOUTHEASTRESIZE = 17,
    CT_COLUMNRESIZE = 18,
    CT_ROWRESIZE = 19,
    CT_MIDDLEPANNING = 20,
    CT_EASTPANNING = 21,
    CT_NORTHPANNING = 22,
    CT_NORTHEASTPANNING = 23,
    CT_NORTHWESTPANNING = 24,
    CT_SOUTHPANNING = 25,
    CT_SOUTHEASTPANNING = 26,
    CT_SOUTHWESTPANNING = 27,
    CT_WESTPANNING = 28,
    CT_MOVE = 29,
    CT_VERTICALTEXT = 30,
    CT_CELL = 31,
    CT_CONTEXTMENU = 32,
    CT_ALIAS = 33,
    CT_PROGRESS = 34,
    CT_NODROP = 35,
    CT_COPY = 36,
    CT_NONE = 37,
    CT_NOTALLOWED = 38,
    CT_ZOOMIN = 39,
    CT_ZOOMOUT = 40,
    CT_GRAB = 41,
    CT_GRABBING = 42,
    CT_CUSTOM = 43,
}
#[doc = ""]
#[doc = " Structure representing cursor information. |buffer| will be"]
#[doc = " |size.width|*|size.height|*4 bytes in size and represents a BGRA image with"]
#[doc = " an upper-left origin."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cursor_info_t {
    pub hotspot: cef_point_t,
    pub image_scale_factor: f32,
    pub buffer: *mut ::std::os::raw::c_void,
    pub size: cef_size_t,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Margin type for PDF printing."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_pdf_print_margin_type_t {
    #[doc = ""]
    #[doc = " Default margins."]
    #[doc = ""]
    PDF_PRINT_MARGIN_DEFAULT = 0,
    #[doc = ""]
    #[doc = " No margins."]
    #[doc = ""]
    PDF_PRINT_MARGIN_NONE = 1,
    #[doc = ""]
    #[doc = " Minimum margins."]
    #[doc = ""]
    PDF_PRINT_MARGIN_MINIMUM = 2,
    #[doc = ""]
    #[doc = " Custom margins using the |margin_*| values from cef_pdf_print_settings_t."]
    #[doc = ""]
    PDF_PRINT_MARGIN_CUSTOM = 3,
}
#[doc = ""]
#[doc = " Structure representing PDF print settings."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_pdf_print_settings_t {
    #[doc = ""]
    #[doc = " Page title to display in the header. Only used if |header_footer_enabled|"]
    #[doc = " is set to true (1)."]
    #[doc = ""]
    pub header_footer_title: cef_string_t,
    #[doc = ""]
    #[doc = " URL to display in the footer. Only used if |header_footer_enabled| is set"]
    #[doc = " to true (1)."]
    #[doc = ""]
    pub header_footer_url: cef_string_t,
    #[doc = ""]
    #[doc = " Output page size in microns. If either of these values is less than or"]
    #[doc = " equal to zero then the default paper size (A4) will be used."]
    #[doc = ""]
    pub page_width: ::std::os::raw::c_int,
    pub page_height: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The percentage to scale the PDF by before printing (e.g. 50 is 50%)."]
    #[doc = " If this value is less than or equal to zero the default value of 100"]
    #[doc = " will be used."]
    #[doc = ""]
    pub scale_factor: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Margins in millimeters. Only used if |margin_type| is set to"]
    #[doc = " PDF_PRINT_MARGIN_CUSTOM."]
    #[doc = ""]
    pub margin_top: f64,
    pub margin_right: f64,
    pub margin_bottom: f64,
    pub margin_left: f64,
    #[doc = ""]
    #[doc = " Margin type."]
    #[doc = ""]
    pub margin_type: cef_pdf_print_margin_type_t,
    #[doc = ""]
    #[doc = " Set to true (1) to print headers and footers or false (0) to not print"]
    #[doc = " headers and footers."]
    #[doc = ""]
    pub header_footer_enabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to print the selection only or false (0) to print all."]
    #[doc = ""]
    pub selection_only: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) for landscape mode or false (0) for portrait mode."]
    #[doc = ""]
    pub landscape: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to print background graphics or false (0) to not print"]
    #[doc = " background graphics."]
    #[doc = ""]
    pub backgrounds_enabled: ::std::os::raw::c_int,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported UI scale factors for the platform. SCALE_FACTOR_NONE is used for"]
#[doc = " density independent resources such as string, html/js files or an image that"]
#[doc = " can be used for any scale factors (such as wallpapers)."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_scale_factor_t {
    SCALE_FACTOR_NONE = 0,
    SCALE_FACTOR_100P = 1,
    SCALE_FACTOR_125P = 2,
    SCALE_FACTOR_133P = 3,
    SCALE_FACTOR_140P = 4,
    SCALE_FACTOR_150P = 5,
    SCALE_FACTOR_180P = 6,
    SCALE_FACTOR_200P = 7,
    SCALE_FACTOR_250P = 8,
    SCALE_FACTOR_300P = 9,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Plugin policies supported by CefRequestContextHandler::OnBeforePluginLoad."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_plugin_policy_t {
    #[doc = ""]
    #[doc = " Allow the content."]
    #[doc = ""]
    PLUGIN_POLICY_ALLOW = 0,
    #[doc = ""]
    #[doc = " Allow important content and block unimportant content based on heuristics."]
    #[doc = " The user can manually load blocked content."]
    #[doc = ""]
    PLUGIN_POLICY_DETECT_IMPORTANT = 1,
    #[doc = ""]
    #[doc = " Block the content. The user can manually load blocked content."]
    #[doc = ""]
    PLUGIN_POLICY_BLOCK = 2,
    #[doc = ""]
    #[doc = " Disable the content. The user cannot load disabled content."]
    #[doc = ""]
    PLUGIN_POLICY_DISABLE = 3,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Policy for how the Referrer HTTP header value will be sent during navigation."]
#[doc = " If the `--no-referrers` command-line flag is specified then the policy value"]
#[doc = " will be ignored and the Referrer value will never be sent."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_referrer_policy_t {
    #[doc = ""]
    #[doc = " Always send the complete Referrer value."]
    #[doc = ""]
    REFERRER_POLICY_ALWAYS = 0,
    #[doc = ""]
    #[doc = " Use the default policy. This is REFERRER_POLICY_ORIGIN_WHEN_CROSS_ORIGIN"]
    #[doc = " when the `--reduced-referrer-granularity` command-line flag is specified"]
    #[doc = " and REFERRER_POLICY_NO_REFERRER_WHEN_DOWNGRADE otherwise."]
    #[doc = ""]
    #[doc = ""]
    REFERRER_POLICY_DEFAULT = 1,
    #[doc = ""]
    #[doc = " When navigating from HTTPS to HTTP do not send the Referrer value."]
    #[doc = " Otherwise, send the complete Referrer value."]
    #[doc = ""]
    REFERRER_POLICY_NO_REFERRER_WHEN_DOWNGRADE = 2,
    #[doc = ""]
    #[doc = " Never send the Referrer value."]
    #[doc = ""]
    REFERRER_POLICY_NEVER = 3,
    #[doc = ""]
    #[doc = " Only send the origin component of the Referrer value."]
    #[doc = ""]
    REFERRER_POLICY_ORIGIN = 4,
    #[doc = ""]
    #[doc = " When navigating cross-origin only send the origin component of the Referrer"]
    #[doc = " value. Otherwise, send the complete Referrer value."]
    #[doc = ""]
    REFERRER_POLICY_ORIGIN_WHEN_CROSS_ORIGIN = 5,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Return values for CefResponseFilter::Filter()."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_response_filter_status_t {
    #[doc = ""]
    #[doc = " Some or all of the pre-filter data was read successfully but more data is"]
    #[doc = " needed in order to continue filtering (filtered output is pending)."]
    #[doc = ""]
    RESPONSE_FILTER_NEED_MORE_DATA = 0,
    #[doc = ""]
    #[doc = " Some or all of the pre-filter data was read successfully and all available"]
    #[doc = " filtered output has been written."]
    #[doc = ""]
    RESPONSE_FILTER_DONE = 1,
    #[doc = ""]
    #[doc = " An error occurred during filtering."]
    #[doc = ""]
    RESPONSE_FILTER_ERROR = 2,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Describes how to interpret the components of a pixel."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_color_type_t {
    #[doc = ""]
    #[doc = " RGBA with 8 bits per pixel (32bits total)."]
    #[doc = ""]
    CEF_COLOR_TYPE_RGBA_8888 = 0,
    #[doc = ""]
    #[doc = " BGRA with 8 bits per pixel (32bits total)."]
    #[doc = ""]
    CEF_COLOR_TYPE_BGRA_8888 = 1,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Describes how to interpret the alpha component of a pixel."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_alpha_type_t {
    #[doc = ""]
    #[doc = " No transparency. The alpha component is ignored."]
    #[doc = ""]
    CEF_ALPHA_TYPE_OPAQUE = 0,
    #[doc = ""]
    #[doc = " Transparency with pre-multiplied alpha component."]
    #[doc = ""]
    CEF_ALPHA_TYPE_PREMULTIPLIED = 1,
    #[doc = ""]
    #[doc = " Transparency with post-multiplied alpha component."]
    #[doc = ""]
    CEF_ALPHA_TYPE_POSTMULTIPLIED = 2,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Supported color types for menu items."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_menu_color_type_t {
    CEF_MENU_COLOR_TEXT = 0,
    CEF_MENU_COLOR_TEXT_HOVERED = 1,
    CEF_MENU_COLOR_TEXT_ACCELERATOR = 2,
    CEF_MENU_COLOR_TEXT_ACCELERATOR_HOVERED = 3,
    CEF_MENU_COLOR_BACKGROUND = 4,
    CEF_MENU_COLOR_BACKGROUND_HOVERED = 5,
    CEF_MENU_COLOR_COUNT = 6,
}
#[repr(i32)]
#[doc = " Supported SSL version values. See net/ssl/ssl_connection_status_flags.h"]
#[doc = " for more information."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_ssl_version_t {
    #[doc = " Unknown SSL version."]
    SSL_CONNECTION_VERSION_UNKNOWN = 0,
    SSL_CONNECTION_VERSION_SSL2 = 1,
    SSL_CONNECTION_VERSION_SSL3 = 2,
    SSL_CONNECTION_VERSION_TLS1 = 3,
    SSL_CONNECTION_VERSION_TLS1_1 = 4,
    SSL_CONNECTION_VERSION_TLS1_2 = 5,
    #[doc = " Reserve 6 for TLS 1.3."]
    SSL_CONNECTION_VERSION_QUIC = 7,
}
#[repr(i32)]
#[doc = " Supported SSL content status flags. See content/public/common/ssl_status.h"]
#[doc = " for more information."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_ssl_content_status_t {
    SSL_CONTENT_NORMAL_CONTENT = 0,
    SSL_CONTENT_DISPLAYED_INSECURE_CONTENT = 1,
    SSL_CONTENT_RAN_INSECURE_CONTENT = 2,
}
#[repr(i32)]
#[doc = ""]
#[doc = " Error codes for CDM registration. See cef_web_plugin.h for details."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_cdm_registration_error_t {
    #[doc = ""]
    #[doc = " No error. Registration completed successfully."]
    #[doc = ""]
    CEF_CDM_REGISTRATION_ERROR_NONE = 0,
    #[doc = ""]
    #[doc = " Required files or manifest contents are missing."]
    #[doc = ""]
    CEF_CDM_REGISTRATION_ERROR_INCORRECT_CONTENTS = 1,
    #[doc = ""]
    #[doc = " The CDM is incompatible with the current Chromium version."]
    #[doc = ""]
    CEF_CDM_REGISTRATION_ERROR_INCOMPATIBLE = 2,
    #[doc = ""]
    #[doc = " CDM registration is not supported at this time."]
    #[doc = ""]
    CEF_CDM_REGISTRATION_ERROR_NOT_SUPPORTED = 3,
}
#[doc = ""]
#[doc = " Structure representing IME composition underline information. This is a thin"]
#[doc = " wrapper around Blink's WebCompositionUnderline class and should be kept in"]
#[doc = " sync with that."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_composition_underline_t {
    #[doc = ""]
    #[doc = " Underline character range."]
    #[doc = ""]
    pub range: cef_range_t,
    #[doc = ""]
    #[doc = " Text color."]
    #[doc = ""]
    pub color: cef_color_t,
    #[doc = ""]
    #[doc = " Background color."]
    #[doc = ""]
    pub background_color: cef_color_t,
    #[doc = ""]
    #[doc = " Set to true (1) for thick underline."]
    #[doc = ""]
    pub thick: ::std::os::raw::c_int,
}
#[doc = ""]
#[doc = " Structure representing IME composition underline information. This is a thin"]
#[doc = " wrapper around Blink's WebCompositionUnderline class and should be kept in"]
#[doc = " sync with that."]
#[doc = ""]
pub type cef_composition_underline_t = _cef_composition_underline_t;
#[doc = ""]
#[doc = " CEF string maps are a set of key/value string pairs."]
#[doc = ""]
pub type cef_string_map_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = ""]
    #[doc = " Allocate a new string map."]
    #[doc = ""]
    pub fn cef_string_map_alloc() -> cef_string_map_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the number of elements in the string map."]
    #[doc = ""]
    pub fn cef_string_map_size(map: cef_string_map_t) -> usize;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the value assigned to the specified key."]
    #[doc = ""]
    pub fn cef_string_map_find(
        map: cef_string_map_t,
        key: *const cef_string_t,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the key at the specified zero-based string map index."]
    #[doc = ""]
    pub fn cef_string_map_key(
        map: cef_string_map_t,
        index: usize,
        key: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the value at the specified zero-based string map index."]
    #[doc = ""]
    pub fn cef_string_map_value(
        map: cef_string_map_t,
        index: usize,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Append a new key/value pair at the end of the string map."]
    #[doc = ""]
    pub fn cef_string_map_append(
        map: cef_string_map_t,
        key: *const cef_string_t,
        value: *const cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Clear the string map."]
    #[doc = ""]
    pub fn cef_string_map_clear(map: cef_string_map_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Free the string map."]
    #[doc = ""]
    pub fn cef_string_map_free(map: cef_string_map_t);
}
#[doc = ""]
#[doc = " CEF string multimaps are a set of key/value string pairs."]
#[doc = " More than one value can be assigned to a single key."]
#[doc = ""]
pub type cef_string_multimap_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = ""]
    #[doc = " Allocate a new string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_alloc() -> cef_string_multimap_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the number of elements in the string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_size(map: cef_string_multimap_t) -> usize;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the number of values with the specified key."]
    #[doc = ""]
    pub fn cef_string_multimap_find_count(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
    ) -> usize;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the value_index-th value with the specified key."]
    #[doc = ""]
    pub fn cef_string_multimap_enumerate(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
        value_index: usize,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the key at the specified zero-based string multimap index."]
    #[doc = ""]
    pub fn cef_string_multimap_key(
        map: cef_string_multimap_t,
        index: usize,
        key: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the value at the specified zero-based string multimap index."]
    #[doc = ""]
    pub fn cef_string_multimap_value(
        map: cef_string_multimap_t,
        index: usize,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Append a new key/value pair at the end of the string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_append(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
        value: *const cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Clear the string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_clear(map: cef_string_multimap_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Free the string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_free(map: cef_string_multimap_t);
}
#[doc = ""]
#[doc = " All ref-counted framework structures must include this structure first."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_base_ref_counted_t {
    #[doc = ""]
    #[doc = " Size of the data structure."]
    #[doc = ""]
    pub size: usize,
    #[doc = ""]
    #[doc = " Called to increment the reference count for the object. Should be called"]
    #[doc = " for every new copy of a pointer to a given object."]
    #[doc = ""]
    pub add_ref: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t)>,
    #[doc = ""]
    #[doc = " Called to decrement the reference count for the object. If the reference"]
    #[doc = " count falls to 0 the object should self-delete. Returns true (1) if the"]
    #[doc = " resulting reference count is 0."]
    #[doc = ""]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the current reference count is 1."]
    #[doc = ""]
    pub has_one_ref: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " All ref-counted framework structures must include this structure first."]
#[doc = ""]
pub type cef_base_ref_counted_t = _cef_base_ref_counted_t;
#[doc = ""]
#[doc = " All scoped framework structures must include this structure first."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_base_scoped_t {
    #[doc = ""]
    #[doc = " Size of the data structure."]
    #[doc = ""]
    pub size: usize,
    #[doc = ""]
    #[doc = " Called to delete this object. May be NULL if the object is not owned."]
    #[doc = ""]
    pub del: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_base_scoped_t)>,
}
#[doc = ""]
#[doc = " All scoped framework structures must include this structure first."]
#[doc = ""]
pub type cef_base_scoped_t = _cef_base_scoped_t;
#[doc = ""]
#[doc = " Structure that wraps other data value types. Complex types (binary,"]
#[doc = " dictionary and list) will be referenced but not owned by this object. Can be"]
#[doc = " used on any process and thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying data is valid. This will always be true"]
    #[doc = " (1) for simple types. For complex types (binary, dictionary and list) the"]
    #[doc = " underlying data may become invalid if owned by another object (e.g. list or"]
    #[doc = " dictionary) and that other object is then modified or destroyed. This value"]
    #[doc = " object can be re-used by calling Set*() even if the underlying data is"]
    #[doc = " invalid."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying data is owned by another object."]
    #[doc = ""]
    pub is_owned: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying data is read-only. Some APIs may expose"]
    #[doc = " read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have the same underlying"]
    #[doc = " data. If true (1) modifications to this object will also affect |that|"]
    #[doc = " object and vice-versa."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            that: *mut _cef_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have an equivalent"]
    #[doc = " underlying value but are not necessarily the same object."]
    #[doc = ""]
    pub is_equal: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            that: *mut _cef_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a copy of this object. The underlying data will also be copied."]
    #[doc = ""]
    pub copy:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_value_t>,
    #[doc = ""]
    #[doc = " Returns the underlying value type."]
    #[doc = ""]
    pub get_type:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> cef_value_type_t>,
    #[doc = ""]
    #[doc = " Returns the underlying value as type bool."]
    #[doc = ""]
    pub get_bool: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type int."]
    #[doc = ""]
    pub get_int: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type double."]
    #[doc = ""]
    pub get_double: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> f64>,
    #[doc = ""]
    #[doc = " Returns the underlying value as type string."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type binary. The returned reference may"]
    #[doc = " become invalid if the value is owned by another object or if ownership is"]
    #[doc = " transferred to another object in the future. To maintain a reference to the"]
    #[doc = " value after assigning ownership to a dictionary or list pass this object to"]
    #[doc = " the set_value() function instead of passing the returned reference to"]
    #[doc = " set_binary()."]
    #[doc = ""]
    pub get_binary: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type dictionary. The returned reference may"]
    #[doc = " become invalid if the value is owned by another object or if ownership is"]
    #[doc = " transferred to another object in the future. To maintain a reference to the"]
    #[doc = " value after assigning ownership to a dictionary or list pass this object to"]
    #[doc = " the set_value() function instead of passing the returned reference to"]
    #[doc = " set_dictionary()."]
    #[doc = ""]
    pub get_dictionary: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type list. The returned reference may"]
    #[doc = " become invalid if the value is owned by another object or if ownership is"]
    #[doc = " transferred to another object in the future. To maintain a reference to the"]
    #[doc = " value after assigning ownership to a dictionary or list pass this object to"]
    #[doc = " the set_value() function instead of passing the returned reference to"]
    #[doc = " set_list()."]
    #[doc = ""]
    pub get_list: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type null. Returns true (1) if the value was"]
    #[doc = " set successfully."]
    #[doc = ""]
    pub set_null: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type bool. Returns true (1) if the value was"]
    #[doc = " set successfully."]
    #[doc = ""]
    pub set_bool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type int. Returns true (1) if the value was"]
    #[doc = " set successfully."]
    #[doc = ""]
    pub set_int: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type double. Returns true (1) if the value was"]
    #[doc = " set successfully."]
    #[doc = ""]
    pub set_double: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t, value: f64) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type string. Returns true (1) if the value was"]
    #[doc = " set successfully."]
    #[doc = ""]
    pub set_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type binary. Returns true (1) if the value was"]
    #[doc = " set successfully. This object keeps a reference to |value| and ownership of"]
    #[doc = " the underlying data remains unchanged."]
    #[doc = ""]
    pub set_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type dict. Returns true (1) if the value was"]
    #[doc = " set successfully. This object keeps a reference to |value| and ownership of"]
    #[doc = " the underlying data remains unchanged."]
    #[doc = ""]
    pub set_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type list. Returns true (1) if the value was"]
    #[doc = " set successfully. This object keeps a reference to |value| and ownership of"]
    #[doc = " the underlying data remains unchanged."]
    #[doc = ""]
    pub set_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure that wraps other data value types. Complex types (binary,"]
#[doc = " dictionary and list) will be referenced but not owned by this object. Can be"]
#[doc = " used on any process and thread."]
#[doc = ""]
pub type cef_value_t = _cef_value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new object."]
    #[doc = ""]
    pub fn cef_value_create() -> *mut cef_value_t;
}
#[doc = ""]
#[doc = " Structure representing a binary value. Can be used on any process and thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_binary_value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. This object may become invalid if"]
    #[doc = " the underlying data is owned by another object (e.g. list or dictionary)"]
    #[doc = " and that other object is then modified or destroyed. Do not call any other"]
    #[doc = " functions if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is currently owned by another object."]
    #[doc = ""]
    pub is_owned: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have the same underlying"]
    #[doc = " data."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            that: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have an equivalent"]
    #[doc = " underlying value but are not necessarily the same object."]
    #[doc = ""]
    pub is_equal: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            that: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a copy of this object. The data in this object will also be copied."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the data size."]
    #[doc = ""]
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> usize>,
    #[doc = ""]
    #[doc = " Read up to |buffer_size| number of bytes into |buffer|. Reading begins at"]
    #[doc = " the specified byte |data_offset|. Returns the number of bytes read."]
    #[doc = ""]
    pub get_data: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            buffer: *mut ::std::os::raw::c_void,
            buffer_size: usize,
            data_offset: usize,
        ) -> usize,
    >,
}
#[doc = ""]
#[doc = " Structure representing a binary value. Can be used on any process and thread."]
#[doc = ""]
pub type cef_binary_value_t = _cef_binary_value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new object that is not owned by any other object. The specified"]
    #[doc = " |data| will be copied."]
    #[doc = ""]
    pub fn cef_binary_value_create(
        data: *const ::std::os::raw::c_void,
        data_size: usize,
    ) -> *mut cef_binary_value_t;
}
#[doc = ""]
#[doc = " Structure representing a dictionary value. Can be used on any process and"]
#[doc = " thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_dictionary_value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. This object may become invalid if"]
    #[doc = " the underlying data is owned by another object (e.g. list or dictionary)"]
    #[doc = " and that other object is then modified or destroyed. Do not call any other"]
    #[doc = " functions if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is currently owned by another object."]
    #[doc = ""]
    pub is_owned: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have the same underlying"]
    #[doc = " data. If true (1) modifications to this object will also affect |that|"]
    #[doc = " object and vice-versa."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            that: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have an equivalent"]
    #[doc = " underlying value but are not necessarily the same object."]
    #[doc = ""]
    pub is_equal: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            that: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object. If |exclude_NULL_children| is true"]
    #[doc = " (1) any NULL dictionaries or lists will be excluded from the copy."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            exclude_empty_children: ::std::os::raw::c_int,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the number of values."]
    #[doc = ""]
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> usize>,
    #[doc = ""]
    #[doc = " Removes all values. Returns true (1) on success."]
    #[doc = ""]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the current dictionary has a value for the given key."]
    #[doc = ""]
    pub has_key: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Reads all keys for this dictionary into the specified vector."]
    #[doc = ""]
    pub get_keys: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            keys: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Removes the value at the specified key. Returns true (1) is the value was"]
    #[doc = " removed successfully."]
    #[doc = ""]
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value type for the specified key."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> cef_value_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key. For simple types the returned value"]
    #[doc = " will copy existing data and modifications to the value will not modify this"]
    #[doc = " object. For complex types (binary, dictionary and list) the returned value"]
    #[doc = " will reference existing data and modifications to the value will modify"]
    #[doc = " this object."]
    #[doc = ""]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type bool."]
    #[doc = ""]
    pub get_bool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type int."]
    #[doc = ""]
    pub get_int: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type double."]
    #[doc = ""]
    pub get_double: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t, key: *const cef_string_t) -> f64,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type string."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type binary. The returned value"]
    #[doc = " will reference existing data."]
    #[doc = ""]
    pub get_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type dictionary. The returned"]
    #[doc = " value will reference existing data and modifications to the value will"]
    #[doc = " modify this object."]
    #[doc = ""]
    pub get_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type list. The returned value"]
    #[doc = " will reference existing data and modifications to the value will modify"]
    #[doc = " this object."]
    #[doc = ""]
    pub get_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key. Returns true (1) if the value was set"]
    #[doc = " successfully. If |value| represents simple data then the underlying data"]
    #[doc = " will be copied and modifications to |value| will not modify this object. If"]
    #[doc = " |value| represents complex data (binary, dictionary or list) then the"]
    #[doc = " underlying data will be referenced and modifications to |value| will modify"]
    #[doc = " this object."]
    #[doc = ""]
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type null. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_null: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type bool. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_bool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type int. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_int: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type double. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_double: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: f64,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type string. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type binary. Returns true (1) if the"]
    #[doc = " value was set successfully. If |value| is currently owned by another object"]
    #[doc = " then the value will be copied and the |value| reference will not change."]
    #[doc = " Otherwise, ownership will be transferred to this object and the |value|"]
    #[doc = " reference will be invalidated."]
    #[doc = ""]
    pub set_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type dict. Returns true (1) if the"]
    #[doc = " value was set successfully. If |value| is currently owned by another object"]
    #[doc = " then the value will be copied and the |value| reference will not change."]
    #[doc = " Otherwise, ownership will be transferred to this object and the |value|"]
    #[doc = " reference will be invalidated."]
    #[doc = ""]
    pub set_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type list. Returns true (1) if the"]
    #[doc = " value was set successfully. If |value| is currently owned by another object"]
    #[doc = " then the value will be copied and the |value| reference will not change."]
    #[doc = " Otherwise, ownership will be transferred to this object and the |value|"]
    #[doc = " reference will be invalidated."]
    #[doc = ""]
    pub set_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure representing a dictionary value. Can be used on any process and"]
#[doc = " thread."]
#[doc = ""]
pub type cef_dictionary_value_t = _cef_dictionary_value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new object that is not owned by any other object."]
    #[doc = ""]
    pub fn cef_dictionary_value_create() -> *mut cef_dictionary_value_t;
}
#[doc = ""]
#[doc = " Structure representing a list value. Can be used on any process and thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_list_value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. This object may become invalid if"]
    #[doc = " the underlying data is owned by another object (e.g. list or dictionary)"]
    #[doc = " and that other object is then modified or destroyed. Do not call any other"]
    #[doc = " functions if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is currently owned by another object."]
    #[doc = ""]
    pub is_owned: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have the same underlying"]
    #[doc = " data. If true (1) modifications to this object will also affect |that|"]
    #[doc = " object and vice-versa."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            that: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have an equivalent"]
    #[doc = " underlying value but are not necessarily the same object."]
    #[doc = ""]
    pub is_equal: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            that: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Sets the number of values. If the number of values is expanded all new"]
    #[doc = " value slots will default to type null. Returns true (1) on success."]
    #[doc = ""]
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, size: usize) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of values."]
    #[doc = ""]
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> usize>,
    #[doc = ""]
    #[doc = " Removes all values. Returns true (1) on success."]
    #[doc = ""]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Removes the value at the specified index."]
    #[doc = ""]
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value type at the specified index."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> cef_value_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index. For simple types the returned"]
    #[doc = " value will copy existing data and modifications to the value will not"]
    #[doc = " modify this object. For complex types (binary, dictionary and list) the"]
    #[doc = " returned value will reference existing data and modifications to the value"]
    #[doc = " will modify this object."]
    #[doc = ""]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> *mut _cef_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type bool."]
    #[doc = ""]
    pub get_bool: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type int."]
    #[doc = ""]
    pub get_int: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type double."]
    #[doc = ""]
    pub get_double: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> f64,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type string."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type binary. The returned value"]
    #[doc = " will reference existing data."]
    #[doc = ""]
    pub get_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type dictionary. The returned"]
    #[doc = " value will reference existing data and modifications to the value will"]
    #[doc = " modify this object."]
    #[doc = ""]
    pub get_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type list. The returned value"]
    #[doc = " will reference existing data and modifications to the value will modify"]
    #[doc = " this object."]
    #[doc = ""]
    pub get_list: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index. Returns true (1) if the value was"]
    #[doc = " set successfully. If |value| represents simple data then the underlying"]
    #[doc = " data will be copied and modifications to |value| will not modify this"]
    #[doc = " object. If |value| represents complex data (binary, dictionary or list)"]
    #[doc = " then the underlying data will be referenced and modifications to |value|"]
    #[doc = " will modify this object."]
    #[doc = ""]
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *mut _cef_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type null. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_null: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type bool. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_bool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type int. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_int: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type double. Returns true (1) if"]
    #[doc = " the value was set successfully."]
    #[doc = ""]
    pub set_double: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: f64,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type string. Returns true (1) if"]
    #[doc = " the value was set successfully."]
    #[doc = ""]
    pub set_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type binary. Returns true (1) if"]
    #[doc = " the value was set successfully. If |value| is currently owned by another"]
    #[doc = " object then the value will be copied and the |value| reference will not"]
    #[doc = " change. Otherwise, ownership will be transferred to this object and the"]
    #[doc = " |value| reference will be invalidated."]
    #[doc = ""]
    pub set_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type dict. Returns true (1) if the"]
    #[doc = " value was set successfully. If |value| is currently owned by another object"]
    #[doc = " then the value will be copied and the |value| reference will not change."]
    #[doc = " Otherwise, ownership will be transferred to this object and the |value|"]
    #[doc = " reference will be invalidated."]
    #[doc = ""]
    pub set_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type list. Returns true (1) if the"]
    #[doc = " value was set successfully. If |value| is currently owned by another object"]
    #[doc = " then the value will be copied and the |value| reference will not change."]
    #[doc = " Otherwise, ownership will be transferred to this object and the |value|"]
    #[doc = " reference will be invalidated."]
    #[doc = ""]
    pub set_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure representing a list value. Can be used on any process and thread."]
#[doc = ""]
pub type cef_list_value_t = _cef_list_value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new object that is not owned by any other object."]
    #[doc = ""]
    pub fn cef_list_value_create() -> *mut cef_list_value_t;
}
#[doc = ""]
#[doc = " Container for a single image represented at different scale factors. All"]
#[doc = " image representations should be the same size in density independent pixel"]
#[doc = " (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels"]
#[doc = " then the image at scale factor 2.0 should be 200x200 pixels -- both images"]
#[doc = " will display with a DIP size of 100x100 units. The functions of this"]
#[doc = " structure must be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_image_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this Image is NULL."]
    #[doc = ""]
    pub is_empty: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this Image and |that| Image share the same underlying"]
    #[doc = " storage. Will also return true (1) if both images are NULL."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            that: *mut _cef_image_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a bitmap image representation for |scale_factor|. Only 32-bit RGBA/BGRA"]
    #[doc = " formats are supported. |pixel_width| and |pixel_height| are the bitmap"]
    #[doc = " representation size in pixel coordinates. |pixel_data| is the array of"]
    #[doc = " pixel data and should be |pixel_width| x |pixel_height| x 4 bytes in size."]
    #[doc = " |color_type| and |alpha_type| values specify the pixel format."]
    #[doc = ""]
    pub add_bitmap: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            pixel_width: ::std::os::raw::c_int,
            pixel_height: ::std::os::raw::c_int,
            color_type: cef_color_type_t,
            alpha_type: cef_alpha_type_t,
            pixel_data: *const ::std::os::raw::c_void,
            pixel_data_size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a PNG image representation for |scale_factor|. |png_data| is the image"]
    #[doc = " data of size |png_data_size|. Any alpha transparency in the PNG data will"]
    #[doc = " be maintained."]
    #[doc = ""]
    pub add_png: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            png_data: *const ::std::os::raw::c_void,
            png_data_size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Create a JPEG image representation for |scale_factor|. |jpeg_data| is the"]
    #[doc = " image data of size |jpeg_data_size|. The JPEG format does not support"]
    #[doc = " transparency so the alpha byte will be set to 0xFF for all pixels."]
    #[doc = ""]
    pub add_jpeg: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            jpeg_data: *const ::std::os::raw::c_void,
            jpeg_data_size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the image width in density independent pixel (DIP) units."]
    #[doc = ""]
    pub get_width: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_image_t) -> usize>,
    #[doc = ""]
    #[doc = " Returns the image height in density independent pixel (DIP) units."]
    #[doc = ""]
    pub get_height: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_image_t) -> usize>,
    #[doc = ""]
    #[doc = " Returns true (1) if this image contains a representation for"]
    #[doc = " |scale_factor|."]
    #[doc = ""]
    pub has_representation: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t, scale_factor: f32) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Removes the representation for |scale_factor|. Returns true (1) on success."]
    #[doc = ""]
    pub remove_representation: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t, scale_factor: f32) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns information for the representation that most closely matches"]
    #[doc = " |scale_factor|. |actual_scale_factor| is the actual scale factor for the"]
    #[doc = " representation. |pixel_width| and |pixel_height| are the representation"]
    #[doc = " size in pixel coordinates. Returns true (1) on success."]
    #[doc = ""]
    pub get_representation_info: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            actual_scale_factor: *mut f32,
            pixel_width: *mut ::std::os::raw::c_int,
            pixel_height: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the bitmap representation that most closely matches |scale_factor|."]
    #[doc = " Only 32-bit RGBA/BGRA formats are supported. |color_type| and |alpha_type|"]
    #[doc = " values specify the desired output pixel format. |pixel_width| and"]
    #[doc = " |pixel_height| are the output representation size in pixel coordinates."]
    #[doc = " Returns a cef_binary_value_t containing the pixel data on success or NULL"]
    #[doc = " on failure."]
    #[doc = ""]
    pub get_as_bitmap: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            color_type: cef_color_type_t,
            alpha_type: cef_alpha_type_t,
            pixel_width: *mut ::std::os::raw::c_int,
            pixel_height: *mut ::std::os::raw::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the PNG representation that most closely matches |scale_factor|. If"]
    #[doc = " |with_transparency| is true (1) any alpha transparency in the image will be"]
    #[doc = " represented in the resulting PNG data. |pixel_width| and |pixel_height| are"]
    #[doc = " the output representation size in pixel coordinates. Returns a"]
    #[doc = " cef_binary_value_t containing the PNG image data on success or NULL on"]
    #[doc = " failure."]
    #[doc = ""]
    pub get_as_png: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            with_transparency: ::std::os::raw::c_int,
            pixel_width: *mut ::std::os::raw::c_int,
            pixel_height: *mut ::std::os::raw::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the JPEG representation that most closely matches |scale_factor|."]
    #[doc = " |quality| determines the compression level with 0 == lowest and 100 =="]
    #[doc = " highest. The JPEG format does not support alpha transparency and the alpha"]
    #[doc = " channel, if any, will be discarded. |pixel_width| and |pixel_height| are"]
    #[doc = " the output representation size in pixel coordinates. Returns a"]
    #[doc = " cef_binary_value_t containing the JPEG image data on success or NULL on"]
    #[doc = " failure."]
    #[doc = ""]
    pub get_as_jpeg: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            quality: ::std::os::raw::c_int,
            pixel_width: *mut ::std::os::raw::c_int,
            pixel_height: *mut ::std::os::raw::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
}
#[doc = ""]
#[doc = " Container for a single image represented at different scale factors. All"]
#[doc = " image representations should be the same size in density independent pixel"]
#[doc = " (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels"]
#[doc = " then the image at scale factor 2.0 should be 200x200 pixels -- both images"]
#[doc = " will display with a DIP size of 100x100 units. The functions of this"]
#[doc = " structure must be called on the browser process UI thread."]
#[doc = ""]
pub type cef_image_t = _cef_image_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_image_t. It will initially be NULL. Use the Add*() functions"]
    #[doc = " to add representations at different scale factors."]
    #[doc = ""]
    pub fn cef_image_create() -> *mut cef_image_t;
}
#[doc = ""]
#[doc = " Structure the client can implement to provide a custom stream reader. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_read_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Read raw binary data."]
    #[doc = ""]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_read_handler_t,
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
            n: usize,
        ) -> usize,
    >,
    #[doc = ""]
    #[doc = " Seek to the specified offset position. |whence| may be any one of SEEK_CUR,"]
    #[doc = " SEEK_END or SEEK_SET. Return zero on success and non-zero on failure."]
    #[doc = ""]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_read_handler_t,
            offset: int64,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the current offset position."]
    #[doc = ""]
    pub tell: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> int64>,
    #[doc = ""]
    #[doc = " Return non-zero if at end of file."]
    #[doc = ""]
    pub eof: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return true (1) if this handler performs work like accessing the file"]
    #[doc = " system which may block. Used as a hint for determining the thread to access"]
    #[doc = " the handler from."]
    #[doc = ""]
    pub may_block: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure the client can implement to provide a custom stream reader. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
pub type cef_read_handler_t = _cef_read_handler_t;
#[doc = ""]
#[doc = " Structure used to read data from a stream. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_stream_reader_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Read raw binary data."]
    #[doc = ""]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_reader_t,
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
            n: usize,
        ) -> usize,
    >,
    #[doc = ""]
    #[doc = " Seek to the specified offset position. |whence| may be any one of SEEK_CUR,"]
    #[doc = " SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure."]
    #[doc = ""]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_reader_t,
            offset: int64,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the current offset position."]
    #[doc = ""]
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> int64>,
    #[doc = ""]
    #[doc = " Return non-zero if at end of file."]
    #[doc = ""]
    pub eof: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this reader performs work like accessing the file"]
    #[doc = " system which may block. Used as a hint for determining the thread to access"]
    #[doc = " the reader from."]
    #[doc = ""]
    pub may_block: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to read data from a stream. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
pub type cef_stream_reader_t = _cef_stream_reader_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_reader_t object from a file."]
    #[doc = ""]
    pub fn cef_stream_reader_create_for_file(
        fileName: *const cef_string_t,
    ) -> *mut cef_stream_reader_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_reader_t object from data."]
    #[doc = ""]
    pub fn cef_stream_reader_create_for_data(
        data: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut cef_stream_reader_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_reader_t object from a custom handler."]
    #[doc = ""]
    pub fn cef_stream_reader_create_for_handler(
        handler: *mut cef_read_handler_t,
    ) -> *mut cef_stream_reader_t;
}
#[doc = ""]
#[doc = " Structure the client can implement to provide a custom stream writer. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_write_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Write raw binary data."]
    #[doc = ""]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_write_handler_t,
            ptr: *const ::std::os::raw::c_void,
            size: usize,
            n: usize,
        ) -> usize,
    >,
    #[doc = ""]
    #[doc = " Seek to the specified offset position. |whence| may be any one of SEEK_CUR,"]
    #[doc = " SEEK_END or SEEK_SET. Return zero on success and non-zero on failure."]
    #[doc = ""]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_write_handler_t,
            offset: int64,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the current offset position."]
    #[doc = ""]
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> int64>,
    #[doc = ""]
    #[doc = " Flush the stream."]
    #[doc = ""]
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return true (1) if this handler performs work like accessing the file"]
    #[doc = " system which may block. Used as a hint for determining the thread to access"]
    #[doc = " the handler from."]
    #[doc = ""]
    pub may_block: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure the client can implement to provide a custom stream writer. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
pub type cef_write_handler_t = _cef_write_handler_t;
#[doc = ""]
#[doc = " Structure used to write data to a stream. The functions of this structure may"]
#[doc = " be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_stream_writer_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Write raw binary data."]
    #[doc = ""]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_writer_t,
            ptr: *const ::std::os::raw::c_void,
            size: usize,
            n: usize,
        ) -> usize,
    >,
    #[doc = ""]
    #[doc = " Seek to the specified offset position. |whence| may be any one of SEEK_CUR,"]
    #[doc = " SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure."]
    #[doc = ""]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_writer_t,
            offset: int64,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the current offset position."]
    #[doc = ""]
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> int64>,
    #[doc = ""]
    #[doc = " Flush the stream."]
    #[doc = ""]
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this writer performs work like accessing the file"]
    #[doc = " system which may block. Used as a hint for determining the thread to access"]
    #[doc = " the writer from."]
    #[doc = ""]
    pub may_block: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to write data to a stream. The functions of this structure may"]
#[doc = " be called on any thread."]
#[doc = ""]
pub type cef_stream_writer_t = _cef_stream_writer_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_writer_t object for a file."]
    #[doc = ""]
    pub fn cef_stream_writer_create_for_file(
        fileName: *const cef_string_t,
    ) -> *mut cef_stream_writer_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_writer_t object for a custom handler."]
    #[doc = ""]
    pub fn cef_stream_writer_create_for_handler(
        handler: *mut cef_write_handler_t,
    ) -> *mut cef_stream_writer_t;
}
#[doc = ""]
#[doc = " Structure used to represent drag data. The functions of this structure may be"]
#[doc = " called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_drag_data_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns a copy of the current object."]
    #[doc = ""]
    pub clone: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> *mut _cef_drag_data_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the drag data is a link."]
    #[doc = ""]
    pub is_link: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the drag data is a text or html fragment."]
    #[doc = ""]
    pub is_fragment: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the drag data is a file."]
    #[doc = ""]
    pub is_file: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the link URL that is being dragged."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_link_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the title associated with the link being dragged."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_link_title: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the metadata, if any, associated with the link being dragged."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_link_metadata: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the plain text fragment that is being dragged."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_fragment_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the text/html fragment that is being dragged."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_fragment_html: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the base URL that the fragment came from. This value is used for"]
    #[doc = " resolving relative URLs and may be NULL."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_fragment_base_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the name of the file being dragged out of the browser window."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_file_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Write the contents of the file being dragged out of the web view into"]
    #[doc = " |writer|. Returns the number of bytes sent to |writer|. If |writer| is NULL"]
    #[doc = " this function will return the size of the file contents in bytes. Call"]
    #[doc = " get_file_name() to get a suggested name for the file."]
    #[doc = ""]
    pub get_file_contents: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            writer: *mut _cef_stream_writer_t,
        ) -> usize,
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of file names that are being dragged into the browser"]
    #[doc = " window."]
    #[doc = ""]
    pub get_file_names: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            names: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the link URL that is being dragged."]
    #[doc = ""]
    pub set_link_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the title associated with the link being dragged."]
    #[doc = ""]
    pub set_link_title: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, title: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the metadata associated with the link being dragged."]
    #[doc = ""]
    pub set_link_metadata: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, data: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the plain text fragment that is being dragged."]
    #[doc = ""]
    pub set_fragment_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, text: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the text/html fragment that is being dragged."]
    #[doc = ""]
    pub set_fragment_html: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, html: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the base URL that the fragment came from."]
    #[doc = ""]
    pub set_fragment_base_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, base_url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Reset the file contents. You should do this before calling"]
    #[doc = " cef_browser_host_t::DragTargetDragEnter as the web view does not allow us"]
    #[doc = " to drag in this kind of data."]
    #[doc = ""]
    pub reset_file_contents:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_drag_data_t)>,
    #[doc = ""]
    #[doc = " Add a file that is being dragged into the webview."]
    #[doc = ""]
    pub add_file: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            path: *const cef_string_t,
            display_name: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Get the image representation of drag data. May return NULL if no image"]
    #[doc = " representation is available."]
    #[doc = ""]
    pub get_image: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> *mut _cef_image_t,
    >,
    #[doc = ""]
    #[doc = " Get the image hotspot (drag start location relative to image dimensions)."]
    #[doc = ""]
    pub get_image_hotspot:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_point_t>,
    #[doc = ""]
    #[doc = " Returns true (1) if an image representation of drag data is available."]
    #[doc = ""]
    pub has_image: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to represent drag data. The functions of this structure may be"]
#[doc = " called on any thread."]
#[doc = ""]
pub type cef_drag_data_t = _cef_drag_data_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_drag_data_t object."]
    #[doc = ""]
    pub fn cef_drag_data_create() -> *mut cef_drag_data_t;
}
#[doc = ""]
#[doc = " Structure to implement for visiting the DOM. The functions of this structure"]
#[doc = " will be called on the render process main thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domvisitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method executed for visiting the DOM. The document object passed to this"]
    #[doc = " function represents a snapshot of the DOM at the time this function is"]
    #[doc = " executed. DOM objects are only valid for the scope of this function. Do not"]
    #[doc = " keep references to or attempt to access any DOM objects outside the scope"]
    #[doc = " of this function."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domvisitor_t, document: *mut _cef_domdocument_t),
    >,
}
#[doc = ""]
#[doc = " Structure used to represent a DOM document. The functions of this structure"]
#[doc = " should only be called on the render process main thread thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domdocument_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the document type."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_dom_document_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the root document node."]
    #[doc = ""]
    pub get_document: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the BODY node of an HTML document."]
    #[doc = ""]
    pub get_body: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the HEAD node of an HTML document."]
    #[doc = ""]
    pub get_head: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the title of an HTML document."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_title: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the document element with the specified ID value."]
    #[doc = ""]
    pub get_element_by_id: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domdocument_t,
            id: *const cef_string_t,
        ) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the node that currently has keyboard focus."]
    #[doc = ""]
    pub get_focused_node: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if a portion of the document is selected."]
    #[doc = ""]
    pub has_selection: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the selection offset within the start node."]
    #[doc = ""]
    pub get_selection_start_offset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the selection offset within the end node."]
    #[doc = ""]
    pub get_selection_end_offset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the contents of this selection as markup."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_selection_as_markup: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the contents of this selection as text."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_selection_as_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the base URL for the document."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_base_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns a complete URL based on the document base URL and the specified"]
    #[doc = " partial URL."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_complete_url: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domdocument_t,
            partialURL: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
}
#[doc = ""]
#[doc = " Structure used to represent a DOM node. The functions of this structure"]
#[doc = " should only be called on the render process main thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domnode_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the type for this node."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_dom_node_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is a text node."]
    #[doc = ""]
    pub is_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is an element node."]
    #[doc = ""]
    pub is_element: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is an editable node."]
    #[doc = ""]
    pub is_editable: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is a form control element node."]
    #[doc = ""]
    pub is_form_control_element: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the type of this form control element node."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_form_control_element_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same handle as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            that: *mut _cef_domnode_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the name of this node."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value of this node."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the value of this node. Returns true (1) on success."]
    #[doc = ""]
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the contents of this node as markup."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_as_markup: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the document associated with this node."]
    #[doc = ""]
    pub get_document: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domdocument_t,
    >,
    #[doc = ""]
    #[doc = " Returns the parent node."]
    #[doc = ""]
    pub get_parent: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the previous sibling node."]
    #[doc = ""]
    pub get_previous_sibling: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the next sibling node."]
    #[doc = ""]
    pub get_next_sibling: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this node has child nodes."]
    #[doc = ""]
    pub has_children: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the first child node."]
    #[doc = ""]
    pub get_first_child: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the last child node."]
    #[doc = ""]
    pub get_last_child: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the tag name of this element."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_element_tag_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this element has attributes."]
    #[doc = ""]
    pub has_element_attributes: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this element has an attribute named |attrName|."]
    #[doc = ""]
    pub has_element_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the element attribute named |attrName|."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_element_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns a map of all element attributes."]
    #[doc = ""]
    pub get_element_attributes: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t, attrMap: cef_string_map_t),
    >,
    #[doc = ""]
    #[doc = " Set the value for the element attribute named |attrName|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub set_element_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the inner text of the element."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_element_inner_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the bounds of the element."]
    #[doc = ""]
    pub get_element_bounds:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_rect_t>,
}
#[doc = ""]
#[doc = " Structure used to represent a web request. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Get the fully qualified URL."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the fully qualified URL."]
    #[doc = ""]
    pub set_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the request function type. The value will default to POST if post data"]
    #[doc = " is provided and GET otherwise."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_method: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the request function type."]
    #[doc = ""]
    pub set_method: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, method: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the referrer URL and policy. If non-NULL the referrer URL must be fully"]
    #[doc = " qualified with an HTTP or HTTPS scheme component. Any username, password or"]
    #[doc = " ref component will be removed."]
    #[doc = ""]
    pub set_referrer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            referrer_url: *const cef_string_t,
            policy: cef_referrer_policy_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Get the referrer URL."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_referrer_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Get the referrer policy."]
    #[doc = ""]
    pub get_referrer_policy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_referrer_policy_t,
    >,
    #[doc = ""]
    #[doc = " Get the post data."]
    #[doc = ""]
    pub get_post_data: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> *mut _cef_post_data_t,
    >,
    #[doc = ""]
    #[doc = " Set the post data."]
    #[doc = ""]
    pub set_post_data: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, postData: *mut _cef_post_data_t),
    >,
    #[doc = ""]
    #[doc = " Get the header values. Will not include the Referer value if any."]
    #[doc = ""]
    pub get_header_map: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = ""]
    #[doc = " Set the header values. If a Referer value exists in the header map it will"]
    #[doc = " be removed and ignored."]
    #[doc = ""]
    pub set_header_map: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = ""]
    #[doc = " Set all values at one time."]
    #[doc = ""]
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            url: *const cef_string_t,
            method: *const cef_string_t,
            postData: *mut _cef_post_data_t,
            headerMap: cef_string_multimap_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Get the flags used in combination with cef_urlrequest_t. See"]
    #[doc = " cef_urlrequest_flags_t for supported values."]
    #[doc = ""]
    pub get_flags: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the flags used in combination with cef_urlrequest_t.  See"]
    #[doc = " cef_urlrequest_flags_t for supported values."]
    #[doc = ""]
    pub set_flags: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, flags: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Set the URL to the first party for cookies used in combination with"]
    #[doc = " cef_urlrequest_t."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_first_party_for_cookies: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Get the URL to the first party for cookies used in combination with"]
    #[doc = " cef_urlrequest_t."]
    #[doc = ""]
    pub set_first_party_for_cookies: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the resource type for this request. Only available in the browser"]
    #[doc = " process."]
    #[doc = ""]
    pub get_resource_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_resource_type_t,
    >,
    #[doc = ""]
    #[doc = " Get the transition type for this request. Only available in the browser"]
    #[doc = " process and only applies to requests that represent a main frame or sub-"]
    #[doc = " frame navigation."]
    #[doc = ""]
    pub get_transition_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_transition_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the globally unique identifier for this request or 0 if not"]
    #[doc = " specified. Can be used by cef_request_tHandler implementations in the"]
    #[doc = " browser process to track a single request across multiple callbacks."]
    #[doc = ""]
    pub get_identifier:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_request_t) -> uint64>,
}
#[doc = ""]
#[doc = " Structure used to represent a web request. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
pub type cef_request_t = _cef_request_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_request_t object."]
    #[doc = ""]
    pub fn cef_request_create() -> *mut cef_request_t;
}
#[doc = ""]
#[doc = " Structure used to represent post data for a web request. The functions of"]
#[doc = " this structure may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_post_data_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying POST data includes elements that are not"]
    #[doc = " represented by this cef_post_data_t object (for example, multi-part file"]
    #[doc = " upload data). Modifying cef_post_data_t objects with excluded elements may"]
    #[doc = " result in the request failing."]
    #[doc = ""]
    pub has_excluded_elements: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of existing post data elements."]
    #[doc = ""]
    pub get_element_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> usize>,
    #[doc = ""]
    #[doc = " Retrieve the post data elements."]
    #[doc = ""]
    pub get_elements: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            elementsCount: *mut usize,
            elements: *mut *mut _cef_post_data_element_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Remove the specified post data element.  Returns true (1) if the removal"]
    #[doc = " succeeds."]
    #[doc = ""]
    pub remove_element: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            element: *mut _cef_post_data_element_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add the specified post data element.  Returns true (1) if the add succeeds."]
    #[doc = ""]
    pub add_element: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            element: *mut _cef_post_data_element_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Remove all existing post data elements."]
    #[doc = ""]
    pub remove_elements: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_t)>,
}
#[doc = ""]
#[doc = " Structure used to represent post data for a web request. The functions of"]
#[doc = " this structure may be called on any thread."]
#[doc = ""]
pub type cef_post_data_t = _cef_post_data_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_post_data_t object."]
    #[doc = ""]
    pub fn cef_post_data_create() -> *mut cef_post_data_t;
}
#[doc = ""]
#[doc = " Structure used to represent a single element in the request post data. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_post_data_element_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Remove all contents from the post data element."]
    #[doc = ""]
    pub set_to_empty:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_element_t)>,
    #[doc = ""]
    #[doc = " The post data element will represent a file."]
    #[doc = ""]
    pub set_to_file: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t, fileName: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " The post data element will represent bytes.  The bytes passed in will be"]
    #[doc = " copied."]
    #[doc = ""]
    pub set_to_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_element_t,
            size: usize,
            bytes: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = ""]
    #[doc = " Return the type of this post data element."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> cef_postdataelement_type_t,
    >,
    #[doc = ""]
    #[doc = " Return the file name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_file: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the number of bytes."]
    #[doc = ""]
    pub get_bytes_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> usize>,
    #[doc = ""]
    #[doc = " Read up to |size| bytes into |bytes| and return the number of bytes"]
    #[doc = " actually read."]
    #[doc = ""]
    pub get_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_element_t,
            size: usize,
            bytes: *mut ::std::os::raw::c_void,
        ) -> usize,
    >,
}
#[doc = ""]
#[doc = " Structure used to represent a single element in the request post data. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
pub type cef_post_data_element_t = _cef_post_data_element_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_post_data_element_t object."]
    #[doc = ""]
    pub fn cef_post_data_element_create() -> *mut cef_post_data_element_t;
}
#[doc = ""]
#[doc = " Implement this structure to receive string values asynchronously."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_string_visitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_string_visitor_t, string: *const cef_string_t),
    >,
}
#[doc = ""]
#[doc = " Structure used to represent a frame in the browser window. When used in the"]
#[doc = " browser process the functions of this structure may be called on any thread"]
#[doc = " unless otherwise indicated in the comments. When used in the render process"]
#[doc = " the functions of this structure may only be called on the main thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_frame_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " True if this object is currently attached to a valid frame."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Execute undo in this frame."]
    #[doc = ""]
    pub undo: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute redo in this frame."]
    #[doc = ""]
    pub redo: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute cut in this frame."]
    #[doc = ""]
    pub cut: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute copy in this frame."]
    #[doc = ""]
    pub copy: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute paste in this frame."]
    #[doc = ""]
    pub paste: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute delete in this frame."]
    #[doc = ""]
    pub del: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute select all in this frame."]
    #[doc = ""]
    pub select_all: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Save this frame's HTML source to a temporary file and open it in the"]
    #[doc = " default text viewing application. This function can only be called from the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub view_source: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Retrieve this frame's HTML source as a string sent to the specified"]
    #[doc = " visitor."]
    #[doc = ""]
    pub get_source: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_string_visitor_t),
    >,
    #[doc = ""]
    #[doc = " Retrieve this frame's display text as a string sent to the specified"]
    #[doc = " visitor."]
    #[doc = ""]
    pub get_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_string_visitor_t),
    >,
    #[doc = ""]
    #[doc = " Load the request represented by the |request| object."]
    #[doc = ""]
    pub load_request: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, request: *mut _cef_request_t),
    >,
    #[doc = ""]
    #[doc = " Load the specified |url|."]
    #[doc = ""]
    pub load_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Load the contents of |string_val| with the specified dummy |url|. |url|"]
    #[doc = " should have a standard scheme (for example, http scheme) or behaviors like"]
    #[doc = " link clicks and web security restrictions may not behave as expected."]
    #[doc = ""]
    pub load_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_t,
            string_val: *const cef_string_t,
            url: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Execute a string of JavaScript code in this frame. The |script_url|"]
    #[doc = " parameter is the URL where the script in question can be found, if any. The"]
    #[doc = " renderer may request this URL to show the developer the source of the"]
    #[doc = " error.  The |start_line| parameter is the base line number to use for error"]
    #[doc = " reporting."]
    #[doc = ""]
    pub execute_java_script: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_t,
            code: *const cef_string_t,
            script_url: *const cef_string_t,
            start_line: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is the main (top-level) frame."]
    #[doc = ""]
    pub is_main: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is the focused frame."]
    #[doc = ""]
    pub is_focused: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the name for this frame. If the frame has an assigned name (for"]
    #[doc = " example, set via the iframe \"name\" attribute) then that value will be"]
    #[doc = " returned. Otherwise a unique name will be constructed based on the frame"]
    #[doc = " parent hierarchy. The main (top-level) frame will always have an NULL name"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the globally unique identifier for this frame or < 0 if the"]
    #[doc = " underlying frame does not yet exist."]
    #[doc = ""]
    pub get_identifier:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t) -> int64>,
    #[doc = ""]
    #[doc = " Returns the parent of this frame or NULL if this is the main (top-level)"]
    #[doc = " frame."]
    #[doc = ""]
    pub get_parent:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_frame_t>,
    #[doc = ""]
    #[doc = " Returns the URL currently loaded in this frame."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the browser that this frame belongs to."]
    #[doc = ""]
    pub get_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_browser_t,
    >,
    #[doc = ""]
    #[doc = " Get the V8 context associated with the frame. This function can only be"]
    #[doc = " called from the render process."]
    #[doc = ""]
    pub get_v8context: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_v8context_t,
    >,
    #[doc = ""]
    #[doc = " Visit the DOM document. This function can only be called from the render"]
    #[doc = " process."]
    #[doc = ""]
    pub visit_dom: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_domvisitor_t),
    >,
}
#[doc = ""]
#[doc = " Structure representing the issuer or subject field of an X.509 certificate."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_x509cert_principal_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns a name that can be used to represent the issuer. It tries in this"]
    #[doc = " order: Common Name (CN), Organization Name (O) and Organizational Unit Name"]
    #[doc = " (OU) and returns the first non-NULL one found."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_display_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the common name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_common_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the locality name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_locality_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the state or province name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_state_or_province_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the country name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_country_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of street addresses."]
    #[doc = ""]
    pub get_street_addresses: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, addresses: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of organization names."]
    #[doc = ""]
    pub get_organization_names: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, names: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of organization unit names."]
    #[doc = ""]
    pub get_organization_unit_names: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, names: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of domain components."]
    #[doc = ""]
    pub get_domain_components: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, components: cef_string_list_t),
    >,
}
#[doc = ""]
#[doc = " Structure representing a X.509 certificate."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_x509certificate_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the subject of the X.509 certificate. For HTTPS server certificates"]
    #[doc = " this represents the web server.  The common name of the subject should"]
    #[doc = " match the host name of the web server."]
    #[doc = ""]
    pub get_subject: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_x509cert_principal_t,
    >,
    #[doc = ""]
    #[doc = " Returns the issuer of the X.509 certificate."]
    #[doc = ""]
    pub get_issuer: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_x509cert_principal_t,
    >,
    #[doc = ""]
    #[doc = " Returns the DER encoded serial number for the X.509 certificate. The value"]
    #[doc = " possibly includes a leading 00 byte."]
    #[doc = ""]
    pub get_serial_number: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the date before which the X.509 certificate is invalid."]
    #[doc = " CefTime.GetTimeT() will return 0 if no date was specified."]
    #[doc = ""]
    pub get_valid_start: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> cef_time_t,
    >,
    #[doc = ""]
    #[doc = " Returns the date after which the X.509 certificate is invalid."]
    #[doc = " CefTime.GetTimeT() will return 0 if no date was specified."]
    #[doc = ""]
    pub get_valid_expiry: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> cef_time_t,
    >,
    #[doc = ""]
    #[doc = " Returns the DER encoded data for the X.509 certificate."]
    #[doc = ""]
    pub get_derencoded: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the PEM encoded data for the X.509 certificate."]
    #[doc = ""]
    pub get_pemencoded: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the number of certificates in the issuer chain. If 0, the"]
    #[doc = " certificate is self-signed."]
    #[doc = ""]
    pub get_issuer_chain_size:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> usize>,
    #[doc = ""]
    #[doc = " Returns the DER encoded data for the certificate issuer chain. If we failed"]
    #[doc = " to encode a certificate in the chain it is still present in the array but"]
    #[doc = " is an NULL string."]
    #[doc = ""]
    pub get_derencoded_issuer_chain: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_x509certificate_t,
            chainCount: *mut usize,
            chain: *mut *mut _cef_binary_value_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns the PEM encoded data for the certificate issuer chain. If we failed"]
    #[doc = " to encode a certificate in the chain it is still present in the array but"]
    #[doc = " is an NULL string."]
    #[doc = ""]
    pub get_pemencoded_issuer_chain: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_x509certificate_t,
            chainCount: *mut usize,
            chain: *mut *mut _cef_binary_value_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Structure representing the SSL information for a navigation entry."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_sslstatus_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the status is related to a secure SSL/TLS connection."]
    #[doc = ""]
    pub is_secure_connection: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a bitmask containing any and all problems verifying the server"]
    #[doc = " certificate."]
    #[doc = ""]
    pub get_cert_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_cert_status_t,
    >,
    #[doc = ""]
    #[doc = " Returns the SSL version used for the SSL connection."]
    #[doc = ""]
    pub get_sslversion: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_ssl_version_t,
    >,
    #[doc = ""]
    #[doc = " Returns a bitmask containing the page security content status."]
    #[doc = ""]
    pub get_content_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_ssl_content_status_t,
    >,
    #[doc = ""]
    #[doc = " Returns the X.509 certificate."]
    #[doc = ""]
    pub get_x509certificate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> *mut _cef_x509certificate_t,
    >,
}
#[doc = ""]
#[doc = " Structure used to represent an entry in navigation history."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_navigation_entry_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the actual URL of the page. For some pages this may be data: URL or"]
    #[doc = " similar. Use get_display_url() to return a display-friendly version."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns a display-friendly version of the URL."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_display_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the original URL that was entered by the user before any redirects."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_original_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the title set by the page. This value may be NULL."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_title: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the transition type which indicates what the user did to move to"]
    #[doc = " this page from the previous page."]
    #[doc = ""]
    pub get_transition_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_transition_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this navigation includes post data."]
    #[doc = ""]
    pub has_post_data: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the time for the last known successful navigation completion. A"]
    #[doc = " navigation may be completed more than once if the page is reloaded. May be"]
    #[doc = " 0 if the navigation has not yet completed."]
    #[doc = ""]
    pub get_completion_time: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_time_t,
    >,
    #[doc = ""]
    #[doc = " Returns the HTTP status code for the last known successful navigation"]
    #[doc = " response. May be 0 if the response has not yet been received or if the"]
    #[doc = " navigation has not yet completed."]
    #[doc = ""]
    pub get_http_status_code: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the SSL information for this navigation entry."]
    #[doc = ""]
    pub get_sslstatus: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> *mut _cef_sslstatus_t,
    >,
}
#[doc = ""]
#[doc = " Structure representing a message. Can be used on any process and thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_process_message_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> *mut _cef_process_message_t,
    >,
    #[doc = ""]
    #[doc = " Returns the message name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the list of arguments."]
    #[doc = ""]
    pub get_argument_list: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> *mut _cef_list_value_t,
    >,
}
#[doc = ""]
#[doc = " Structure representing a message. Can be used on any process and thread."]
#[doc = ""]
pub type cef_process_message_t = _cef_process_message_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_process_message_t object with the specified name."]
    #[doc = ""]
    pub fn cef_process_message_create(name: *const cef_string_t) -> *mut cef_process_message_t;
}
#[doc = ""]
#[doc = " Generic callback structure used for asynchronous continuation."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue processing."]
    #[doc = ""]
    pub cont: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_callback_t)>,
    #[doc = ""]
    #[doc = " Cancel processing."]
    #[doc = ""]
    pub cancel: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_callback_t)>,
}
#[doc = ""]
#[doc = " Generic callback structure used for asynchronous completion."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_completion_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called once the task is complete."]
    #[doc = ""]
    pub on_complete:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_completion_callback_t)>,
}
#[doc = ""]
#[doc = " Structure used for managing cookies. The functions of this structure may be"]
#[doc = " called on any thread unless otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_manager_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Set the schemes supported by this manager. The default schemes (\"http\","]
    #[doc = " \"https\", \"ws\" and \"wss\") will always be supported. If |callback| is non-"]
    #[doc = " NULL it will be executed asnychronously on the IO thread after the change"]
    #[doc = " has been applied. Must be called before any cookies are accessed."]
    #[doc = ""]
    pub set_supported_schemes: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            schemes: cef_string_list_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Visit all cookies on the IO thread. The returned cookies are ordered by"]
    #[doc = " longest path, then by earliest creation date. Returns false (0) if cookies"]
    #[doc = " cannot be accessed."]
    #[doc = ""]
    pub visit_all_cookies: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            visitor: *mut _cef_cookie_visitor_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Visit a subset of cookies on the IO thread. The results are filtered by the"]
    #[doc = " given url scheme, host, domain and path. If |includeHttpOnly| is true (1)"]
    #[doc = " HTTP-only cookies will also be included in the results. The returned"]
    #[doc = " cookies are ordered by longest path, then by earliest creation date."]
    #[doc = " Returns false (0) if cookies cannot be accessed."]
    #[doc = ""]
    pub visit_url_cookies: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            includeHttpOnly: ::std::os::raw::c_int,
            visitor: *mut _cef_cookie_visitor_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets a cookie given a valid URL and explicit user-provided cookie"]
    #[doc = " attributes. This function expects each attribute to be well-formed. It will"]
    #[doc = " check for disallowed characters (e.g. the ';' character is disallowed"]
    #[doc = " within the cookie value attribute) and fail without setting the cookie if"]
    #[doc = " such characters are found. If |callback| is non-NULL it will be executed"]
    #[doc = " asnychronously on the IO thread after the cookie has been set. Returns"]
    #[doc = " false (0) if an invalid URL is specified or if cookies cannot be accessed."]
    #[doc = ""]
    pub set_cookie: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            cookie: *const _cef_cookie_t,
            callback: *mut _cef_set_cookie_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Delete all cookies that match the specified parameters. If both |url| and"]
    #[doc = " |cookie_name| values are specified all host and domain cookies matching"]
    #[doc = " both will be deleted. If only |url| is specified all host cookies (but not"]
    #[doc = " domain cookies) irrespective of path will be deleted. If |url| is NULL all"]
    #[doc = " cookies for all hosts and domains will be deleted. If |callback| is non-"]
    #[doc = " NULL it will be executed asnychronously on the IO thread after the cookies"]
    #[doc = " have been deleted. Returns false (0) if a non-NULL invalid URL is specified"]
    #[doc = " or if cookies cannot be accessed. Cookies can alternately be deleted using"]
    #[doc = " the Visit*Cookies() functions."]
    #[doc = ""]
    pub delete_cookies: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            cookie_name: *const cef_string_t,
            callback: *mut _cef_delete_cookies_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the directory path that will be used for storing cookie data. If"]
    #[doc = " |path| is NULL data will be stored in memory only. Otherwise, data will be"]
    #[doc = " stored at the specified |path|. To persist session cookies (cookies without"]
    #[doc = " an expiry date or validity interval) set |persist_session_cookies| to true"]
    #[doc = " (1). Session cookies are generally intended to be transient and most Web"]
    #[doc = " browsers do not persist them. If |callback| is non-NULL it will be executed"]
    #[doc = " asnychronously on the IO thread after the manager's storage has been"]
    #[doc = " initialized. Returns false (0) if cookies cannot be accessed."]
    #[doc = ""]
    pub set_storage_path: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            path: *const cef_string_t,
            persist_session_cookies: ::std::os::raw::c_int,
            callback: *mut _cef_completion_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Flush the backing store (if any) to disk. If |callback| is non-NULL it will"]
    #[doc = " be executed asnychronously on the IO thread after the flush is complete."]
    #[doc = " Returns false (0) if cookies cannot be accessed."]
    #[doc = ""]
    pub flush_store: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            callback: *mut _cef_completion_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used for managing cookies. The functions of this structure may be"]
#[doc = " called on any thread unless otherwise indicated."]
#[doc = ""]
pub type cef_cookie_manager_t = _cef_cookie_manager_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the global cookie manager. By default data will be stored at"]
    #[doc = " CefSettings.cache_path if specified or in memory otherwise. If |callback| is"]
    #[doc = " non-NULL it will be executed asnychronously on the IO thread after the"]
    #[doc = " manager's storage has been initialized. Using this function is equivalent to"]
    #[doc = " calling cef_request_tContext::cef_request_context_get_global_context()->get_d"]
    #[doc = " efault_cookie_manager()."]
    #[doc = ""]
    pub fn cef_cookie_manager_get_global_manager(
        callback: *mut _cef_completion_callback_t,
    ) -> *mut cef_cookie_manager_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new cookie manager. If |path| is NULL data will be stored in memory"]
    #[doc = " only. Otherwise, data will be stored at the specified |path|. To persist"]
    #[doc = " session cookies (cookies without an expiry date or validity interval) set"]
    #[doc = " |persist_session_cookies| to true (1). Session cookies are generally intended"]
    #[doc = " to be transient and most Web browsers do not persist them. If |callback| is"]
    #[doc = " non-NULL it will be executed asnychronously on the IO thread after the"]
    #[doc = " manager's storage has been initialized."]
    #[doc = ""]
    pub fn cef_cookie_manager_create_manager(
        path: *const cef_string_t,
        persist_session_cookies: ::std::os::raw::c_int,
        callback: *mut _cef_completion_callback_t,
    ) -> *mut cef_cookie_manager_t;
}
#[doc = ""]
#[doc = " Structure to implement for visiting cookie values. The functions of this"]
#[doc = " structure will always be called on the IO thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_cookie_visitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called once for each cookie. |count| is the 0-based"]
    #[doc = " index for the current cookie. |total| is the total number of cookies. Set"]
    #[doc = " |deleteCookie| to true (1) to delete the cookie currently being visited."]
    #[doc = " Return false (0) to stop visiting cookies. This function may never be"]
    #[doc = " called if no cookies are found."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_visitor_t,
            cookie: *const _cef_cookie_t,
            count: ::std::os::raw::c_int,
            total: ::std::os::raw::c_int,
            deleteCookie: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure to implement to be notified of asynchronous completion via"]
#[doc = " cef_cookie_manager_t::set_cookie()."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_set_cookie_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called upon completion. |success| will be true (1) if"]
    #[doc = " the cookie was set successfully."]
    #[doc = ""]
    pub on_complete: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_set_cookie_callback_t,
            success: ::std::os::raw::c_int,
        ),
    >,
}
#[doc = ""]
#[doc = " Structure to implement to be notified of asynchronous completion via"]
#[doc = " cef_cookie_manager_t::delete_cookies()."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_delete_cookies_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called upon completion. |num_deleted| will be the"]
    #[doc = " number of cookies that were deleted or -1 if unknown."]
    #[doc = ""]
    pub on_complete: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_delete_cookies_callback_t,
            num_deleted: ::std::os::raw::c_int,
        ),
    >,
}
#[doc = ""]
#[doc = " Information about a specific web plugin."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_web_plugin_info_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the plugin name (i.e. Flash)."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_web_plugin_info_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the plugin file path (DLL/bundle/library)."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_path: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_web_plugin_info_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the version of the plugin (may be OS-specific)."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_version: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_web_plugin_info_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns a description of the plugin from the version information."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_description: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_web_plugin_info_t) -> cef_string_userfree_t,
    >,
}
#[doc = ""]
#[doc = " Structure to implement for visiting web plugin information. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_web_plugin_info_visitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called once for each plugin. |count| is the 0-based"]
    #[doc = " index for the current plugin. |total| is the total number of plugins."]
    #[doc = " Return false (0) to stop visiting plugins. This function may never be"]
    #[doc = " called if no plugins are found."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_web_plugin_info_visitor_t,
            info: *mut _cef_web_plugin_info_t,
            count: ::std::os::raw::c_int,
            total: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure to implement for visiting web plugin information. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_web_plugin_info_visitor_t = _cef_web_plugin_info_visitor_t;
#[doc = ""]
#[doc = " Structure to implement for receiving unstable plugin information. The"]
#[doc = " functions of this structure will be called on the browser process IO thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_web_plugin_unstable_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called for the requested plugin. |unstable| will be"]
    #[doc = " true (1) if the plugin has reached the crash count threshold of 3 times in"]
    #[doc = " 120 seconds."]
    #[doc = ""]
    pub is_unstable: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_web_plugin_unstable_callback_t,
            path: *const cef_string_t,
            unstable: ::std::os::raw::c_int,
        ),
    >,
}
#[doc = ""]
#[doc = " Structure to implement for receiving unstable plugin information. The"]
#[doc = " functions of this structure will be called on the browser process IO thread."]
#[doc = ""]
pub type cef_web_plugin_unstable_callback_t = _cef_web_plugin_unstable_callback_t;
#[doc = ""]
#[doc = " Implement this structure to receive notification when CDM registration is"]
#[doc = " complete. The functions of this structure will be called on the browser"]
#[doc = " process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_register_cdm_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called when CDM registration is complete. |result| will"]
    #[doc = " be CEF_CDM_REGISTRATION_ERROR_NONE if registration completed successfully."]
    #[doc = " Otherwise, |result| and |error_message| will contain additional information"]
    #[doc = " about why registration failed."]
    #[doc = ""]
    pub on_cdm_registration_complete: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_register_cdm_callback_t,
            result: cef_cdm_registration_error_t,
            error_message: *const cef_string_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to receive notification when CDM registration is"]
#[doc = " complete. The functions of this structure will be called on the browser"]
#[doc = " process UI thread."]
#[doc = ""]
pub type cef_register_cdm_callback_t = _cef_register_cdm_callback_t;
extern "C" {
    #[doc = ""]
    #[doc = " Visit web plugin information. Can be called on any thread in the browser"]
    #[doc = " process."]
    #[doc = ""]
    pub fn cef_visit_web_plugin_info(visitor: *mut cef_web_plugin_info_visitor_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Cause the plugin list to refresh the next time it is accessed regardless of"]
    #[doc = " whether it has already been loaded. Can be called on any thread in the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub fn cef_refresh_web_plugins();
}
extern "C" {
    #[doc = ""]
    #[doc = " Unregister an internal plugin. This may be undone the next time"]
    #[doc = " cef_refresh_web_plugins() is called. Can be called on any thread in the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub fn cef_unregister_internal_web_plugin(path: *const cef_string_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Register a plugin crash. Can be called on any thread in the browser process"]
    #[doc = " but will be executed on the IO thread."]
    #[doc = ""]
    pub fn cef_register_web_plugin_crash(path: *const cef_string_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Query if a plugin is unstable. Can be called on any thread in the browser"]
    #[doc = " process."]
    #[doc = ""]
    pub fn cef_is_web_plugin_unstable(
        path: *const cef_string_t,
        callback: *mut cef_web_plugin_unstable_callback_t,
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " Register the Widevine CDM plugin."]
    #[doc = ""]
    #[doc = " The client application is responsible for downloading an appropriate"]
    #[doc = " platform-specific CDM binary distribution from Google, extracting the"]
    #[doc = " contents, and building the required directory structure on the local machine."]
    #[doc = " The cef_browser_host_t::StartDownload function and CefZipArchive structure"]
    #[doc = " can be used to implement this functionality in CEF. Contact Google via"]
    #[doc = " https://www.widevine.com/contact.html for details on CDM download."]
    #[doc = ""]
    #[doc = " |path| is a directory that must contain the following files:"]
    #[doc = "   1. manifest.json file from the CDM binary distribution (see below)."]
    #[doc = "   2. widevinecdm file from the CDM binary distribution (e.g."]
    #[doc = "      widevinecdm.dll on on Windows, libwidevinecdm.dylib on OS X,"]
    #[doc = "      libwidevinecdm.so on Linux)."]
    #[doc = "   3. widevidecdmadapter file from the CEF binary distribution (e.g."]
    #[doc = "      widevinecdmadapter.dll on Windows, widevinecdmadapter.plugin on OS X,"]
    #[doc = "      libwidevinecdmadapter.so on Linux)."]
    #[doc = ""]
    #[doc = " If any of these files are missing or if the manifest file has incorrect"]
    #[doc = " contents the registration will fail and |callback| will receive a |result|"]
    #[doc = " value of CEF_CDM_REGISTRATION_ERROR_INCORRECT_CONTENTS."]
    #[doc = ""]
    #[doc = " The manifest.json file must contain the following keys:"]
    #[doc = "   A. \"os\": Supported OS (e.g. \"mac\", \"win\" or \"linux\")."]
    #[doc = "   B. \"arch\": Supported architecture (e.g. \"ia32\" or \"x64\")."]
    #[doc = "   C. \"x-cdm-module-versions\": Module API version (e.g. \"4\")."]
    #[doc = "   D. \"x-cdm-interface-versions\": Interface API version (e.g. \"8\")."]
    #[doc = "   E. \"x-cdm-host-versions\": Host API version (e.g. \"8\")."]
    #[doc = "   F. \"version\": CDM version (e.g. \"1.4.8.903\")."]
    #[doc = "   G. \"x-cdm-codecs\": List of supported codecs (e.g. \"vp8,vp9.0,avc1\")."]
    #[doc = ""]
    #[doc = " A through E are used to verify compatibility with the current Chromium"]
    #[doc = " version. If the CDM is not compatible the registration will fail and"]
    #[doc = " |callback| will receive a |result| value of"]
    #[doc = " CEF_CDM_REGISTRATION_ERROR_INCOMPATIBLE."]
    #[doc = ""]
    #[doc = " |callback| will be executed asynchronously once registration is complete."]
    #[doc = ""]
    #[doc = " On Linux this function must be called before cef_initialize() and the"]
    #[doc = " registration cannot be changed during runtime. If registration is not"]
    #[doc = " supported at the time that cef_register_widevine_cdm() is called then"]
    #[doc = " |callback| will receive a |result| value of"]
    #[doc = " CEF_CDM_REGISTRATION_ERROR_NOT_SUPPORTED."]
    #[doc = ""]
    pub fn cef_register_widevine_cdm(
        path: *const cef_string_t,
        callback: *mut cef_register_cdm_callback_t,
    );
}
#[doc = ""]
#[doc = " Implement this structure to provide handler implementations. The handler"]
#[doc = " instance will not be released until all objects related to the context have"]
#[doc = " been destroyed."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the browser process IO thread to retrieve the cookie manager. If"]
    #[doc = " this function returns NULL the default cookie manager retrievable via"]
    #[doc = " cef_request_tContext::get_default_cookie_manager() will be used."]
    #[doc = ""]
    pub get_cookie_manager: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_handler_t,
        ) -> *mut _cef_cookie_manager_t,
    >,
    #[doc = ""]
    #[doc = " Called on multiple browser process threads before a plugin instance is"]
    #[doc = " loaded. |mime_type| is the mime type of the plugin that will be loaded."]
    #[doc = " |plugin_url| is the content URL that the plugin will load and may be NULL."]
    #[doc = " |is_main_frame| will be true (1) if the plugin is being loaded in the main"]
    #[doc = " (top-level) frame, |top_origin_url| is the URL for the top-level frame that"]
    #[doc = " contains the plugin when loading a specific plugin instance or NULL when"]
    #[doc = " building the initial list of enabled plugins for 'navigator.plugins'"]
    #[doc = " JavaScript state. |plugin_info| includes additional information about the"]
    #[doc = " plugin that will be loaded. |plugin_policy| is the recommended policy."]
    #[doc = " Modify |plugin_policy| and return true (1) to change the policy. Return"]
    #[doc = " false (0) to use the recommended policy. The default plugin policy can be"]
    #[doc = " set at runtime using the `--plugin-policy=[allow|detect|block]` command-"]
    #[doc = " line flag. Decisions to mark a plugin as disabled by setting"]
    #[doc = " |plugin_policy| to PLUGIN_POLICY_DISABLED may be cached when"]
    #[doc = " |top_origin_url| is NULL. To purge the plugin list cache and potentially"]
    #[doc = " trigger new calls to this function call"]
    #[doc = " cef_request_tContext::PurgePluginListCache."]
    #[doc = ""]
    pub on_before_plugin_load: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_handler_t,
            mime_type: *const cef_string_t,
            plugin_url: *const cef_string_t,
            is_main_frame: ::std::os::raw::c_int,
            top_origin_url: *const cef_string_t,
            plugin_info: *mut _cef_web_plugin_info_t,
            plugin_policy: *mut cef_plugin_policy_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Callback structure for cef_request_tContext::ResolveHost."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resolve_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called after the ResolveHost request has completed. |result| will be the"]
    #[doc = " result code. |resolved_ips| will be the list of resolved IP addresses or"]
    #[doc = " NULL if the resolution failed."]
    #[doc = ""]
    pub on_resolve_completed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resolve_callback_t,
            result: cef_errorcode_t,
            resolved_ips: cef_string_list_t,
        ),
    >,
}
#[doc = ""]
#[doc = " A request context provides request handling for a set of related browser or"]
#[doc = " URL request objects. A request context can be specified when creating a new"]
#[doc = " browser via the cef_browser_host_t static factory functions or when creating"]
#[doc = " a new URL request via the cef_urlrequest_t static factory functions. Browser"]
#[doc = " objects with different request contexts will never be hosted in the same"]
#[doc = " render process. Browser objects with the same request context may or may not"]
#[doc = " be hosted in the same render process depending on the process model. Browser"]
#[doc = " objects created indirectly via the JavaScript window.open function or"]
#[doc = " targeted links will share the same render process and the same request"]
#[doc = " context as the source browser. When running in single-process mode there is"]
#[doc = " only a single render process (the main process) and so all browsers created"]
#[doc = " in single-process mode will share the same request context. This will be the"]
#[doc = " first request context passed into a cef_browser_host_t static factory"]
#[doc = " function and all other request context objects will be ignored."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same context as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            other: *mut _cef_request_context_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is sharing the same storage as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_sharing_with: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            other: *mut _cef_request_context_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is the global context. The global context"]
    #[doc = " is used by default when creating a browser or URL request with a NULL"]
    #[doc = " context argument."]
    #[doc = ""]
    pub is_global: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the handler for this context if any."]
    #[doc = ""]
    pub get_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
        ) -> *mut _cef_request_context_handler_t,
    >,
    #[doc = ""]
    #[doc = " Returns the cache path for this object. If NULL an \"incognito mode\" in-"]
    #[doc = " memory cache is being used."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_cache_path: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the default cookie manager for this object. This will be the global"]
    #[doc = " cookie manager if this object is the global request context. Otherwise,"]
    #[doc = " this will be the default cookie manager used when this request context does"]
    #[doc = " not receive a value via cef_request_tContextHandler::get_cookie_manager()."]
    #[doc = " If |callback| is non-NULL it will be executed asnychronously on the IO"]
    #[doc = " thread after the manager's storage has been initialized."]
    #[doc = ""]
    pub get_default_cookie_manager: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ) -> *mut _cef_cookie_manager_t,
    >,
    #[doc = ""]
    #[doc = " Register a scheme handler factory for the specified |scheme_name| and"]
    #[doc = " optional |domain_name|. An NULL |domain_name| value for a standard scheme"]
    #[doc = " will cause the factory to match all domain names. The |domain_name| value"]
    #[doc = " will be ignored for non-standard schemes. If |scheme_name| is a built-in"]
    #[doc = " scheme and no handler is returned by |factory| then the built-in scheme"]
    #[doc = " handler factory will be called. If |scheme_name| is a custom scheme then"]
    #[doc = " you must also implement the cef_app_t::on_register_custom_schemes()"]
    #[doc = " function in all processes. This function may be called multiple times to"]
    #[doc = " change or remove the factory that matches the specified |scheme_name| and"]
    #[doc = " optional |domain_name|. Returns false (0) if an error occurs. This function"]
    #[doc = " may be called on any thread in the browser process."]
    #[doc = ""]
    pub register_scheme_handler_factory: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            scheme_name: *const cef_string_t,
            domain_name: *const cef_string_t,
            factory: *mut _cef_scheme_handler_factory_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Clear all registered scheme handler factories. Returns false (0) on error."]
    #[doc = " This function may be called on any thread in the browser process."]
    #[doc = ""]
    pub clear_scheme_handler_factories: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Tells all renderer processes associated with this context to throw away"]
    #[doc = " their plugin list cache. If |reload_pages| is true (1) they will also"]
    #[doc = " reload all pages with plugins."]
    #[doc = " cef_request_tContextHandler::OnBeforePluginLoad may be called to rebuild"]
    #[doc = " the plugin list cache."]
    #[doc = ""]
    pub purge_plugin_list_cache: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            reload_pages: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if a preference with the specified |name| exists. This"]
    #[doc = " function must be called on the browser process UI thread."]
    #[doc = ""]
    pub has_preference: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value for the preference with the specified |name|. Returns"]
    #[doc = " NULL if the preference does not exist. The returned object contains a copy"]
    #[doc = " of the underlying preference value and modifications to the returned object"]
    #[doc = " will not modify the underlying preference value. This function must be"]
    #[doc = " called on the browser process UI thread."]
    #[doc = ""]
    pub get_preference: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> *mut _cef_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns all preferences as a dictionary. If |include_defaults| is true (1)"]
    #[doc = " then preferences currently at their default value will be included. The"]
    #[doc = " returned object contains a copy of the underlying preference values and"]
    #[doc = " modifications to the returned object will not modify the underlying"]
    #[doc = " preference values. This function must be called on the browser process UI"]
    #[doc = " thread."]
    #[doc = ""]
    pub get_all_preferences: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            include_defaults: ::std::os::raw::c_int,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the preference with the specified |name| can be"]
    #[doc = " modified using SetPreference. As one example preferences set via the"]
    #[doc = " command-line usually cannot be modified. This function must be called on"]
    #[doc = " the browser process UI thread."]
    #[doc = ""]
    pub can_set_preference: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the |value| associated with preference |name|. Returns true (1) if the"]
    #[doc = " value is set successfully and false (0) otherwise. If |value| is NULL the"]
    #[doc = " preference will be restored to its default value. If setting the preference"]
    #[doc = " fails then |error| will be populated with a detailed description of the"]
    #[doc = " problem. This function must be called on the browser process UI thread."]
    #[doc = ""]
    pub set_preference: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
            value: *mut _cef_value_t,
            error: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Clears all certificate exceptions that were added as part of handling"]
    #[doc = " cef_request_tHandler::on_certificate_error(). If you call this it is"]
    #[doc = " recommended that you also call close_all_connections() or you risk not"]
    #[doc = " being prompted again for server certificates if you reconnect quickly. If"]
    #[doc = " |callback| is non-NULL it will be executed on the UI thread after"]
    #[doc = " completion."]
    #[doc = ""]
    pub clear_certificate_exceptions: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Clears all active and idle connections that Chromium currently has. This is"]
    #[doc = " only recommended if you have released all other CEF objects but don't yet"]
    #[doc = " want to call cef_shutdown(). If |callback| is non-NULL it will be executed"]
    #[doc = " on the UI thread after completion."]
    #[doc = ""]
    pub close_all_connections: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Attempts to resolve |origin| to a list of associated IP addresses."]
    #[doc = " |callback| will be executed on the UI thread after completion."]
    #[doc = ""]
    pub resolve_host: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            origin: *const cef_string_t,
            callback: *mut _cef_resolve_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Attempts to resolve |origin| to a list of associated IP addresses using"]
    #[doc = " cached data. |resolved_ips| will be populated with the list of resolved IP"]
    #[doc = " addresses or NULL if no cached data is available. Returns ERR_NONE on"]
    #[doc = " success. This function must be called on the browser process IO thread."]
    #[doc = ""]
    pub resolve_host_cached: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            origin: *const cef_string_t,
            resolved_ips: cef_string_list_t,
        ) -> cef_errorcode_t,
    >,
}
#[doc = ""]
#[doc = " A request context provides request handling for a set of related browser or"]
#[doc = " URL request objects. A request context can be specified when creating a new"]
#[doc = " browser via the cef_browser_host_t static factory functions or when creating"]
#[doc = " a new URL request via the cef_urlrequest_t static factory functions. Browser"]
#[doc = " objects with different request contexts will never be hosted in the same"]
#[doc = " render process. Browser objects with the same request context may or may not"]
#[doc = " be hosted in the same render process depending on the process model. Browser"]
#[doc = " objects created indirectly via the JavaScript window.open function or"]
#[doc = " targeted links will share the same render process and the same request"]
#[doc = " context as the source browser. When running in single-process mode there is"]
#[doc = " only a single render process (the main process) and so all browsers created"]
#[doc = " in single-process mode will share the same request context. This will be the"]
#[doc = " first request context passed into a cef_browser_host_t static factory"]
#[doc = " function and all other request context objects will be ignored."]
#[doc = ""]
pub type cef_request_context_t = _cef_request_context_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the global context object."]
    #[doc = ""]
    pub fn cef_request_context_get_global_context() -> *mut cef_request_context_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new context object with the specified |settings| and optional"]
    #[doc = " |handler|."]
    #[doc = ""]
    pub fn cef_request_context_create_context(
        settings: *const _cef_request_context_settings_t,
        handler: *mut _cef_request_context_handler_t,
    ) -> *mut cef_request_context_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new context object that shares storage with |other| and uses an"]
    #[doc = " optional |handler|."]
    #[doc = ""]
    pub fn cef_create_context_shared(
        other: *mut cef_request_context_t,
        handler: *mut _cef_request_context_handler_t,
    ) -> *mut cef_request_context_t;
}
#[doc = ""]
#[doc = " Structure used to represent a browser window. When used in the browser"]
#[doc = " process the functions of this structure may be called on any thread unless"]
#[doc = " otherwise indicated in the comments. When used in the render process the"]
#[doc = " functions of this structure may only be called on the main thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the browser host object. This function can only be called in the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub get_host: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_browser_host_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the browser can navigate backwards."]
    #[doc = ""]
    pub can_go_back: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Navigate backwards."]
    #[doc = ""]
    pub go_back: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Returns true (1) if the browser can navigate forwards."]
    #[doc = ""]
    pub can_go_forward: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Navigate forwards."]
    #[doc = ""]
    pub go_forward: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Returns true (1) if the browser is currently loading."]
    #[doc = ""]
    pub is_loading: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Reload the current page."]
    #[doc = ""]
    pub reload: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Reload the current page ignoring any cached data."]
    #[doc = ""]
    pub reload_ignore_cache:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Stop loading the page."]
    #[doc = ""]
    pub stop_load: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Returns the globally unique identifier for this browser."]
    #[doc = ""]
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same handle as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            that: *mut _cef_browser_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the window is a popup window."]
    #[doc = ""]
    pub is_popup: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if a document has been loaded in the browser."]
    #[doc = ""]
    pub has_document: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the main (top-level) frame for the browser window."]
    #[doc = ""]
    pub get_main_frame: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the focused frame for the browser window."]
    #[doc = ""]
    pub get_focused_frame: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the frame with the specified identifier, or NULL if not found."]
    #[doc = ""]
    pub get_frame_byident: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t, identifier: int64) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the frame with the specified name, or NULL if not found."]
    #[doc = ""]
    pub get_frame: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            name: *const cef_string_t,
        ) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the number of frames that currently exist."]
    #[doc = ""]
    pub get_frame_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t) -> usize>,
    #[doc = ""]
    #[doc = " Returns the identifiers of all existing frames."]
    #[doc = ""]
    pub get_frame_identifiers: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            identifiersCount: *mut usize,
            identifiers: *mut int64,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns the names of all existing frames."]
    #[doc = ""]
    pub get_frame_names: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t, names: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Send a message to the specified |target_process|. Returns true (1) if the"]
    #[doc = " message was sent successfully."]
    #[doc = ""]
    pub send_process_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            target_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to represent a browser window. When used in the browser"]
#[doc = " process the functions of this structure may be called on any thread unless"]
#[doc = " otherwise indicated in the comments. When used in the render process the"]
#[doc = " functions of this structure may only be called on the main thread."]
#[doc = ""]
pub type cef_browser_t = _cef_browser_t;
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::RunFileDialog. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_run_file_dialog_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called asynchronously after the file dialog is dismissed."]
    #[doc = " |selected_accept_filter| is the 0-based index of the value selected from"]
    #[doc = " the accept filters array passed to cef_browser_host_t::RunFileDialog."]
    #[doc = " |file_paths| will be a single value or a list of values depending on the"]
    #[doc = " dialog mode. If the selection was cancelled |file_paths| will be NULL."]
    #[doc = ""]
    pub on_file_dialog_dismissed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_run_file_dialog_callback_t,
            selected_accept_filter: ::std::os::raw::c_int,
            file_paths: cef_string_list_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::GetNavigationEntries. The"]
#[doc = " functions of this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_navigation_entry_visitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed. Do not keep a reference to |entry| outside of"]
    #[doc = " this callback. Return true (1) to continue visiting entries or false (0) to"]
    #[doc = " stop. |current| is true (1) if this entry is the currently loaded"]
    #[doc = " navigation entry. |index| is the 0-based index of this entry and |total| is"]
    #[doc = " the total number of entries."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_navigation_entry_visitor_t,
            entry: *mut _cef_navigation_entry_t,
            current: ::std::os::raw::c_int,
            index: ::std::os::raw::c_int,
            total: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::PrintToPDF. The functions of this"]
#[doc = " structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_pdf_print_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed when the PDF printing has completed. |path| is"]
    #[doc = " the output path. |ok| will be true (1) if the printing completed"]
    #[doc = " successfully or false (0) otherwise."]
    #[doc = ""]
    pub on_pdf_print_finished: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_pdf_print_callback_t,
            path: *const cef_string_t,
            ok: ::std::os::raw::c_int,
        ),
    >,
}
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::DownloadImage. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_image_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed when the image download has completed."]
    #[doc = " |image_url| is the URL that was downloaded and |http_status_code| is the"]
    #[doc = " resulting HTTP status code. |image| is the resulting image, possibly at"]
    #[doc = " multiple scale factors, or NULL if the download failed."]
    #[doc = ""]
    pub on_download_image_finished: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_image_callback_t,
            image_url: *const cef_string_t,
            http_status_code: ::std::os::raw::c_int,
            image: *mut _cef_image_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Structure used to represent the browser process aspects of a browser window."]
#[doc = " The functions of this structure can only be called in the browser process."]
#[doc = " They may be called on any thread in that process unless otherwise indicated"]
#[doc = " in the comments."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_host_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the hosted browser object."]
    #[doc = ""]
    pub get_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_browser_t,
    >,
    #[doc = ""]
    #[doc = " Request that the browser close. The JavaScript 'onbeforeunload' event will"]
    #[doc = " be fired. If |force_close| is false (0) the event handler, if any, will be"]
    #[doc = " allowed to prompt the user and the user can optionally cancel the close. If"]
    #[doc = " |force_close| is true (1) the prompt will not be displayed and the close"]
    #[doc = " will proceed. Results in a call to cef_life_span_handler_t::do_close() if"]
    #[doc = " the event handler allows the close or if |force_close| is true (1). See"]
    #[doc = " cef_life_span_handler_t::do_close() documentation for additional usage"]
    #[doc = " information."]
    #[doc = ""]
    pub close_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, force_close: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Helper for closing a browser. Call this function from the top-level window"]
    #[doc = " close handler. Internally this calls CloseBrowser(false (0)) if the close"]
    #[doc = " has not yet been initiated. This function returns false (0) while the close"]
    #[doc = " is pending and true (1) after the close has completed. See close_browser()"]
    #[doc = " and cef_life_span_handler_t::do_close() documentation for additional usage"]
    #[doc = " information. This function must be called on the browser process UI thread."]
    #[doc = ""]
    pub try_close_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set whether the browser is focused."]
    #[doc = ""]
    pub set_focus: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, focus: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Retrieve the window handle for this browser. If this browser is wrapped in"]
    #[doc = " a cef_browser_view_t this function should be called on the browser process"]
    #[doc = " UI thread and it will return the handle for the top-level native window."]
    #[doc = ""]
    pub get_window_handle: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = ""]
    #[doc = " Retrieve the window handle of the browser that opened this browser. Will"]
    #[doc = " return NULL for non-popup windows or if this browser is wrapped in a"]
    #[doc = " cef_browser_view_t. This function can be used in combination with custom"]
    #[doc = " handling of modal windows."]
    #[doc = ""]
    pub get_opener_window_handle: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this browser is wrapped in a cef_browser_view_t."]
    #[doc = ""]
    pub has_view: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the client for this browser."]
    #[doc = ""]
    pub get_client: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_client_t,
    >,
    #[doc = ""]
    #[doc = " Returns the request context for this browser."]
    #[doc = ""]
    pub get_request_context: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_request_context_t,
    >,
    #[doc = ""]
    #[doc = " Get the current zoom level. The default zoom level is 0.0. This function"]
    #[doc = " can only be called on the UI thread."]
    #[doc = ""]
    pub get_zoom_level:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> f64>,
    #[doc = ""]
    #[doc = " Change the zoom level to the specified value. Specify 0.0 to reset the zoom"]
    #[doc = " level. If called on the UI thread the change will be applied immediately."]
    #[doc = " Otherwise, the change will be applied asynchronously on the UI thread."]
    #[doc = ""]
    pub set_zoom_level: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, zoomLevel: f64),
    >,
    #[doc = ""]
    #[doc = " Call to run a file chooser dialog. Only a single file chooser dialog may be"]
    #[doc = " pending at any given time. |mode| represents the type of dialog to display."]
    #[doc = " |title| to the title to be used for the dialog and may be NULL to show the"]
    #[doc = " default title (\"Open\" or \"Save\" depending on the mode). |default_file_path|"]
    #[doc = " is the path with optional directory and/or file name component that will be"]
    #[doc = " initially selected in the dialog. |accept_filters| are used to restrict the"]
    #[doc = " selectable file types and may any combination of (a) valid lower-cased MIME"]
    #[doc = " types (e.g. \"text/*\" or \"image/*\"), (b) individual file extensions (e.g."]
    #[doc = " \".txt\" or \".png\"), or (c) combined description and file extension delimited"]
    #[doc = " using \"|\" and \";\" (e.g. \"Image Types|.png;.gif;.jpg\")."]
    #[doc = " |selected_accept_filter| is the 0-based index of the filter that will be"]
    #[doc = " selected by default. |callback| will be executed after the dialog is"]
    #[doc = " dismissed or immediately if another dialog is already pending. The dialog"]
    #[doc = " will be initiated asynchronously on the UI thread."]
    #[doc = ""]
    pub run_file_dialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            mode: cef_file_dialog_mode_t,
            title: *const cef_string_t,
            default_file_path: *const cef_string_t,
            accept_filters: cef_string_list_t,
            selected_accept_filter: ::std::os::raw::c_int,
            callback: *mut _cef_run_file_dialog_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Download the file at |url| using cef_download_handler_t."]
    #[doc = ""]
    pub start_download: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Download |image_url| and execute |callback| on completion with the images"]
    #[doc = " received from the renderer. If |is_favicon| is true (1) then cookies are"]
    #[doc = " not sent and not accepted during download. Images with density independent"]
    #[doc = " pixel (DIP) sizes larger than |max_image_size| are filtered out from the"]
    #[doc = " image results. Versions of the image at different scale factors may be"]
    #[doc = " downloaded up to the maximum scale factor supported by the system. If there"]
    #[doc = " are no image results <= |max_image_size| then the smallest image is resized"]
    #[doc = " to |max_image_size| and is the only result. A |max_image_size| of 0 means"]
    #[doc = " unlimited. If |bypass_cache| is true (1) then |image_url| is requested from"]
    #[doc = " the server even if it is present in the browser cache."]
    #[doc = ""]
    pub download_image: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            image_url: *const cef_string_t,
            is_favicon: ::std::os::raw::c_int,
            max_image_size: uint32,
            bypass_cache: ::std::os::raw::c_int,
            callback: *mut _cef_download_image_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Print the current browser contents."]
    #[doc = ""]
    pub print: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Print the current browser contents to the PDF file specified by |path| and"]
    #[doc = " execute |callback| on completion. The caller is responsible for deleting"]
    #[doc = " |path| when done. For PDF printing to work on Linux you must implement the"]
    #[doc = " cef_print_handler_t::GetPdfPaperSize function."]
    #[doc = ""]
    pub print_to_pdf: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            path: *const cef_string_t,
            settings: *const _cef_pdf_print_settings_t,
            callback: *mut _cef_pdf_print_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Search for |searchText|. |identifier| must be a unique ID and these IDs"]
    #[doc = " must strictly increase so that newer requests always have greater IDs than"]
    #[doc = " older requests. If |identifier| is zero or less than the previous ID value"]
    #[doc = " then it will be automatically assigned a new valid ID. |forward| indicates"]
    #[doc = " whether to search forward or backward within the page. |matchCase|"]
    #[doc = " indicates whether the search should be case-sensitive. |findNext| indicates"]
    #[doc = " whether this is the first request or a follow-up. The cef_find_handler_t"]
    #[doc = " instance, if any, returned via cef_client_t::GetFindHandler will be called"]
    #[doc = " to report find results."]
    #[doc = ""]
    pub find: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            identifier: ::std::os::raw::c_int,
            searchText: *const cef_string_t,
            forward: ::std::os::raw::c_int,
            matchCase: ::std::os::raw::c_int,
            findNext: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel all searches that are currently going on."]
    #[doc = ""]
    pub stop_finding: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            clearSelection: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Open developer tools (DevTools) in its own browser. The DevTools browser"]
    #[doc = " will remain associated with this browser. If the DevTools browser is"]
    #[doc = " already open then it will be focused, in which case the |windowInfo|,"]
    #[doc = " |client| and |settings| parameters will be ignored. If |inspect_element_at|"]
    #[doc = " is non-NULL then the element at the specified (x,y) location will be"]
    #[doc = " inspected. The |windowInfo| parameter will be ignored if this browser is"]
    #[doc = " wrapped in a cef_browser_view_t."]
    #[doc = ""]
    pub show_dev_tools: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            windowInfo: *const _cef_window_info_t,
            client: *mut _cef_client_t,
            settings: *const _cef_browser_settings_t,
            inspect_element_at: *const cef_point_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Explicitly close the associated DevTools browser, if any."]
    #[doc = ""]
    pub close_dev_tools:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Returns true (1) if this browser currently has an associated DevTools"]
    #[doc = " browser. Must be called on the browser process UI thread."]
    #[doc = ""]
    pub has_dev_tools: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Retrieve a snapshot of current navigation entries as values sent to the"]
    #[doc = " specified visitor. If |current_only| is true (1) only the current"]
    #[doc = " navigation entry will be sent, otherwise all navigation entries will be"]
    #[doc = " sent."]
    #[doc = ""]
    pub get_navigation_entries: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            visitor: *mut _cef_navigation_entry_visitor_t,
            current_only: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Set whether mouse cursor change is disabled."]
    #[doc = ""]
    pub set_mouse_cursor_change_disabled: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, disabled: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if mouse cursor change is disabled."]
    #[doc = ""]
    pub is_mouse_cursor_change_disabled: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " If a misspelled word is currently selected in an editable node calling this"]
    #[doc = " function will replace it with the specified |word|."]
    #[doc = ""]
    pub replace_misspelling: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, word: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Add the specified |word| to the spelling dictionary."]
    #[doc = ""]
    pub add_word_to_dictionary: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, word: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if window rendering is disabled."]
    #[doc = ""]
    pub is_window_rendering_disabled: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Notify the browser that the widget has been resized. The browser will first"]
    #[doc = " call cef_render_handler_t::GetViewRect to get the new size and then call"]
    #[doc = " cef_render_handler_t::OnPaint asynchronously with the updated regions. This"]
    #[doc = " function is only used when window rendering is disabled."]
    #[doc = ""]
    pub was_resized: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Notify the browser that it has been hidden or shown. Layouting and"]
    #[doc = " cef_render_handler_t::OnPaint notification will stop when the browser is"]
    #[doc = " hidden. This function is only used when window rendering is disabled."]
    #[doc = ""]
    pub was_hidden: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, hidden: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Send a notification to the browser that the screen info has changed. The"]
    #[doc = " browser will then call cef_render_handler_t::GetScreenInfo to update the"]
    #[doc = " screen information with the new values. This simulates moving the webview"]
    #[doc = " window from one display to another, or changing the properties of the"]
    #[doc = " current display. This function is only used when window rendering is"]
    #[doc = " disabled."]
    #[doc = ""]
    pub notify_screen_info_changed:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Invalidate the view. The browser will call cef_render_handler_t::OnPaint"]
    #[doc = " asynchronously. This function is only used when window rendering is"]
    #[doc = " disabled."]
    #[doc = ""]
    pub invalidate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, type_: cef_paint_element_type_t),
    >,
    #[doc = ""]
    #[doc = " Send a key event to the browser."]
    #[doc = ""]
    pub send_key_event: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, event: *const _cef_key_event_t),
    >,
    #[doc = ""]
    #[doc = " Send a mouse click event to the browser. The |x| and |y| coordinates are"]
    #[doc = " relative to the upper-left corner of the view."]
    #[doc = ""]
    pub send_mouse_click_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const _cef_mouse_event_t,
            type_: cef_mouse_button_type_t,
            mouseUp: ::std::os::raw::c_int,
            clickCount: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Send a mouse move event to the browser. The |x| and |y| coordinates are"]
    #[doc = " relative to the upper-left corner of the view."]
    #[doc = ""]
    pub send_mouse_move_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const _cef_mouse_event_t,
            mouseLeave: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Send a mouse wheel event to the browser. The |x| and |y| coordinates are"]
    #[doc = " relative to the upper-left corner of the view. The |deltaX| and |deltaY|"]
    #[doc = " values represent the movement delta in the X and Y directions respectively."]
    #[doc = " In order to scroll inside select popups with window rendering disabled"]
    #[doc = " cef_render_handler_t::GetScreenPoint should be implemented properly."]
    #[doc = ""]
    pub send_mouse_wheel_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const _cef_mouse_event_t,
            deltaX: ::std::os::raw::c_int,
            deltaY: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Send a focus event to the browser."]
    #[doc = ""]
    pub send_focus_event: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, setFocus: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Send a capture lost event to the browser."]
    #[doc = ""]
    pub send_capture_lost_event:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Notify the browser that the window hosting it is about to be moved or"]
    #[doc = " resized. This function is only used on Windows and Linux."]
    #[doc = ""]
    pub notify_move_or_resize_started:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Returns the maximum rate in frames per second (fps) that"]
    #[doc = " cef_render_handler_t:: OnPaint will be called for a windowless browser. The"]
    #[doc = " actual fps may be lower if the browser cannot generate frames at the"]
    #[doc = " requested rate. The minimum value is 1 and the maximum value is 60 (default"]
    #[doc = " 30). This function can only be called on the UI thread."]
    #[doc = ""]
    pub get_windowless_frame_rate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the maximum rate in frames per second (fps) that cef_render_handler_t::"]
    #[doc = " OnPaint will be called for a windowless browser. The actual fps may be"]
    #[doc = " lower if the browser cannot generate frames at the requested rate. The"]
    #[doc = " minimum value is 1 and the maximum value is 60 (default 30). Can also be"]
    #[doc = " set at browser creation via cef_browser_tSettings.windowless_frame_rate."]
    #[doc = ""]
    pub set_windowless_frame_rate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, frame_rate: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Begins a new composition or updates the existing composition. Blink has a"]
    #[doc = " special node (a composition node) that allows the input function to change"]
    #[doc = " text without affecting other DOM nodes. |text| is the optional text that"]
    #[doc = " will be inserted into the composition node. |underlines| is an optional set"]
    #[doc = " of ranges that will be underlined in the resulting text."]
    #[doc = " |replacement_range| is an optional range of the existing text that will be"]
    #[doc = " replaced. |selection_range| is an optional range of the resulting text that"]
    #[doc = " will be selected after insertion or replacement. The |replacement_range|"]
    #[doc = " value is only used on OS X."]
    #[doc = ""]
    #[doc = " This function may be called multiple times as the composition changes. When"]
    #[doc = " the client is done making changes the composition should either be canceled"]
    #[doc = " or completed. To cancel the composition call ImeCancelComposition. To"]
    #[doc = " complete the composition call either ImeCommitText or"]
    #[doc = " ImeFinishComposingText. Completion is usually signaled when:"]
    #[doc = "   A. The client receives a WM_IME_COMPOSITION message with a GCS_RESULTSTR"]
    #[doc = "      flag (on Windows), or;"]
    #[doc = "   B. The client receives a \"commit\" signal of GtkIMContext (on Linux), or;"]
    #[doc = "   C. insertText of NSTextInput is called (on Mac)."]
    #[doc = ""]
    #[doc = " This function is only used when window rendering is disabled."]
    #[doc = ""]
    pub ime_set_composition: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            text: *const cef_string_t,
            underlinesCount: usize,
            underlines: *const cef_composition_underline_t,
            replacement_range: *const cef_range_t,
            selection_range: *const cef_range_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Completes the existing composition by optionally inserting the specified"]
    #[doc = " |text| into the composition node. |replacement_range| is an optional range"]
    #[doc = " of the existing text that will be replaced. |relative_cursor_pos| is where"]
    #[doc = " the cursor will be positioned relative to the current cursor position. See"]
    #[doc = " comments on ImeSetComposition for usage. The |replacement_range| and"]
    #[doc = " |relative_cursor_pos| values are only used on OS X. This function is only"]
    #[doc = " used when window rendering is disabled."]
    #[doc = ""]
    pub ime_commit_text: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            text: *const cef_string_t,
            replacement_range: *const cef_range_t,
            relative_cursor_pos: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Completes the existing composition by applying the current composition node"]
    #[doc = " contents. If |keep_selection| is false (0) the current selection, if any,"]
    #[doc = " will be discarded. See comments on ImeSetComposition for usage. This"]
    #[doc = " function is only used when window rendering is disabled."]
    #[doc = ""]
    pub ime_finish_composing_text: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            keep_selection: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancels the existing composition and discards the composition node contents"]
    #[doc = " without applying them. See comments on ImeSetComposition for usage. This"]
    #[doc = " function is only used when window rendering is disabled."]
    #[doc = ""]
    pub ime_cancel_composition:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Call this function when the user drags the mouse into the web view (before"]
    #[doc = " calling DragTargetDragOver/DragTargetLeave/DragTargetDrop). |drag_data|"]
    #[doc = " should not contain file contents as this type of data is not allowed to be"]
    #[doc = " dragged into the web view. File contents can be removed using"]
    #[doc = " cef_drag_data_t::ResetFileContents (for example, if |drag_data| comes from"]
    #[doc = " cef_render_handler_t::StartDragging). This function is only used when"]
    #[doc = " window rendering is disabled."]
    #[doc = ""]
    pub drag_target_drag_enter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            drag_data: *mut _cef_drag_data_t,
            event: *const _cef_mouse_event_t,
            allowed_ops: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Call this function each time the mouse is moved across the web view during"]
    #[doc = " a drag operation (after calling DragTargetDragEnter and before calling"]
    #[doc = " DragTargetDragLeave/DragTargetDrop). This function is only used when window"]
    #[doc = " rendering is disabled."]
    #[doc = ""]
    pub drag_target_drag_over: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const _cef_mouse_event_t,
            allowed_ops: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Call this function when the user drags the mouse out of the web view (after"]
    #[doc = " calling DragTargetDragEnter). This function is only used when window"]
    #[doc = " rendering is disabled."]
    #[doc = ""]
    pub drag_target_drag_leave:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Call this function when the user completes the drag operation by dropping"]
    #[doc = " the object onto the web view (after calling DragTargetDragEnter). The"]
    #[doc = " object being dropped is |drag_data|, given as an argument to the previous"]
    #[doc = " DragTargetDragEnter call. This function is only used when window rendering"]
    #[doc = " is disabled."]
    #[doc = ""]
    pub drag_target_drop: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, event: *const _cef_mouse_event_t),
    >,
    #[doc = ""]
    #[doc = " Call this function when the drag operation started by a"]
    #[doc = " cef_render_handler_t::StartDragging call has ended either in a drop or by"]
    #[doc = " being cancelled. |x| and |y| are mouse coordinates relative to the upper-"]
    #[doc = " left corner of the view. If the web view is both the drag source and the"]
    #[doc = " drag target then all DragTarget* functions should be called before"]
    #[doc = " DragSource* mthods. This function is only used when window rendering is"]
    #[doc = " disabled."]
    #[doc = ""]
    pub drag_source_ended_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            op: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Call this function when the drag operation started by a"]
    #[doc = " cef_render_handler_t::StartDragging call has completed. This function may"]
    #[doc = " be called immediately without first calling DragSourceEndedAt to cancel a"]
    #[doc = " drag operation. If the web view is both the drag source and the drag target"]
    #[doc = " then all DragTarget* functions should be called before DragSource* mthods."]
    #[doc = " This function is only used when window rendering is disabled."]
    #[doc = ""]
    pub drag_source_system_drag_ended:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Returns the current visible navigation entry for this browser. This"]
    #[doc = " function can only be called on the UI thread."]
    #[doc = ""]
    pub get_visible_navigation_entry: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_navigation_entry_t,
    >,
    #[doc = ""]
    #[doc = " Set accessibility state for all frames. |accessibility_state| may be"]
    #[doc = " default, enabled or disabled. If |accessibility_state| is STATE_DEFAULT"]
    #[doc = " then accessibility will be disabled by default and the state may be further"]
    #[doc = " controlled with the \"force-renderer-accessibility\" and \"disable-renderer-"]
    #[doc = " accessibility\" command-line switches. If |accessibility_state| is"]
    #[doc = " STATE_ENABLED then accessibility will be enabled. If |accessibility_state|"]
    #[doc = " is STATE_DISABLED then accessibility will be completely disabled."]
    #[doc = ""]
    #[doc = " For windowed browsers accessibility will be enabled in Complete mode (which"]
    #[doc = " corresponds to kAccessibilityModeComplete in Chromium). In this mode all"]
    #[doc = " platform accessibility objects will be created and managed by Chromium's"]
    #[doc = " internal implementation. The client needs only to detect the screen reader"]
    #[doc = " and call this function appropriately. For example, on macOS the client can"]
    #[doc = " handle the @\"AXEnhancedUserStructure\" accessibility attribute to detect"]
    #[doc = " VoiceOver state changes and on Windows the client can handle WM_GETOBJECT"]
    #[doc = " with OBJID_CLIENT to detect accessibility readers."]
    #[doc = ""]
    #[doc = " For windowless browsers accessibility will be enabled in TreeOnly mode"]
    #[doc = " (which corresponds to kAccessibilityModeWebContentsOnly in Chromium). In"]
    #[doc = " this mode renderer accessibility is enabled, the full tree is computed, and"]
    #[doc = " events are passed to CefAccessibiltyHandler, but platform accessibility"]
    #[doc = " objects are not created. The client may implement platform accessibility"]
    #[doc = " objects using CefAccessibiltyHandler callbacks if desired."]
    #[doc = ""]
    pub set_accessibility_state: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, accessibility_state: cef_state_t),
    >,
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new browser window using the window parameters specified by"]
    #[doc = " |windowInfo|. All values will be copied internally and the actual window will"]
    #[doc = " be created on the UI thread. If |request_context| is NULL the global request"]
    #[doc = " context will be used. This function can be called on any browser process"]
    #[doc = " thread and will not block."]
    #[doc = ""]
    pub fn cef_browser_host_create_browser(
        windowInfo: *const cef_window_info_t,
        client: *mut _cef_client_t,
        url: *const cef_string_t,
        settings: *const _cef_browser_settings_t,
        request_context: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new browser window using the window parameters specified by"]
    #[doc = " |windowInfo|. If |request_context| is NULL the global request context will be"]
    #[doc = " used. This function can only be called on the browser process UI thread."]
    #[doc = ""]
    pub fn cef_browser_host_create_browser_sync(
        windowInfo: *const cef_window_info_t,
        client: *mut _cef_client_t,
        url: *const cef_string_t,
        settings: *const _cef_browser_settings_t,
        request_context: *mut _cef_request_context_t,
    ) -> *mut cef_browser_t;
}
#[doc = ""]
#[doc = " Structure representing print settings."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_settings_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> *mut _cef_print_settings_t,
    >,
    #[doc = ""]
    #[doc = " Set the page orientation."]
    #[doc = ""]
    pub set_orientation: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, landscape: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the orientation is landscape."]
    #[doc = ""]
    pub is_landscape: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the printer printable area in device units. Some platforms already"]
    #[doc = " provide flipped area. Set |landscape_needs_flip| to false (0) on those"]
    #[doc = " platforms to avoid double flipping."]
    #[doc = ""]
    pub set_printer_printable_area: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            physical_size_device_units: *const cef_size_t,
            printable_area_device_units: *const cef_rect_t,
            landscape_needs_flip: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Set the device name."]
    #[doc = ""]
    pub set_device_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, name: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the device name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_device_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the DPI (dots per inch)."]
    #[doc = ""]
    pub set_dpi: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, dpi: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Get the DPI (dots per inch)."]
    #[doc = ""]
    pub get_dpi: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the page ranges."]
    #[doc = ""]
    pub set_page_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            rangesCount: usize,
            ranges: *const cef_range_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns the number of page ranges that currently exist."]
    #[doc = ""]
    pub get_page_ranges_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> usize>,
    #[doc = ""]
    #[doc = " Retrieve the page ranges."]
    #[doc = ""]
    pub get_page_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            rangesCount: *mut usize,
            ranges: *mut cef_range_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Set whether only the selection will be printed."]
    #[doc = ""]
    pub set_selection_only: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            selection_only: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if only the selection will be printed."]
    #[doc = ""]
    pub is_selection_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set whether pages will be collated."]
    #[doc = ""]
    pub set_collate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, collate: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if pages will be collated."]
    #[doc = ""]
    pub will_collate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the color model."]
    #[doc = ""]
    pub set_color_model: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, model: cef_color_model_t),
    >,
    #[doc = ""]
    #[doc = " Get the color model."]
    #[doc = ""]
    pub get_color_model: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_color_model_t,
    >,
    #[doc = ""]
    #[doc = " Set the number of copies."]
    #[doc = ""]
    pub set_copies: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, copies: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Get the number of copies."]
    #[doc = ""]
    pub get_copies: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the duplex mode."]
    #[doc = ""]
    pub set_duplex_mode: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, mode: cef_duplex_mode_t),
    >,
    #[doc = ""]
    #[doc = " Get the duplex mode."]
    #[doc = ""]
    pub get_duplex_mode: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_duplex_mode_t,
    >,
}
#[doc = ""]
#[doc = " Structure representing print settings."]
#[doc = ""]
pub type cef_print_settings_t = _cef_print_settings_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_print_settings_t object."]
    #[doc = ""]
    pub fn cef_print_settings_create() -> *mut cef_print_settings_t;
}
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of print dialog requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_dialog_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue printing with the specified |settings|."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_dialog_callback_t,
            settings: *mut _cef_print_settings_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel the printing."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_dialog_callback_t)>,
}
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of print job requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_job_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Indicate completion of the print job."]
    #[doc = ""]
    pub cont: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_job_callback_t)>,
}
#[doc = ""]
#[doc = " Implement this structure to handle printing on Linux. Each browser will have"]
#[doc = " only one print job in progress at a time. The functions of this structure"]
#[doc = " will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when printing has started for the specified |browser|. This function"]
    #[doc = " will be called before the other OnPrint*() functions and irrespective of"]
    #[doc = " how printing was initiated (e.g. cef_browser_host_t::print(), JavaScript"]
    #[doc = " window.print() or PDF extension print button)."]
    #[doc = ""]
    pub on_print_start: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Synchronize |settings| with client state. If |get_defaults| is true (1)"]
    #[doc = " then populate |settings| with the default print settings. Do not keep a"]
    #[doc = " reference to |settings| outside of this callback."]
    #[doc = ""]
    pub on_print_settings: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            settings: *mut _cef_print_settings_t,
            get_defaults: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Show the print dialog. Execute |callback| once the dialog is dismissed."]
    #[doc = " Return true (1) if the dialog will be displayed or false (0) to cancel the"]
    #[doc = " printing immediately."]
    #[doc = ""]
    pub on_print_dialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            has_selection: ::std::os::raw::c_int,
            callback: *mut _cef_print_dialog_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Send the print job to the printer. Execute |callback| once the job is"]
    #[doc = " completed. Return true (1) if the job will proceed or false (0) to cancel"]
    #[doc = " the job immediately."]
    #[doc = ""]
    pub on_print_job: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            document_name: *const cef_string_t,
            pdf_file_path: *const cef_string_t,
            callback: *mut _cef_print_job_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Reset client state related to printing."]
    #[doc = ""]
    pub on_print_reset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Return the PDF paper size in device units. Used in combination with"]
    #[doc = " cef_browser_host_t::print_to_pdf()."]
    #[doc = ""]
    pub get_pdf_paper_size: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            device_units_per_inch: ::std::os::raw::c_int,
        ) -> cef_size_t,
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle menu model events. The functions of this"]
#[doc = " structure will be called on the browser process UI thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_menu_model_delegate_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Perform the action associated with the specified |command_id| and optional"]
    #[doc = " |event_flags|."]
    #[doc = ""]
    pub execute_command: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            event_flags: cef_event_flags_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the user moves the mouse outside the menu and over the owning"]
    #[doc = " window."]
    #[doc = ""]
    pub mouse_outside_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            screen_point: *const cef_point_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on unhandled open submenu keyboard commands. |is_rtl| will be true"]
    #[doc = " (1) if the menu is displaying a right-to-left language."]
    #[doc = ""]
    pub unhandled_open_submenu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            is_rtl: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on unhandled close submenu keyboard commands. |is_rtl| will be true"]
    #[doc = " (1) if the menu is displaying a right-to-left language."]
    #[doc = ""]
    pub unhandled_close_submenu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            is_rtl: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " The menu is about to show."]
    #[doc = ""]
    pub menu_will_show: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = ""]
    #[doc = " The menu has closed."]
    #[doc = ""]
    pub menu_closed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Optionally modify a menu item label. Return true (1) if |label| was"]
    #[doc = " modified."]
    #[doc = ""]
    pub format_label: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            label: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Supports creation and modification of menus. See cef_menu_id_t for the"]
#[doc = " command ids that have default implementations. All user-defined command ids"]
#[doc = " should be between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of"]
#[doc = " this structure can only be accessed on the browser process the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_menu_model_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this menu is a submenu."]
    #[doc = ""]
    pub is_sub_menu: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Clears the menu. Returns true (1) on success."]
    #[doc = ""]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of items in this menu."]
    #[doc = ""]
    pub get_count: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a separator to the menu. Returns true (1) on success."]
    #[doc = ""]
    pub add_separator: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add an item to the menu. Returns true (1) on success."]
    #[doc = ""]
    pub add_item: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a check item to the menu. Returns true (1) on success."]
    #[doc = ""]
    pub add_check_item: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a radio item to the menu. Only a single item with the specified"]
    #[doc = " |group_id| can be checked at a time. Returns true (1) on success."]
    #[doc = ""]
    pub add_radio_item: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
            group_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a sub-menu to the menu. The new sub-menu is returned."]
    #[doc = ""]
    pub add_sub_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = ""]
    #[doc = " Insert a separator in the menu at the specified |index|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub insert_separator_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Insert an item in the menu at the specified |index|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub insert_item_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Insert a check item in the menu at the specified |index|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub insert_check_item_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Insert a radio item in the menu at the specified |index|. Only a single"]
    #[doc = " item with the specified |group_id| can be checked at a time. Returns true"]
    #[doc = " (1) on success."]
    #[doc = ""]
    pub insert_radio_item_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
            group_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Insert a sub-menu in the menu at the specified |index|. The new sub-menu is"]
    #[doc = " returned."]
    #[doc = ""]
    pub insert_sub_menu_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = ""]
    #[doc = " Removes the item with the specified |command_id|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Removes the item at the specified |index|. Returns true (1) on success."]
    #[doc = ""]
    pub remove_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index associated with the specified |command_id| or -1 if not"]
    #[doc = " found due to the command id not existing in the menu."]
    #[doc = ""]
    pub get_index_of: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the command id at the specified |index| or -1 if not found due to"]
    #[doc = " invalid range or the index being a separator."]
    #[doc = ""]
    pub get_command_id_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the command id at the specified |index|. Returns true (1) on success."]
    #[doc = ""]
    pub set_command_id_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the label for the specified |command_id| or NULL if not found."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_label: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the label at the specified |index| or NULL if not found due to"]
    #[doc = " invalid range or the index being a separator."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_label_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Sets the label for the specified |command_id|. Returns true (1) on success."]
    #[doc = ""]
    pub set_label: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the label at the specified |index|. Returns true (1) on success."]
    #[doc = ""]
    pub set_label_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the item type for the specified |command_id|."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> cef_menu_item_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the item type at the specified |index|."]
    #[doc = ""]
    pub get_type_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> cef_menu_item_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the group id for the specified |command_id| or -1 if invalid."]
    #[doc = ""]
    pub get_group_id: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the group id at the specified |index| or -1 if invalid."]
    #[doc = ""]
    pub get_group_id_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the group id for the specified |command_id|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_group_id: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            group_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the group id at the specified |index|. Returns true (1) on success."]
    #[doc = ""]
    pub set_group_id_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            group_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the submenu for the specified |command_id| or NULL if invalid."]
    #[doc = ""]
    pub get_sub_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = ""]
    #[doc = " Returns the submenu at the specified |index| or NULL if invalid."]
    #[doc = ""]
    pub get_sub_menu_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |command_id| is visible."]
    #[doc = ""]
    pub is_visible: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |index| is visible."]
    #[doc = ""]
    pub is_visible_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Change the visibility of the specified |command_id|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_visible: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            visible: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Change the visibility at the specified |index|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_visible_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            visible: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |command_id| is enabled."]
    #[doc = ""]
    pub is_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |index| is enabled."]
    #[doc = ""]
    pub is_enabled_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Change the enabled status of the specified |command_id|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub set_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            enabled: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Change the enabled status at the specified |index|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_enabled_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            enabled: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |command_id| is checked. Only applies to"]
    #[doc = " check and radio items."]
    #[doc = ""]
    pub is_checked: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |index| is checked. Only applies to check"]
    #[doc = " and radio items."]
    #[doc = ""]
    pub is_checked_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Check the specified |command_id|. Only applies to check and radio items."]
    #[doc = " Returns true (1) on success."]
    #[doc = ""]
    pub set_checked: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            checked: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Check the specified |index|. Only applies to check and radio items. Returns"]
    #[doc = " true (1) on success."]
    #[doc = ""]
    pub set_checked_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            checked: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |command_id| has a keyboard accelerator"]
    #[doc = " assigned."]
    #[doc = ""]
    pub has_accelerator: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |index| has a keyboard accelerator"]
    #[doc = " assigned."]
    #[doc = ""]
    pub has_accelerator_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the keyboard accelerator for the specified |command_id|. |key_code| can"]
    #[doc = " be any virtual key or character value. Returns true (1) on success."]
    #[doc = ""]
    pub set_accelerator: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            key_code: ::std::os::raw::c_int,
            shift_pressed: ::std::os::raw::c_int,
            ctrl_pressed: ::std::os::raw::c_int,
            alt_pressed: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the keyboard accelerator at the specified |index|. |key_code| can be"]
    #[doc = " any virtual key or character value. Returns true (1) on success."]
    #[doc = ""]
    pub set_accelerator_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            key_code: ::std::os::raw::c_int,
            shift_pressed: ::std::os::raw::c_int,
            ctrl_pressed: ::std::os::raw::c_int,
            alt_pressed: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Remove the keyboard accelerator for the specified |command_id|. Returns"]
    #[doc = " true (1) on success."]
    #[doc = ""]
    pub remove_accelerator: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Remove the keyboard accelerator at the specified |index|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub remove_accelerator_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Retrieves the keyboard accelerator for the specified |command_id|. Returns"]
    #[doc = " true (1) on success."]
    #[doc = ""]
    pub get_accelerator: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            key_code: *mut ::std::os::raw::c_int,
            shift_pressed: *mut ::std::os::raw::c_int,
            ctrl_pressed: *mut ::std::os::raw::c_int,
            alt_pressed: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Retrieves the keyboard accelerator for the specified |index|. Returns true"]
    #[doc = " (1) on success."]
    #[doc = ""]
    pub get_accelerator_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            key_code: *mut ::std::os::raw::c_int,
            shift_pressed: *mut ::std::os::raw::c_int,
            ctrl_pressed: *mut ::std::os::raw::c_int,
            alt_pressed: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the explicit color for |command_id| and |color_type| to |color|."]
    #[doc = " Specify a |color| value of 0 to remove the explicit color. If no explicit"]
    #[doc = " color or default color is set for |color_type| then the system color will"]
    #[doc = " be used. Returns true (1) on success."]
    #[doc = ""]
    pub set_color: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            color_type: cef_menu_color_type_t,
            color: cef_color_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the explicit color for |command_id| and |index| to |color|. Specify a"]
    #[doc = " |color| value of 0 to remove the explicit color. Specify an |index| value"]
    #[doc = " of -1 to set the default color for items that do not have an explicit color"]
    #[doc = " set. If no explicit color or default color is set for |color_type| then the"]
    #[doc = " system color will be used. Returns true (1) on success."]
    #[doc = ""]
    pub set_color_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            color_type: cef_menu_color_type_t,
            color: cef_color_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns in |color| the color that was explicitly set for |command_id| and"]
    #[doc = " |color_type|. If a color was not set then 0 will be returned in |color|."]
    #[doc = " Returns true (1) on success."]
    #[doc = ""]
    pub get_color: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            color_type: cef_menu_color_type_t,
            color: *mut cef_color_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns in |color| the color that was explicitly set for |command_id| and"]
    #[doc = " |color_type|. Specify an |index| value of -1 to return the default color in"]
    #[doc = " |color|. If a color was not set then 0 will be returned in |color|. Returns"]
    #[doc = " true (1) on success."]
    #[doc = ""]
    pub get_color_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            color_type: cef_menu_color_type_t,
            color: *mut cef_color_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the font list for the specified |command_id|. If |font_list| is NULL"]
    #[doc = " the system font will be used. Returns true (1) on success. The format is"]
    #[doc = " \"<FONT_FAMILY_LIST>,[STYLES] <SIZE>\", where: - FONT_FAMILY_LIST is a comma-"]
    #[doc = " separated list of font family names, - STYLES is an optional space-"]
    #[doc = " separated list of style names (case-sensitive"]
    #[doc = "   \"Bold\" and \"Italic\" are supported), and"]
    #[doc = " - SIZE is an integer font size in pixels with the suffix \"px\"."]
    #[doc = ""]
    #[doc = " Here are examples of valid font description strings: - \"Arial, Helvetica,"]
    #[doc = " Bold Italic 14px\" - \"Arial, 14px\""]
    #[doc = ""]
    pub set_font_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            font_list: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the font list for the specified |index|. Specify an |index| value of"]
    #[doc = " -1 to set the default font. If |font_list| is NULL the system font will be"]
    #[doc = " used. Returns true (1) on success. The format is"]
    #[doc = " \"<FONT_FAMILY_LIST>,[STYLES] <SIZE>\", where: - FONT_FAMILY_LIST is a comma-"]
    #[doc = " separated list of font family names, - STYLES is an optional space-"]
    #[doc = " separated list of style names (case-sensitive"]
    #[doc = "   \"Bold\" and \"Italic\" are supported), and"]
    #[doc = " - SIZE is an integer font size in pixels with the suffix \"px\"."]
    #[doc = ""]
    #[doc = " Here are examples of valid font description strings: - \"Arial, Helvetica,"]
    #[doc = " Bold Italic 14px\" - \"Arial, 14px\""]
    #[doc = ""]
    pub set_font_list_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            font_list: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Supports creation and modification of menus. See cef_menu_id_t for the"]
#[doc = " command ids that have default implementations. All user-defined command ids"]
#[doc = " should be between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of"]
#[doc = " this structure can only be accessed on the browser process the UI thread."]
#[doc = ""]
pub type cef_menu_model_t = _cef_menu_model_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new MenuModel with the specified |delegate|."]
    #[doc = ""]
    pub fn cef_menu_model_create(
        delegate: *mut _cef_menu_model_delegate_t,
    ) -> *mut cef_menu_model_t;
}
#[doc = ""]
#[doc = " Callback structure used for continuation of custom context menu display."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_run_context_menu_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Complete context menu display by selecting the specified |command_id| and"]
    #[doc = " |event_flags|."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_run_context_menu_callback_t,
            command_id: ::std::os::raw::c_int,
            event_flags: cef_event_flags_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel context menu display."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_run_context_menu_callback_t)>,
}
#[doc = ""]
#[doc = " Implement this structure to handle context menu events. The functions of this"]
#[doc = " structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_context_menu_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called before a context menu is displayed. |params| provides information"]
    #[doc = " about the context menu state. |model| initially contains the default"]
    #[doc = " context menu. The |model| can be cleared to show no context menu or"]
    #[doc = " modified to show a custom menu. Do not keep references to |params| or"]
    #[doc = " |model| outside of this callback."]
    #[doc = ""]
    pub on_before_context_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called to allow custom display of the context menu. |params| provides"]
    #[doc = " information about the context menu state. |model| contains the context menu"]
    #[doc = " model resulting from OnBeforeContextMenu. For custom display return true"]
    #[doc = " (1) and execute |callback| either synchronously or asynchronously with the"]
    #[doc = " selected command ID. For default display return false (0). Do not keep"]
    #[doc = " references to |params| or |model| outside of this callback."]
    #[doc = ""]
    pub run_context_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            model: *mut _cef_menu_model_t,
            callback: *mut _cef_run_context_menu_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to execute a command selected from the context menu. Return true (1)"]
    #[doc = " if the command was handled or false (0) for the default implementation. See"]
    #[doc = " cef_menu_id_t for the command ids that have default implementations. All"]
    #[doc = " user-defined command ids should be between MENU_ID_USER_FIRST and"]
    #[doc = " MENU_ID_USER_LAST. |params| will have the same values as what was passed to"]
    #[doc = " on_before_context_menu(). Do not keep a reference to |params| outside of"]
    #[doc = " this callback."]
    #[doc = ""]
    pub on_context_menu_command: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            command_id: ::std::os::raw::c_int,
            event_flags: cef_event_flags_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the context menu is dismissed irregardless of whether the menu"]
    #[doc = " was NULL or a command was selected."]
    #[doc = ""]
    pub on_context_menu_dismissed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Provides information about the context menu state. The ethods of this"]
#[doc = " structure can only be accessed on browser process the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_context_menu_params_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the X coordinate of the mouse where the context menu was invoked."]
    #[doc = " Coords are relative to the associated RenderView's origin."]
    #[doc = ""]
    pub get_xcoord: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the Y coordinate of the mouse where the context menu was invoked."]
    #[doc = " Coords are relative to the associated RenderView's origin."]
    #[doc = ""]
    pub get_ycoord: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns flags representing the type of node that the context menu was"]
    #[doc = " invoked on."]
    #[doc = ""]
    pub get_type_flags: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_type_flags_t,
    >,
    #[doc = ""]
    #[doc = " Returns the URL of the link, if any, that encloses the node that the"]
    #[doc = " context menu was invoked on."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_link_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the link URL, if any, to be used ONLY for \"copy link address\". We"]
    #[doc = " don't validate this field in the frontend process."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_unfiltered_link_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the source URL, if any, for the element that the context menu was"]
    #[doc = " invoked on. Example of elements with source URLs are img, audio, and video."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_source_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu was invoked on an image which has non-"]
    #[doc = " NULL contents."]
    #[doc = ""]
    pub has_image_contents: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the title text or the alt text if the context menu was invoked on"]
    #[doc = " an image."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_title_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the URL of the top level page that the context menu was invoked on."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_page_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the URL of the subframe that the context menu was invoked on."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_frame_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the character encoding of the subframe that the context menu was"]
    #[doc = " invoked on."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_frame_charset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the type of context node that the context menu was invoked on."]
    #[doc = ""]
    pub get_media_type: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_media_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns flags representing the actions supported by the media element, if"]
    #[doc = " any, that the context menu was invoked on."]
    #[doc = ""]
    pub get_media_state_flags: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_media_state_flags_t,
    >,
    #[doc = ""]
    #[doc = " Returns the text of the selection, if any, that the context menu was"]
    #[doc = " invoked on."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_selection_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the text of the misspelled word, if any, that the context menu was"]
    #[doc = " invoked on."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_misspelled_word: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if suggestions exist, false (0) otherwise. Fills in"]
    #[doc = " |suggestions| from the spell check service for the misspelled word if there"]
    #[doc = " is one."]
    #[doc = ""]
    pub get_dictionary_suggestions: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
            suggestions: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu was invoked on an editable node."]
    #[doc = ""]
    pub is_editable: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu was invoked on an editable node where"]
    #[doc = " spell-check is enabled."]
    #[doc = ""]
    pub is_spell_check_enabled: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns flags representing the actions supported by the editable node, if"]
    #[doc = " any, that the context menu was invoked on."]
    #[doc = ""]
    pub get_edit_state_flags: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_edit_state_flags_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu contains items specified by the"]
    #[doc = " renderer process (for example, plugin placeholder or pepper plugin menu"]
    #[doc = " items)."]
    #[doc = ""]
    pub is_custom_menu: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu was invoked from a pepper plugin."]
    #[doc = ""]
    pub is_pepper_menu: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to create and/or parse command line arguments. Arguments with"]
#[doc = " '--', '-' and, on Windows, '/' prefixes are considered switches. Switches"]
#[doc = " will always precede any arguments without switch prefixes. Switches can"]
#[doc = " optionally have a value specified using the '=' delimiter (e.g."]
#[doc = " \"-switch=value\"). An argument of \"--\" will terminate switch parsing with all"]
#[doc = " subsequent tokens, regardless of prefix, being interpreted as non-switch"]
#[doc = " arguments. Switch names are considered case-insensitive. This structure can"]
#[doc = " be used before cef_initialize() is called."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_command_line_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> *mut _cef_command_line_t,
    >,
    #[doc = ""]
    #[doc = " Initialize the command line with the specified |argc| and |argv| values."]
    #[doc = " The first argument must be the name of the program. This function is only"]
    #[doc = " supported on non-Windows platforms."]
    #[doc = ""]
    pub init_from_argv: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            argc: ::std::os::raw::c_int,
            argv: *const *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = ""]
    #[doc = " Initialize the command line with the string returned by calling"]
    #[doc = " GetCommandLineW(). This function is only supported on Windows."]
    #[doc = ""]
    pub init_from_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, command_line: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Reset the command-line switches and arguments but leave the program"]
    #[doc = " component unchanged."]
    #[doc = ""]
    pub reset: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_command_line_t)>,
    #[doc = ""]
    #[doc = " Retrieve the original command line string as a vector of strings. The argv"]
    #[doc = " array: { program, [(--|-|/)switch[=value]]*, [--], [argument]* }"]
    #[doc = ""]
    pub get_argv: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, argv: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Constructs and returns the represented command line string. Use this"]
    #[doc = " function cautiously because quoting behavior is unclear."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_command_line_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Get the program part of the command line string (the first item)."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_program: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the program part of the command line string (the first item)."]
    #[doc = ""]
    pub set_program: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, program: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the command line has switches."]
    #[doc = ""]
    pub has_switches: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the command line contains the given switch."]
    #[doc = ""]
    pub has_switch: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value associated with the given switch. If the switch has no"]
    #[doc = " value or isn't present this function returns the NULL string."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_switch_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the map of switch names and values. If a switch has no value an"]
    #[doc = " NULL string is returned."]
    #[doc = ""]
    pub get_switches: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, switches: cef_string_map_t),
    >,
    #[doc = ""]
    #[doc = " Add a switch to the end of the command line. If the switch has no value"]
    #[doc = " pass an NULL value string."]
    #[doc = ""]
    pub append_switch: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, name: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Add a switch with the specified value to the end of the command line."]
    #[doc = ""]
    pub append_switch_with_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
            value: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " True if there are remaining command line arguments."]
    #[doc = ""]
    pub has_arguments: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Get the remaining command line arguments."]
    #[doc = ""]
    pub get_arguments: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, arguments: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Add an argument to the end of the command line."]
    #[doc = ""]
    pub append_argument: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, argument: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Insert a command before the current command. Common for debuggers, like"]
    #[doc = " \"valgrind\" or \"gdb --args\"."]
    #[doc = ""]
    pub prepend_wrapper: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, wrapper: *const cef_string_t),
    >,
}
#[doc = ""]
#[doc = " Structure used to create and/or parse command line arguments. Arguments with"]
#[doc = " '--', '-' and, on Windows, '/' prefixes are considered switches. Switches"]
#[doc = " will always precede any arguments without switch prefixes. Switches can"]
#[doc = " optionally have a value specified using the '=' delimiter (e.g."]
#[doc = " \"-switch=value\"). An argument of \"--\" will terminate switch parsing with all"]
#[doc = " subsequent tokens, regardless of prefix, being interpreted as non-switch"]
#[doc = " arguments. Switch names are considered case-insensitive. This structure can"]
#[doc = " be used before cef_initialize() is called."]
#[doc = ""]
pub type cef_command_line_t = _cef_command_line_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_command_line_t instance."]
    #[doc = ""]
    pub fn cef_command_line_create() -> *mut cef_command_line_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns the singleton global cef_command_line_t object. The returned object"]
    #[doc = " will be read-only."]
    #[doc = ""]
    pub fn cef_command_line_get_global() -> *mut cef_command_line_t;
}
#[doc = ""]
#[doc = " Structure used to implement browser process callbacks. The functions of this"]
#[doc = " structure will be called on the browser process main thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_browser_process_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the browser process UI thread immediately after the CEF context"]
    #[doc = " has been initialized."]
    #[doc = ""]
    pub on_context_initialized:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_process_handler_t)>,
    #[doc = ""]
    #[doc = " Called before a child process is launched. Will be called on the browser"]
    #[doc = " process UI thread when launching a render process and on the browser"]
    #[doc = " process IO thread when launching a GPU or plugin process. Provides an"]
    #[doc = " opportunity to modify the child process command line. Do not keep a"]
    #[doc = " reference to |command_line| outside of this function."]
    #[doc = ""]
    pub on_before_child_process_launch: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_process_handler_t,
            command_line: *mut _cef_command_line_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the browser process IO thread after the main thread has been"]
    #[doc = " created for a new render process. Provides an opportunity to specify extra"]
    #[doc = " information that will be passed to"]
    #[doc = " cef_render_process_handler_t::on_render_thread_created() in the render"]
    #[doc = " process. Do not keep a reference to |extra_info| outside of this function."]
    #[doc = ""]
    pub on_render_process_thread_created: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_process_handler_t,
            extra_info: *mut _cef_list_value_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Return the handler for printing on Linux. If a print handler is not"]
    #[doc = " provided then printing will not be supported on the Linux platform."]
    #[doc = ""]
    pub get_print_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_process_handler_t,
        ) -> *mut _cef_print_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called from any thread when work has been scheduled for the browser process"]
    #[doc = " main (UI) thread. This callback is used in combination with CefSettings."]
    #[doc = " external_message_pump and cef_do_message_loop_work() in cases where the CEF"]
    #[doc = " message loop must be integrated into an existing application message loop"]
    #[doc = " (see additional comments and warnings on CefDoMessageLoopWork). This"]
    #[doc = " callback should schedule a cef_do_message_loop_work() call to happen on the"]
    #[doc = " main (UI) thread. |delay_ms| is the requested delay in milliseconds. If"]
    #[doc = " |delay_ms| is <= 0 then the call should happen reasonably soon. If"]
    #[doc = " |delay_ms| is > 0 then the call should be scheduled to happen after the"]
    #[doc = " specified delay and any currently pending scheduled call should be"]
    #[doc = " cancelled."]
    #[doc = ""]
    pub on_schedule_message_pump_work: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_process_handler_t, delay_ms: int64),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser load status. The"]
#[doc = " functions of this structure will be called on the browser process UI thread"]
#[doc = " or render process main thread (TID_RENDERER)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_load_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when the loading state has changed. This callback will be executed"]
    #[doc = " twice -- once when loading is initiated either programmatically or by user"]
    #[doc = " action, and once when loading is terminated due to completion, cancellation"]
    #[doc = " of failure. It will be called before any calls to OnLoadStart and after all"]
    #[doc = " calls to OnLoadError and/or OnLoadEnd."]
    #[doc = ""]
    pub on_loading_state_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            isLoading: ::std::os::raw::c_int,
            canGoBack: ::std::os::raw::c_int,
            canGoForward: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called after a navigation has been committed and before the browser begins"]
    #[doc = " loading contents in the frame. The |frame| value will never be NULL -- call"]
    #[doc = " the is_main() function to check if this frame is the main frame."]
    #[doc = " |transition_type| provides information about the source of the navigation"]
    #[doc = " and an accurate value is only available in the browser process. Multiple"]
    #[doc = " frames may be loading at the same time. Sub-frames may start or continue"]
    #[doc = " loading after the main frame load has ended. This function will not be"]
    #[doc = " called for same page navigations (fragments, history state, etc.) or for"]
    #[doc = " navigations that fail or are canceled before commit. For notification of"]
    #[doc = " overall browser load status use OnLoadingStateChange instead."]
    #[doc = ""]
    pub on_load_start: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            transition_type: cef_transition_type_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser is done loading a frame. The |frame| value will"]
    #[doc = " never be NULL -- call the is_main() function to check if this frame is the"]
    #[doc = " main frame. Multiple frames may be loading at the same time. Sub-frames may"]
    #[doc = " start or continue loading after the main frame load has ended. This"]
    #[doc = " function will not be called for same page navigations (fragments, history"]
    #[doc = " state, etc.) or for navigations that fail or are canceled before commit."]
    #[doc = " For notification of overall browser load status use OnLoadingStateChange"]
    #[doc = " instead."]
    #[doc = ""]
    pub on_load_end: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            httpStatusCode: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a navigation fails or is canceled. This function may be called"]
    #[doc = " by itself if before commit or in combination with OnLoadStart/OnLoadEnd if"]
    #[doc = " after commit. |errorCode| is the error code number, |errorText| is the"]
    #[doc = " error text and |failedUrl| is the URL that failed to load. See"]
    #[doc = " net\\base\\net_error_list.h for complete descriptions of the error codes."]
    #[doc = ""]
    pub on_load_error: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            errorCode: cef_errorcode_t,
            errorText: *const cef_string_t,
            failedUrl: *const cef_string_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Implement this structure for asynchronous task execution. If the task is"]
#[doc = " posted successfully and if the associated message loop is still running then"]
#[doc = " the execute() function will be called on the target thread. If the task fails"]
#[doc = " to post then the task object may be destroyed on the source thread instead of"]
#[doc = " the target thread. For this reason be cautious when performing work in the"]
#[doc = " task object destructor."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_task_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed on the target thread."]
    #[doc = ""]
    pub execute: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_task_t)>,
}
#[doc = ""]
#[doc = " Implement this structure for asynchronous task execution. If the task is"]
#[doc = " posted successfully and if the associated message loop is still running then"]
#[doc = " the execute() function will be called on the target thread. If the task fails"]
#[doc = " to post then the task object may be destroyed on the source thread instead of"]
#[doc = " the target thread. For this reason be cautious when performing work in the"]
#[doc = " task object destructor."]
#[doc = ""]
pub type cef_task_t = _cef_task_t;
#[doc = ""]
#[doc = " Structure that asynchronously executes tasks on the associated thread. It is"]
#[doc = " safe to call the functions of this structure on any thread."]
#[doc = ""]
#[doc = " CEF maintains multiple internal threads that are used for handling different"]
#[doc = " types of tasks in different processes. The cef_thread_id_t definitions in"]
#[doc = " cef_types.h list the common CEF threads. Task runners are also available for"]
#[doc = " other CEF threads as appropriate (for example, V8 WebWorker threads)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_task_runner_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same task runner as"]
    #[doc = " |that| object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            that: *mut _cef_task_runner_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this task runner belongs to the current thread."]
    #[doc = ""]
    pub belongs_to_current_thread: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_task_runner_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this task runner is for the specified CEF thread."]
    #[doc = ""]
    pub belongs_to_thread: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            threadId: cef_thread_id_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Post a task for execution on the thread associated with this task runner."]
    #[doc = " Execution will occur asynchronously."]
    #[doc = ""]
    pub post_task: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            task: *mut _cef_task_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Post a task for delayed execution on the thread associated with this task"]
    #[doc = " runner. Execution will occur asynchronously. Delayed tasks are not"]
    #[doc = " supported on V8 WebWorker threads and will be executed without the"]
    #[doc = " specified delay."]
    #[doc = ""]
    pub post_delayed_task: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            task: *mut _cef_task_t,
            delay_ms: int64,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure that asynchronously executes tasks on the associated thread. It is"]
#[doc = " safe to call the functions of this structure on any thread."]
#[doc = ""]
#[doc = " CEF maintains multiple internal threads that are used for handling different"]
#[doc = " types of tasks in different processes. The cef_thread_id_t definitions in"]
#[doc = " cef_types.h list the common CEF threads. Task runners are also available for"]
#[doc = " other CEF threads as appropriate (for example, V8 WebWorker threads)."]
#[doc = ""]
pub type cef_task_runner_t = _cef_task_runner_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the task runner for the current thread. Only CEF threads will have"]
    #[doc = " task runners. An NULL reference will be returned if this function is called"]
    #[doc = " on an invalid thread."]
    #[doc = ""]
    pub fn cef_task_runner_get_for_current_thread() -> *mut cef_task_runner_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns the task runner for the specified CEF thread."]
    #[doc = ""]
    pub fn cef_task_runner_get_for_thread(threadId: cef_thread_id_t) -> *mut cef_task_runner_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns true (1) if called on the specified thread. Equivalent to using"]
    #[doc = " cef_task_tRunner::GetForThread(threadId)->belongs_to_current_thread()."]
    #[doc = ""]
    pub fn cef_currently_on(threadId: cef_thread_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Post a task for execution on the specified thread. Equivalent to using"]
    #[doc = " cef_task_tRunner::GetForThread(threadId)->PostTask(task)."]
    #[doc = ""]
    pub fn cef_post_task(threadId: cef_thread_id_t, task: *mut cef_task_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Post a task for delayed execution on the specified thread. Equivalent to"]
    #[doc = " using cef_task_tRunner::GetForThread(threadId)->PostDelayedTask(task,"]
    #[doc = " delay_ms)."]
    #[doc = ""]
    pub fn cef_post_delayed_task(
        threadId: cef_thread_id_t,
        task: *mut cef_task_t,
        delay_ms: int64,
    ) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Structure representing a V8 context handle. V8 handles can only be accessed"]
#[doc = " from the thread on which they are created. Valid threads for creating a V8"]
#[doc = " handle include the render process main thread (TID_RENDERER) and WebWorker"]
#[doc = " threads. A task runner for posting tasks on the associated thread can be"]
#[doc = " retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8context_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the task runner associated with this context. V8 handles can only"]
    #[doc = " be accessed from the thread on which they are created. This function can be"]
    #[doc = " called on any render process thread."]
    #[doc = ""]
    pub get_task_runner: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_task_runner_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying handle is valid and it can be accessed"]
    #[doc = " on the current thread. Do not call any other functions if this function"]
    #[doc = " returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the browser for this context. This function will return an NULL"]
    #[doc = " reference for WebWorker contexts."]
    #[doc = ""]
    pub get_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_browser_t,
    >,
    #[doc = ""]
    #[doc = " Returns the frame for this context. This function will return an NULL"]
    #[doc = " reference for WebWorker contexts."]
    #[doc = ""]
    pub get_frame: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the global object for this context. The context must be entered"]
    #[doc = " before calling this function."]
    #[doc = ""]
    pub get_global: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_v8value_t,
    >,
    #[doc = ""]
    #[doc = " Enter this context. A context must be explicitly entered before creating a"]
    #[doc = " V8 Object, Array, Function or Date asynchronously. exit() must be called"]
    #[doc = " the same number of times as enter() before releasing this context. V8"]
    #[doc = " objects belong to the context in which they are created. Returns true (1)"]
    #[doc = " if the scope was entered successfully."]
    #[doc = ""]
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Exit this context. Call this function only after calling enter(). Returns"]
    #[doc = " true (1) if the scope was exited successfully."]
    #[doc = ""]
    pub exit: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same handle as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8context_t,
            that: *mut _cef_v8context_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Execute a string of JavaScript code in this V8 context. The |script_url|"]
    #[doc = " parameter is the URL where the script in question can be found, if any. The"]
    #[doc = " |start_line| parameter is the base line number to use for error reporting."]
    #[doc = " On success |retval| will be set to the return value, if any, and the"]
    #[doc = " function will return true (1). On failure |exception| will be set to the"]
    #[doc = " exception, if any, and the function will return false (0)."]
    #[doc = ""]
    pub eval: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8context_t,
            code: *const cef_string_t,
            script_url: *const cef_string_t,
            start_line: ::std::os::raw::c_int,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut *mut _cef_v8exception_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure representing a V8 context handle. V8 handles can only be accessed"]
#[doc = " from the thread on which they are created. Valid threads for creating a V8"]
#[doc = " handle include the render process main thread (TID_RENDERER) and WebWorker"]
#[doc = " threads. A task runner for posting tasks on the associated thread can be"]
#[doc = " retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
pub type cef_v8context_t = _cef_v8context_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the current (top) context object in the V8 context stack."]
    #[doc = ""]
    pub fn cef_v8context_get_current_context() -> *mut cef_v8context_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns the entered (bottom) context object in the V8 context stack."]
    #[doc = ""]
    pub fn cef_v8context_get_entered_context() -> *mut cef_v8context_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns true (1) if V8 is currently inside a context."]
    #[doc = ""]
    pub fn cef_v8context_in_context() -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 function calls. The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Handle execution of the function identified by |name|. |object| is the"]
    #[doc = " receiver ('this' object) of the function. |arguments| is the list of"]
    #[doc = " arguments passed to the function. If execution succeeds set |retval| to the"]
    #[doc = " function return value. If execution fails set |exception| to the exception"]
    #[doc = " that will be thrown. Return true (1) if execution was handled."]
    #[doc = ""]
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8handler_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            argumentsCount: usize,
            arguments: *const *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 function calls. The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 function."]
#[doc = ""]
pub type cef_v8handler_t = _cef_v8handler_t;
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 accessor calls. Accessor"]
#[doc = " identifiers are registered by calling cef_v8value_t::set_value(). The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 accessor."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8accessor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Handle retrieval the accessor value identified by |name|. |object| is the"]
    #[doc = " receiver ('this' object) of the accessor. If retrieval succeeds set"]
    #[doc = " |retval| to the return value. If retrieval fails set |exception| to the"]
    #[doc = " exception that will be thrown. Return true (1) if accessor retrieval was"]
    #[doc = " handled."]
    #[doc = ""]
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8accessor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Handle assignment of the accessor value identified by |name|. |object| is"]
    #[doc = " the receiver ('this' object) of the accessor. |value| is the new value"]
    #[doc = " being assigned to the accessor. If assignment fails set |exception| to the"]
    #[doc = " exception that will be thrown. Return true (1) if accessor assignment was"]
    #[doc = " handled."]
    #[doc = ""]
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8accessor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 accessor calls. Accessor"]
#[doc = " identifiers are registered by calling cef_v8value_t::set_value(). The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 accessor."]
#[doc = ""]
pub type cef_v8accessor_t = _cef_v8accessor_t;
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 interceptor calls. The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 interceptor. Interceptor's named property handlers (with first argument of"]
#[doc = " type CefString) are called when object is indexed by string. Indexed property"]
#[doc = " handlers (with first argument of type int) are called when object is indexed"]
#[doc = " by integer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8interceptor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Handle retrieval of the interceptor value identified by |name|. |object| is"]
    #[doc = " the receiver ('this' object) of the interceptor. If retrieval succeeds, set"]
    #[doc = " |retval| to the return value. If the requested value does not exist, don't"]
    #[doc = " set either |retval| or |exception|. If retrieval fails, set |exception| to"]
    #[doc = " the exception that will be thrown. If the property has an associated"]
    #[doc = " accessor, it will be called only if you don't set |retval|. Return true (1)"]
    #[doc = " if interceptor retrieval was handled, false (0) otherwise."]
    #[doc = ""]
    pub get_byname: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Handle retrieval of the interceptor value identified by |index|. |object|"]
    #[doc = " is the receiver ('this' object) of the interceptor. If retrieval succeeds,"]
    #[doc = " set |retval| to the return value. If the requested value does not exist,"]
    #[doc = " don't set either |retval| or |exception|. If retrieval fails, set"]
    #[doc = " |exception| to the exception that will be thrown. Return true (1) if"]
    #[doc = " interceptor retrieval was handled, false (0) otherwise."]
    #[doc = ""]
    pub get_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            index: ::std::os::raw::c_int,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Handle assignment of the interceptor value identified by |name|. |object|"]
    #[doc = " is the receiver ('this' object) of the interceptor. |value| is the new"]
    #[doc = " value being assigned to the interceptor. If assignment fails, set"]
    #[doc = " |exception| to the exception that will be thrown. This setter will always"]
    #[doc = " be called, even when the property has an associated accessor. Return true"]
    #[doc = " (1) if interceptor assignment was handled, false (0) otherwise."]
    #[doc = ""]
    pub set_byname: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Handle assignment of the interceptor value identified by |index|. |object|"]
    #[doc = " is the receiver ('this' object) of the interceptor. |value| is the new"]
    #[doc = " value being assigned to the interceptor. If assignment fails, set"]
    #[doc = " |exception| to the exception that will be thrown. Return true (1) if"]
    #[doc = " interceptor assignment was handled, false (0) otherwise."]
    #[doc = ""]
    pub set_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            index: ::std::os::raw::c_int,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 interceptor calls. The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 interceptor. Interceptor's named property handlers (with first argument of"]
#[doc = " type CefString) are called when object is indexed by string. Indexed property"]
#[doc = " handlers (with first argument of type int) are called when object is indexed"]
#[doc = " by integer."]
#[doc = ""]
pub type cef_v8interceptor_t = _cef_v8interceptor_t;
#[doc = ""]
#[doc = " Structure representing a V8 exception. The functions of this structure may be"]
#[doc = " called on any render process thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8exception_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the exception message."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_message: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the line of source code that the exception occurred within."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_source_line: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the resource name for the script from where the function causing"]
    #[doc = " the error originates."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_script_resource_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the 1-based number of the line where the error occurred or 0 if the"]
    #[doc = " line number is unknown."]
    #[doc = ""]
    pub get_line_number: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index within the script of the first character where the error"]
    #[doc = " occurred."]
    #[doc = ""]
    pub get_start_position: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index within the script of the last character where the error"]
    #[doc = " occurred."]
    #[doc = ""]
    pub get_end_position: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index within the line of the first character where the error"]
    #[doc = " occurred."]
    #[doc = ""]
    pub get_start_column: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index within the line of the last character where the error"]
    #[doc = " occurred."]
    #[doc = ""]
    pub get_end_column: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure representing a V8 value handle. V8 handles can only be accessed"]
#[doc = " from the thread on which they are created. Valid threads for creating a V8"]
#[doc = " handle include the render process main thread (TID_RENDERER) and WebWorker"]
#[doc = " threads. A task runner for posting tasks on the associated thread can be"]
#[doc = " retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying handle is valid and it can be accessed"]
    #[doc = " on the current thread. Do not call any other functions if this function"]
    #[doc = " returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is undefined."]
    #[doc = ""]
    pub is_undefined: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is null."]
    #[doc = ""]
    pub is_null: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is bool."]
    #[doc = ""]
    pub is_bool: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is int."]
    #[doc = ""]
    pub is_int: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is unsigned int."]
    #[doc = ""]
    pub is_uint: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is double."]
    #[doc = ""]
    pub is_double: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is Date."]
    #[doc = ""]
    pub is_date: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is string."]
    #[doc = ""]
    pub is_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is object."]
    #[doc = ""]
    pub is_object: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is array."]
    #[doc = ""]
    pub is_array: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is function."]
    #[doc = ""]
    pub is_function: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same handle as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            that: *mut _cef_v8value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return a bool value."]
    #[doc = ""]
    pub get_bool_value: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return an int value."]
    #[doc = ""]
    pub get_int_value:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> int32>,
    #[doc = ""]
    #[doc = " Return an unsigned int value."]
    #[doc = ""]
    pub get_uint_value:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> uint32>,
    #[doc = ""]
    #[doc = " Return a double value."]
    #[doc = ""]
    pub get_double_value:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> f64>,
    #[doc = ""]
    #[doc = " Return a Date value."]
    #[doc = ""]
    pub get_date_value:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_time_t>,
    #[doc = ""]
    #[doc = " Return a string value."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_string_value: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is a user created object."]
    #[doc = ""]
    pub is_user_created: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the last function call resulted in an exception. This"]
    #[doc = " attribute exists only in the scope of the current CEF value object."]
    #[doc = ""]
    pub has_exception: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the exception resulting from the last function call. This attribute"]
    #[doc = " exists only in the scope of the current CEF value object."]
    #[doc = ""]
    pub get_exception: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_v8exception_t,
    >,
    #[doc = ""]
    #[doc = " Clears the last exception and returns true (1) on success."]
    #[doc = ""]
    pub clear_exception: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object will re-throw future exceptions. This"]
    #[doc = " attribute exists only in the scope of the current CEF value object."]
    #[doc = ""]
    pub will_rethrow_exceptions: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set whether this object will re-throw future exceptions. By default"]
    #[doc = " exceptions are not re-thrown. If a exception is re-thrown the current"]
    #[doc = " context should not be accessed again until after the exception has been"]
    #[doc = " caught and not re-thrown. Returns true (1) on success. This attribute"]
    #[doc = " exists only in the scope of the current CEF value object."]
    #[doc = ""]
    pub set_rethrow_exceptions: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            rethrow: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the object has a value with the specified identifier."]
    #[doc = ""]
    pub has_value_bykey: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the object has a value with the specified identifier."]
    #[doc = ""]
    pub has_value_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Deletes the value with the specified identifier and returns true (1) on"]
    #[doc = " success. Returns false (0) if this function is called incorrectly or an"]
    #[doc = " exception is thrown. For read-only and don't-delete values this function"]
    #[doc = " will return true (1) even though deletion failed."]
    #[doc = ""]
    pub delete_value_bykey: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Deletes the value with the specified identifier and returns true (1) on"]
    #[doc = " success. Returns false (0) if this function is called incorrectly, deletion"]
    #[doc = " fails or an exception is thrown. For read-only and don't-delete values this"]
    #[doc = " function will return true (1) even though deletion failed."]
    #[doc = ""]
    pub delete_value_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value with the specified identifier on success. Returns NULL if"]
    #[doc = " this function is called incorrectly or an exception is thrown."]
    #[doc = ""]
    pub get_value_bykey: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value with the specified identifier on success. Returns NULL if"]
    #[doc = " this function is called incorrectly or an exception is thrown."]
    #[doc = ""]
    pub get_value_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::std::os::raw::c_int,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = ""]
    #[doc = " Associates a value with the specified identifier and returns true (1) on"]
    #[doc = " success. Returns false (0) if this function is called incorrectly or an"]
    #[doc = " exception is thrown. For read-only values this function will return true"]
    #[doc = " (1) even though assignment failed."]
    #[doc = ""]
    pub set_value_bykey: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
            value: *mut _cef_v8value_t,
            attribute: cef_v8_propertyattribute_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Associates a value with the specified identifier and returns true (1) on"]
    #[doc = " success. Returns false (0) if this function is called incorrectly or an"]
    #[doc = " exception is thrown. For read-only values this function will return true"]
    #[doc = " (1) even though assignment failed."]
    #[doc = ""]
    pub set_value_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::std::os::raw::c_int,
            value: *mut _cef_v8value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Registers an identifier and returns true (1) on success. Access to the"]
    #[doc = " identifier will be forwarded to the cef_v8accessor_t instance passed to"]
    #[doc = " cef_v8value_t::cef_v8value_create_object(). Returns false (0) if this"]
    #[doc = " function is called incorrectly or an exception is thrown. For read-only"]
    #[doc = " values this function will return true (1) even though assignment failed."]
    #[doc = ""]
    pub set_value_byaccessor: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
            settings: cef_v8_accesscontrol_t,
            attribute: cef_v8_propertyattribute_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Read the keys for the object's values into the specified vector. Integer-"]
    #[doc = " based keys will also be returned as strings."]
    #[doc = ""]
    pub get_keys: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            keys: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the user data for this object and returns true (1) on success. Returns"]
    #[doc = " false (0) if this function is called incorrectly. This function can only be"]
    #[doc = " called on user created objects."]
    #[doc = ""]
    pub set_user_data: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            user_data: *mut _cef_base_ref_counted_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the user data, if any, assigned to this object."]
    #[doc = ""]
    pub get_user_data: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_base_ref_counted_t,
    >,
    #[doc = ""]
    #[doc = " Returns the amount of externally allocated memory registered for the"]
    #[doc = " object."]
    #[doc = ""]
    pub get_externally_allocated_memory: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Adjusts the amount of registered external memory for the object. Used to"]
    #[doc = " give V8 an indication of the amount of externally allocated memory that is"]
    #[doc = " kept alive by JavaScript objects. V8 uses this information to decide when"]
    #[doc = " to perform global garbage collection. Each cef_v8value_t tracks the amount"]
    #[doc = " of external memory associated with it and automatically decreases the"]
    #[doc = " global total by the appropriate amount on its destruction."]
    #[doc = " |change_in_bytes| specifies the number of bytes to adjust by. This function"]
    #[doc = " returns the number of bytes associated with the object after the"]
    #[doc = " adjustment. This function can only be called on user created objects."]
    #[doc = ""]
    pub adjust_externally_allocated_memory: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            change_in_bytes: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of elements in the array."]
    #[doc = ""]
    pub get_array_length: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the function name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_function_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the function handler or NULL if not a CEF-created function."]
    #[doc = ""]
    pub get_function_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_v8handler_t,
    >,
    #[doc = ""]
    #[doc = " Execute the function using the current V8 context. This function should"]
    #[doc = " only be called from within the scope of a cef_v8handler_t or"]
    #[doc = " cef_v8accessor_t callback, or in combination with calling enter() and"]
    #[doc = " exit() on a stored cef_v8context_t reference. |object| is the receiver"]
    #[doc = " ('this' object) of the function. If |object| is NULL the current context's"]
    #[doc = " global object will be used. |arguments| is the list of arguments that will"]
    #[doc = " be passed to the function. Returns the function return value on success."]
    #[doc = " Returns NULL if this function is called incorrectly or an exception is"]
    #[doc = " thrown."]
    #[doc = ""]
    pub execute_function: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            object: *mut _cef_v8value_t,
            argumentsCount: usize,
            arguments: *const *mut _cef_v8value_t,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = ""]
    #[doc = " Execute the function using the specified V8 context. |object| is the"]
    #[doc = " receiver ('this' object) of the function. If |object| is NULL the specified"]
    #[doc = " context's global object will be used. |arguments| is the list of arguments"]
    #[doc = " that will be passed to the function. Returns the function return value on"]
    #[doc = " success. Returns NULL if this function is called incorrectly or an"]
    #[doc = " exception is thrown."]
    #[doc = ""]
    pub execute_function_with_context: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            context: *mut _cef_v8context_t,
            object: *mut _cef_v8value_t,
            argumentsCount: usize,
            arguments: *const *mut _cef_v8value_t,
        ) -> *mut _cef_v8value_t,
    >,
}
#[doc = ""]
#[doc = " Structure representing a V8 value handle. V8 handles can only be accessed"]
#[doc = " from the thread on which they are created. Valid threads for creating a V8"]
#[doc = " handle include the render process main thread (TID_RENDERER) and WebWorker"]
#[doc = " threads. A task runner for posting tasks on the associated thread can be"]
#[doc = " retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
pub type cef_v8value_t = _cef_v8value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type undefined."]
    #[doc = ""]
    pub fn cef_v8value_create_undefined() -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type null."]
    #[doc = ""]
    pub fn cef_v8value_create_null() -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type bool."]
    #[doc = ""]
    pub fn cef_v8value_create_bool(value: ::std::os::raw::c_int) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type int."]
    #[doc = ""]
    pub fn cef_v8value_create_int(value: int32) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type unsigned int."]
    #[doc = ""]
    pub fn cef_v8value_create_uint(value: uint32) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type double."]
    #[doc = ""]
    pub fn cef_v8value_create_double(value: f64) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type Date. This function should only be"]
    #[doc = " called from within the scope of a cef_render_process_handler_t,"]
    #[doc = " cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling"]
    #[doc = " enter() and exit() on a stored cef_v8context_t reference."]
    #[doc = ""]
    pub fn cef_v8value_create_date(date: *const cef_time_t) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type string."]
    #[doc = ""]
    pub fn cef_v8value_create_string(value: *const cef_string_t) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type object with optional accessor"]
    #[doc = " and/or interceptor. This function should only be called from within the scope"]
    #[doc = " of a cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t"]
    #[doc = " callback, or in combination with calling enter() and exit() on a stored"]
    #[doc = " cef_v8context_t reference."]
    #[doc = ""]
    pub fn cef_v8value_create_object(
        accessor: *mut cef_v8accessor_t,
        interceptor: *mut cef_v8interceptor_t,
    ) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type array with the specified |length|."]
    #[doc = " If |length| is negative the returned array will have length 0. This function"]
    #[doc = " should only be called from within the scope of a"]
    #[doc = " cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,"]
    #[doc = " or in combination with calling enter() and exit() on a stored cef_v8context_t"]
    #[doc = " reference."]
    #[doc = ""]
    pub fn cef_v8value_create_array(length: ::std::os::raw::c_int) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type function. This function should only"]
    #[doc = " be called from within the scope of a cef_render_process_handler_t,"]
    #[doc = " cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling"]
    #[doc = " enter() and exit() on a stored cef_v8context_t reference."]
    #[doc = ""]
    pub fn cef_v8value_create_function(
        name: *const cef_string_t,
        handler: *mut cef_v8handler_t,
    ) -> *mut cef_v8value_t;
}
#[doc = ""]
#[doc = " Structure representing a V8 stack trace handle. V8 handles can only be"]
#[doc = " accessed from the thread on which they are created. Valid threads for"]
#[doc = " creating a V8 handle include the render process main thread (TID_RENDERER)"]
#[doc = " and WebWorker threads. A task runner for posting tasks on the associated"]
#[doc = " thread can be retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8stack_trace_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying handle is valid and it can be accessed"]
    #[doc = " on the current thread. Do not call any other functions if this function"]
    #[doc = " returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_trace_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of stack frames."]
    #[doc = ""]
    pub get_frame_count: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_trace_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the stack frame at the specified 0-based index."]
    #[doc = ""]
    pub get_frame: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8stack_trace_t,
            index: ::std::os::raw::c_int,
        ) -> *mut _cef_v8stack_frame_t,
    >,
}
#[doc = ""]
#[doc = " Structure representing a V8 stack trace handle. V8 handles can only be"]
#[doc = " accessed from the thread on which they are created. Valid threads for"]
#[doc = " creating a V8 handle include the render process main thread (TID_RENDERER)"]
#[doc = " and WebWorker threads. A task runner for posting tasks on the associated"]
#[doc = " thread can be retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
pub type cef_v8stack_trace_t = _cef_v8stack_trace_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the stack trace for the currently active context. |frame_limit| is"]
    #[doc = " the maximum number of frames that will be captured."]
    #[doc = ""]
    pub fn cef_v8stack_trace_get_current(
        frame_limit: ::std::os::raw::c_int,
    ) -> *mut cef_v8stack_trace_t;
}
#[doc = ""]
#[doc = " Structure representing a V8 stack frame handle. V8 handles can only be"]
#[doc = " accessed from the thread on which they are created. Valid threads for"]
#[doc = " creating a V8 handle include the render process main thread (TID_RENDERER)"]
#[doc = " and WebWorker threads. A task runner for posting tasks on the associated"]
#[doc = " thread can be retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8stack_frame_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying handle is valid and it can be accessed"]
    #[doc = " on the current thread. Do not call any other functions if this function"]
    #[doc = " returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the name of the resource script that contains the function."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_script_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the name of the resource script that contains the function or the"]
    #[doc = " sourceURL value if the script name is undefined and its source ends with a"]
    #[doc = " \"//@ sourceURL=...\" string."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_script_name_or_source_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the name of the function."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_function_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the 1-based line number for the function call or 0 if unknown."]
    #[doc = ""]
    pub get_line_number: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the 1-based column offset on the line for the function call or 0 if"]
    #[doc = " unknown."]
    #[doc = ""]
    pub get_column: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the function was compiled using eval()."]
    #[doc = ""]
    pub is_eval: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the function was called as a constructor via \"new\"."]
    #[doc = ""]
    pub is_constructor: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
}
extern "C" {
    #[doc = ""]
    #[doc = " Register a new V8 extension with the specified JavaScript extension code and"]
    #[doc = " handler. Functions implemented by the handler are prototyped using the"]
    #[doc = " keyword 'native'. The calling of a native function is restricted to the scope"]
    #[doc = " in which the prototype of the native function is defined. This function may"]
    #[doc = " only be called on the render process main thread."]
    #[doc = ""]
    #[doc = " Example JavaScript extension code: <pre>"]
    #[doc = "   // create the 'example' global object if it doesn't already exist."]
    #[doc = "   if (!example)"]
    #[doc = "     example = {};"]
    #[doc = "   // create the 'example.test' global object if it doesn't already exist."]
    #[doc = "   if (!example.test)"]
    #[doc = "     example.test = {};"]
    #[doc = "   (function() {"]
    #[doc = "     // Define the function 'example.test.myfunction'."]
    #[doc = "     example.test.myfunction = function() {"]
    #[doc = "       // Call CefV8Handler::Execute() with the function name 'MyFunction'"]
    #[doc = "       // and no arguments."]
    #[doc = "       native function MyFunction();"]
    #[doc = "       return MyFunction();"]
    #[doc = "     };"]
    #[doc = "     // Define the getter function for parameter 'example.test.myparam'."]
    #[doc = "     example.test.__defineGetter__('myparam', function() {"]
    #[doc = "       // Call CefV8Handler::Execute() with the function name 'GetMyParam'"]
    #[doc = "       // and no arguments."]
    #[doc = "       native function GetMyParam();"]
    #[doc = "       return GetMyParam();"]
    #[doc = "     });"]
    #[doc = "     // Define the setter function for parameter 'example.test.myparam'."]
    #[doc = "     example.test.__defineSetter__('myparam', function(b) {"]
    #[doc = "       // Call CefV8Handler::Execute() with the function name 'SetMyParam'"]
    #[doc = "       // and a single argument."]
    #[doc = "       native function SetMyParam();"]
    #[doc = "       if(b) SetMyParam(b);"]
    #[doc = "     });"]
    #[doc = ""]
    #[doc = "     // Extension definitions can also contain normal JavaScript variables"]
    #[doc = "     // and functions."]
    #[doc = "     var myint = 0;"]
    #[doc = "     example.test.increment = function() {"]
    #[doc = "       myint += 1;"]
    #[doc = "       return myint;"]
    #[doc = "     };"]
    #[doc = "   })();"]
    #[doc = " </pre> Example usage in the page: <pre>"]
    #[doc = "   // Call the function."]
    #[doc = "   example.test.myfunction();"]
    #[doc = "   // Set the parameter."]
    #[doc = "   example.test.myparam = value;"]
    #[doc = "   // Get the parameter."]
    #[doc = "   value = example.test.myparam;"]
    #[doc = "   // Call another function."]
    #[doc = "   example.test.increment();"]
    #[doc = " </pre>"]
    #[doc = ""]
    pub fn cef_register_extension(
        extension_name: *const cef_string_t,
        javascript_code: *const cef_string_t,
        handler: *mut cef_v8handler_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Structure used to implement render process callbacks. The functions of this"]
#[doc = " structure will be called on the render process main thread (TID_RENDERER)"]
#[doc = " unless otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_render_process_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called after the render process main thread has been created. |extra_info|"]
    #[doc = " is a read-only value originating from"]
    #[doc = " cef_browser_process_handler_t::on_render_process_thread_created(). Do not"]
    #[doc = " keep a reference to |extra_info| outside of this function."]
    #[doc = ""]
    pub on_render_thread_created: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            extra_info: *mut _cef_list_value_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called after WebKit has been initialized."]
    #[doc = ""]
    pub on_web_kit_initialized:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_render_process_handler_t)>,
    #[doc = ""]
    #[doc = " Called after a browser has been created. When browsing cross-origin a new"]
    #[doc = " browser will be created before the old browser with the same identifier is"]
    #[doc = " destroyed."]
    #[doc = ""]
    pub on_browser_created: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called before a browser is destroyed."]
    #[doc = ""]
    pub on_browser_destroyed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser load status events."]
    #[doc = ""]
    pub get_load_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_render_process_handler_t) -> *mut _cef_load_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called before browser navigation. Return true (1) to cancel the navigation"]
    #[doc = " or false (0) to allow the navigation to proceed. The |request| object"]
    #[doc = " cannot be modified in this callback."]
    #[doc = ""]
    pub on_before_navigation: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            navigation_type: cef_navigation_type_t,
            is_redirect: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called immediately after the V8 context for a frame has been created. To"]
    #[doc = " retrieve the JavaScript 'window' object use the"]
    #[doc = " cef_v8context_t::get_global() function. V8 handles can only be accessed"]
    #[doc = " from the thread on which they are created. A task runner for posting tasks"]
    #[doc = " on the associated thread can be retrieved via the"]
    #[doc = " cef_v8context_t::get_task_runner() function."]
    #[doc = ""]
    pub on_context_created: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called immediately before the V8 context for a frame is released. No"]
    #[doc = " references to the context should be kept after this function is called."]
    #[doc = ""]
    pub on_context_released: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called for global uncaught exceptions in a frame. Execution of this"]
    #[doc = " callback is disabled by default. To enable set"]
    #[doc = " CefSettings.uncaught_exception_stack_size > 0."]
    #[doc = ""]
    pub on_uncaught_exception: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
            exception: *mut _cef_v8exception_t,
            stackTrace: *mut _cef_v8stack_trace_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a new node in the the browser gets focus. The |node| value may"]
    #[doc = " be NULL if no specific node has gained focus. The node object passed to"]
    #[doc = " this function represents a snapshot of the DOM at the time this function is"]
    #[doc = " executed. DOM objects are only valid for the scope of this function. Do not"]
    #[doc = " keep references to or attempt to access any DOM objects outside the scope"]
    #[doc = " of this function."]
    #[doc = ""]
    pub on_focused_node_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            node: *mut _cef_domnode_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a new message is received from a different process. Return true"]
    #[doc = " (1) if the message was handled or false (0) otherwise. Do not keep a"]
    #[doc = " reference to or attempt to access the message outside of this callback."]
    #[doc = ""]
    pub on_process_message_received: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            source_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to implement a custom resource bundle structure. See"]
#[doc = " CefSettings for additional options related to resource bundle loading. The"]
#[doc = " functions of this structure may be called on multiple threads."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_bundle_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to retrieve a localized translation for the specified |string_id|."]
    #[doc = " To provide the translation set |string| to the translation string and"]
    #[doc = " return true (1). To use the default translation return false (0). Include"]
    #[doc = " cef_pack_strings.h for a listing of valid string ID values."]
    #[doc = ""]
    pub get_localized_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            string_id: ::std::os::raw::c_int,
            string: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve data for the specified scale independent |resource_id|."]
    #[doc = " To provide the resource data set |data| and |data_size| to the data pointer"]
    #[doc = " and size respectively and return true (1). To use the default resource data"]
    #[doc = " return false (0). The resource data will not be copied and must remain"]
    #[doc = " resident in memory. Include cef_pack_resources.h for a listing of valid"]
    #[doc = " resource ID values."]
    #[doc = ""]
    pub get_data_resource: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            resource_id: ::std::os::raw::c_int,
            data: *mut *mut ::std::os::raw::c_void,
            data_size: *mut usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve data for the specified |resource_id| nearest the scale"]
    #[doc = " factor |scale_factor|. To provide the resource data set |data| and"]
    #[doc = " |data_size| to the data pointer and size respectively and return true (1)."]
    #[doc = " To use the default resource data return false (0). The resource data will"]
    #[doc = " not be copied and must remain resident in memory. Include"]
    #[doc = " cef_pack_resources.h for a listing of valid resource ID values."]
    #[doc = ""]
    pub get_data_resource_for_scale: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            resource_id: ::std::os::raw::c_int,
            scale_factor: cef_scale_factor_t,
            data: *mut *mut ::std::os::raw::c_void,
            data_size: *mut usize,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to represent a web response. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_response_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Get the response error code. Returns ERR_NONE if there was no error."]
    #[doc = ""]
    pub get_error:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_errorcode_t>,
    #[doc = ""]
    #[doc = " Set the response error code. This can be used by custom scheme handlers to"]
    #[doc = " return errors during initial request processing."]
    #[doc = ""]
    pub set_error: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, error: cef_errorcode_t),
    >,
    #[doc = ""]
    #[doc = " Get the response status code."]
    #[doc = ""]
    pub get_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the response status code."]
    #[doc = ""]
    pub set_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, status: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Get the response status text."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_status_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the response status text."]
    #[doc = ""]
    pub set_status_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, statusText: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the response mime type."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_mime_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the response mime type."]
    #[doc = ""]
    pub set_mime_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, mimeType: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the value for the specified response header field."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_header: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_response_t,
            name: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Get all response header fields."]
    #[doc = ""]
    pub get_header_map: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = ""]
    #[doc = " Set all response header fields."]
    #[doc = ""]
    pub set_header_map: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, headerMap: cef_string_multimap_t),
    >,
}
#[doc = ""]
#[doc = " Structure used to represent a web response. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
pub type cef_response_t = _cef_response_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_response_t object."]
    #[doc = ""]
    pub fn cef_response_create() -> *mut cef_response_t;
}
#[doc = ""]
#[doc = " Structure used to implement a custom request handler structure. The functions"]
#[doc = " of this structure will always be called on the IO thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Begin processing the request. To handle the request return true (1) and"]
    #[doc = " call cef_callback_t::cont() once the response header information is"]
    #[doc = " available (cef_callback_t::cont() can also be called from inside this"]
    #[doc = " function if header information is available immediately). To cancel the"]
    #[doc = " request return false (0)."]
    #[doc = ""]
    pub process_request: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            request: *mut _cef_request_t,
            callback: *mut _cef_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Retrieve response header information. If the response length is not known"]
    #[doc = " set |response_length| to -1 and read_response() will be called until it"]
    #[doc = " returns false (0). If the response length is known set |response_length| to"]
    #[doc = " a positive value and read_response() will be called until it returns false"]
    #[doc = " (0) or the specified number of bytes have been read. Use the |response|"]
    #[doc = " object to set the mime type, http status code and other optional header"]
    #[doc = " values. To redirect the request to a new URL set |redirectUrl| to the new"]
    #[doc = " URL. If an error occured while setting up the request you can call"]
    #[doc = " set_error() on |response| to indicate the error condition."]
    #[doc = ""]
    pub get_response_headers: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            response: *mut _cef_response_t,
            response_length: *mut int64,
            redirectUrl: *mut cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Read response data. If data is available immediately copy up to"]
    #[doc = " |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of"]
    #[doc = " bytes copied, and return true (1). To read the data at a later time set"]
    #[doc = " |bytes_read| to 0, return true (1) and call cef_callback_t::cont() when the"]
    #[doc = " data is available. To indicate response completion return false (0)."]
    #[doc = ""]
    pub read_response: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            data_out: *mut ::std::os::raw::c_void,
            bytes_to_read: ::std::os::raw::c_int,
            bytes_read: *mut ::std::os::raw::c_int,
            callback: *mut _cef_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return true (1) if the specified cookie can be sent with the request or"]
    #[doc = " false (0) otherwise. If false (0) is returned for any cookie then no"]
    #[doc = " cookies will be sent with the request."]
    #[doc = ""]
    pub can_get_cookie: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            cookie: *const _cef_cookie_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return true (1) if the specified cookie returned with the response can be"]
    #[doc = " set or false (0) otherwise."]
    #[doc = ""]
    pub can_set_cookie: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            cookie: *const _cef_cookie_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Request processing has been canceled."]
    #[doc = ""]
    pub cancel: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_resource_handler_t)>,
}
#[doc = ""]
#[doc = " Structure that manages custom scheme registrations."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_scheme_registrar_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_scoped_t,
    #[doc = ""]
    #[doc = " Register a custom scheme. This function should not be called for the built-"]
    #[doc = " in HTTP, HTTPS, FILE, FTP, ABOUT and DATA schemes."]
    #[doc = ""]
    #[doc = " If |is_standard| is true (1) the scheme will be treated as a standard"]
    #[doc = " scheme. Standard schemes are subject to URL canonicalization and parsing"]
    #[doc = " rules as defined in the Common Internet Scheme Syntax RFC 1738 Section 3.1"]
    #[doc = " available at http://www.ietf.org/rfc/rfc1738.txt"]
    #[doc = ""]
    #[doc = " In particular, the syntax for standard scheme URLs must be of the form:"]
    #[doc = " <pre>"]
    #[doc = "  [scheme]://[username]:[password]@[host]:[port]/[url-path]"]
    #[doc = " </pre> Standard scheme URLs must have a host component that is a fully"]
    #[doc = " qualified domain name as defined in Section 3.5 of RFC 1034 [13] and"]
    #[doc = " Section 2.1 of RFC 1123. These URLs will be canonicalized to"]
    #[doc = " \"scheme://host/path\" in the simplest case and"]
    #[doc = " \"scheme://username:password@host:port/path\" in the most explicit case. For"]
    #[doc = " example, \"scheme:host/path\" and \"scheme:///host/path\" will both be"]
    #[doc = " canonicalized to \"scheme://host/path\". The origin of a standard scheme URL"]
    #[doc = " is the combination of scheme, host and port (i.e., \"scheme://host:port\" in"]
    #[doc = " the most explicit case)."]
    #[doc = ""]
    #[doc = " For non-standard scheme URLs only the \"scheme:\" component is parsed and"]
    #[doc = " canonicalized. The remainder of the URL will be passed to the handler as-"]
    #[doc = " is. For example, \"scheme:///some%20text\" will remain the same. Non-standard"]
    #[doc = " scheme URLs cannot be used as a target for form submission."]
    #[doc = ""]
    #[doc = " If |is_local| is true (1) the scheme will be treated with the same security"]
    #[doc = " rules as those applied to \"file\" URLs. Normal pages cannot link to or"]
    #[doc = " access local URLs. Also, by default, local URLs can only perform"]
    #[doc = " XMLHttpRequest calls to the same URL (origin + path) that originated the"]
    #[doc = " request. To allow XMLHttpRequest calls from a local URL to other URLs with"]
    #[doc = " the same origin set the CefSettings.file_access_from_file_urls_allowed"]
    #[doc = " value to true (1). To allow XMLHttpRequest calls from a local URL to all"]
    #[doc = " origins set the CefSettings.universal_access_from_file_urls_allowed value"]
    #[doc = " to true (1)."]
    #[doc = ""]
    #[doc = " If |is_display_isolated| is true (1) the scheme can only be displayed from"]
    #[doc = " other content hosted with the same scheme. For example, pages in other"]
    #[doc = " origins cannot create iframes or hyperlinks to URLs with the scheme. For"]
    #[doc = " schemes that must be accessible from other schemes set this value to false"]
    #[doc = " (0), set |is_cors_enabled| to true (1), and use CORS \"Access-Control-Allow-"]
    #[doc = " Origin\" headers to further restrict access."]
    #[doc = ""]
    #[doc = " If |is_secure| is true (1) the scheme will be treated with the same"]
    #[doc = " security rules as those applied to \"https\" URLs. For example, loading this"]
    #[doc = " scheme from other secure schemes will not trigger mixed content warnings."]
    #[doc = ""]
    #[doc = " If |is_cors_enabled| is true (1) the scheme can be sent CORS requests. This"]
    #[doc = " value should be true (1) in most cases where |is_standard| is true (1)."]
    #[doc = ""]
    #[doc = " If |is_csp_bypassing| is true (1) the scheme can bypass Content-Security-"]
    #[doc = " Policy (CSP) checks. This value should be false (0) in most cases where"]
    #[doc = " |is_standard| is true (1)."]
    #[doc = ""]
    #[doc = " This function may be called on any thread. It should only be called once"]
    #[doc = " per unique |scheme_name| value. If |scheme_name| is already registered or"]
    #[doc = " if an error occurs this function will return false (0)."]
    #[doc = ""]
    pub add_custom_scheme: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_scheme_registrar_t,
            scheme_name: *const cef_string_t,
            is_standard: ::std::os::raw::c_int,
            is_local: ::std::os::raw::c_int,
            is_display_isolated: ::std::os::raw::c_int,
            is_secure: ::std::os::raw::c_int,
            is_cors_enabled: ::std::os::raw::c_int,
            is_csp_bypassing: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure that creates cef_resource_handler_t instances for handling scheme"]
#[doc = " requests. The functions of this structure will always be called on the IO"]
#[doc = " thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_scheme_handler_factory_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Return a new resource handler instance to handle the request or an NULL"]
    #[doc = " reference to allow default handling of the request. |browser| and |frame|"]
    #[doc = " will be the browser window and frame respectively that originated the"]
    #[doc = " request or NULL if the request did not originate from a browser window (for"]
    #[doc = " example, if the request came from cef_urlrequest_t). The |request| object"]
    #[doc = " passed to this function will not contain cookie data."]
    #[doc = ""]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_scheme_handler_factory_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            scheme_name: *const cef_string_t,
            request: *mut _cef_request_t,
        ) -> *mut _cef_resource_handler_t,
    >,
}
#[doc = ""]
#[doc = " Structure that creates cef_resource_handler_t instances for handling scheme"]
#[doc = " requests. The functions of this structure will always be called on the IO"]
#[doc = " thread."]
#[doc = ""]
pub type cef_scheme_handler_factory_t = _cef_scheme_handler_factory_t;
extern "C" {
    #[doc = ""]
    #[doc = " Register a scheme handler factory with the global request context. An NULL"]
    #[doc = " |domain_name| value for a standard scheme will cause the factory to match all"]
    #[doc = " domain names. The |domain_name| value will be ignored for non-standard"]
    #[doc = " schemes. If |scheme_name| is a built-in scheme and no handler is returned by"]
    #[doc = " |factory| then the built-in scheme handler factory will be called. If"]
    #[doc = " |scheme_name| is a custom scheme then you must also implement the"]
    #[doc = " cef_app_t::on_register_custom_schemes() function in all processes. This"]
    #[doc = " function may be called multiple times to change or remove the factory that"]
    #[doc = " matches the specified |scheme_name| and optional |domain_name|. Returns false"]
    #[doc = " (0) if an error occurs. This function may be called on any thread in the"]
    #[doc = " browser process. Using this function is equivalent to calling cef_request_tCo"]
    #[doc = " ntext::cef_request_context_get_global_context()->register_scheme_handler_fact"]
    #[doc = " ory()."]
    #[doc = ""]
    pub fn cef_register_scheme_handler_factory(
        scheme_name: *const cef_string_t,
        domain_name: *const cef_string_t,
        factory: *mut cef_scheme_handler_factory_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Clear all scheme handler factories registered with the global request"]
    #[doc = " context. Returns false (0) on error. This function may be called on any"]
    #[doc = " thread in the browser process. Using this function is equivalent to calling c"]
    #[doc = " ef_request_tContext::cef_request_context_get_global_context()->clear_scheme_h"]
    #[doc = " andler_factories()."]
    #[doc = ""]
    pub fn cef_clear_scheme_handler_factories() -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Implement this structure to provide handler implementations. Methods will be"]
#[doc = " called by the process and/or thread indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_app_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Provides an opportunity to view and/or modify command-line arguments before"]
    #[doc = " processing by CEF and Chromium. The |process_type| value will be NULL for"]
    #[doc = " the browser process. Do not keep a reference to the cef_command_line_t"]
    #[doc = " object passed to this function. The CefSettings.command_line_args_disabled"]
    #[doc = " value can be used to start with an NULL command-line object. Any values"]
    #[doc = " specified in CefSettings that equate to command-line arguments will be set"]
    #[doc = " before this function is called. Be cautious when using this function to"]
    #[doc = " modify command-line arguments for non-browser processes as this may result"]
    #[doc = " in undefined behavior including crashes."]
    #[doc = ""]
    pub on_before_command_line_processing: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_app_t,
            process_type: *const cef_string_t,
            command_line: *mut _cef_command_line_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Provides an opportunity to register custom schemes. Do not keep a reference"]
    #[doc = " to the |registrar| object. This function is called on the main thread for"]
    #[doc = " each process and the registered schemes should be the same across all"]
    #[doc = " processes."]
    #[doc = ""]
    pub on_register_custom_schemes: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t, registrar: *mut _cef_scheme_registrar_t),
    >,
    #[doc = ""]
    #[doc = " Return the handler for resource bundle events. If"]
    #[doc = " CefSettings.pack_loading_disabled is true (1) a handler must be returned."]
    #[doc = " If no handler is returned resources will be loaded from pack files. This"]
    #[doc = " function is called by the browser and render processes on multiple threads."]
    #[doc = ""]
    pub get_resource_bundle_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_resource_bundle_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for functionality specific to the browser process. This"]
    #[doc = " function is called on multiple threads in the browser process."]
    #[doc = ""]
    pub get_browser_process_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_browser_process_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for functionality specific to the render process. This"]
    #[doc = " function is called on the render process main thread."]
    #[doc = ""]
    pub get_render_process_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_render_process_handler_t,
    >,
}
#[doc = ""]
#[doc = " Implement this structure to provide handler implementations. Methods will be"]
#[doc = " called by the process and/or thread indicated."]
#[doc = ""]
pub type cef_app_t = _cef_app_t;
extern "C" {
    #[doc = ""]
    #[doc = " This function should be called from the application entry point function to"]
    #[doc = " execute a secondary process. It can be used to run secondary processes from"]
    #[doc = " the browser client executable (default behavior) or from a separate"]
    #[doc = " executable specified by the CefSettings.browser_subprocess_path value. If"]
    #[doc = " called for the browser process (identified by no \"type\" command-line value)"]
    #[doc = " it will return immediately with a value of -1. If called for a recognized"]
    #[doc = " secondary process it will block until the process should exit and then return"]
    #[doc = " the process exit code. The |application| parameter may be NULL. The"]
    #[doc = " |windows_sandbox_info| parameter is only used on Windows and may be NULL (see"]
    #[doc = " cef_sandbox_win.h for details)."]
    #[doc = ""]
    pub fn cef_execute_process(
        args: *const _cef_main_args_t,
        application: *mut cef_app_t,
        windows_sandbox_info: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " This function should be called on the main application thread to initialize"]
    #[doc = " the CEF browser process. The |application| parameter may be NULL. A return"]
    #[doc = " value of true (1) indicates that it succeeded and false (0) indicates that it"]
    #[doc = " failed. The |windows_sandbox_info| parameter is only used on Windows and may"]
    #[doc = " be NULL (see cef_sandbox_win.h for details)."]
    #[doc = ""]
    pub fn cef_initialize(
        args: *const _cef_main_args_t,
        settings: *const _cef_settings_t,
        application: *mut cef_app_t,
        windows_sandbox_info: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " This function should be called on the main application thread to shut down"]
    #[doc = " the CEF browser process before the application exits."]
    #[doc = ""]
    pub fn cef_shutdown();
}
extern "C" {
    #[doc = ""]
    #[doc = " Perform a single iteration of CEF message loop processing. This function is"]
    #[doc = " provided for cases where the CEF message loop must be integrated into an"]
    #[doc = " existing application message loop. Use of this function is not recommended"]
    #[doc = " for most users; use either the cef_run_message_loop() function or"]
    #[doc = " CefSettings.multi_threaded_message_loop if possible. When using this function"]
    #[doc = " care must be taken to balance performance against excessive CPU usage. It is"]
    #[doc = " recommended to enable the CefSettings.external_message_pump option when using"]
    #[doc = " this function so that"]
    #[doc = " cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can"]
    #[doc = " facilitate the scheduling process. This function should only be called on the"]
    #[doc = " main application thread and only if cef_initialize() is called with a"]
    #[doc = " CefSettings.multi_threaded_message_loop value of false (0). This function"]
    #[doc = " will not block."]
    #[doc = ""]
    pub fn cef_do_message_loop_work();
}
extern "C" {
    #[doc = ""]
    #[doc = " Run the CEF message loop. Use this function instead of an application-"]
    #[doc = " provided message loop to get the best balance between performance and CPU"]
    #[doc = " usage. This function should only be called on the main application thread and"]
    #[doc = " only if cef_initialize() is called with a"]
    #[doc = " CefSettings.multi_threaded_message_loop value of false (0). This function"]
    #[doc = " will block until a quit message is received by the system."]
    #[doc = ""]
    pub fn cef_run_message_loop();
}
extern "C" {
    #[doc = ""]
    #[doc = " Quit the CEF message loop that was started by calling cef_run_message_loop()."]
    #[doc = " This function should only be called on the main application thread and only"]
    #[doc = " if cef_run_message_loop() was used."]
    #[doc = ""]
    pub fn cef_quit_message_loop();
}
extern "C" {
    #[doc = ""]
    #[doc = " Set to true (1) before calling Windows APIs like TrackPopupMenu that enter a"]
    #[doc = " modal message loop. Set to false (0) after exiting the modal message loop."]
    #[doc = ""]
    pub fn cef_set_osmodal_loop(osModalLoop: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = ""]
    #[doc = " Call during process startup to enable High-DPI support on Windows 7 or newer."]
    #[doc = " Older versions of Windows should be left DPI-unaware because they do not"]
    #[doc = " support DirectWrite and GDI fonts are kerned very badly."]
    #[doc = ""]
    pub fn cef_enable_highdpi_support();
}
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of file dialog requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_file_dialog_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue the file selection. |selected_accept_filter| should be the 0-based"]
    #[doc = " index of the value selected from the accept filters array passed to"]
    #[doc = " cef_dialog_handler_t::OnFileDialog. |file_paths| should be a single value"]
    #[doc = " or a list of values depending on the dialog mode. An NULL |file_paths|"]
    #[doc = " value is treated the same as calling cancel()."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_file_dialog_callback_t,
            selected_accept_filter: ::std::os::raw::c_int,
            file_paths: cef_string_list_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel the file selection."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_file_dialog_callback_t)>,
}
#[doc = ""]
#[doc = " Implement this structure to handle dialog events. The functions of this"]
#[doc = " structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_dialog_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to run a file chooser dialog. |mode| represents the type of dialog"]
    #[doc = " to display. |title| to the title to be used for the dialog and may be NULL"]
    #[doc = " to show the default title (\"Open\" or \"Save\" depending on the mode)."]
    #[doc = " |default_file_path| is the path with optional directory and/or file name"]
    #[doc = " component that should be initially selected in the dialog. |accept_filters|"]
    #[doc = " are used to restrict the selectable file types and may any combination of"]
    #[doc = " (a) valid lower-cased MIME types (e.g. \"text/*\" or \"image/*\"), (b)"]
    #[doc = " individual file extensions (e.g. \".txt\" or \".png\"), or (c) combined"]
    #[doc = " description and file extension delimited using \"|\" and \";\" (e.g. \"Image"]
    #[doc = " Types|.png;.gif;.jpg\"). |selected_accept_filter| is the 0-based index of"]
    #[doc = " the filter that should be selected by default. To display a custom dialog"]
    #[doc = " return true (1) and execute |callback| either inline or at a later time. To"]
    #[doc = " display the default dialog return false (0)."]
    #[doc = ""]
    pub on_file_dialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dialog_handler_t,
            browser: *mut _cef_browser_t,
            mode: cef_file_dialog_mode_t,
            title: *const cef_string_t,
            default_file_path: *const cef_string_t,
            accept_filters: cef_string_list_t,
            selected_accept_filter: ::std::os::raw::c_int,
            callback: *mut _cef_file_dialog_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser display state."]
#[doc = " The functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_display_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when a frame's address has changed."]
    #[doc = ""]
    pub on_address_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            url: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the page title changes."]
    #[doc = ""]
    pub on_title_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            title: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the page icon changes."]
    #[doc = ""]
    pub on_favicon_urlchange: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            icon_urls: cef_string_list_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when web content in the page has toggled fullscreen mode. If"]
    #[doc = " |fullscreen| is true (1) the content will automatically be sized to fill"]
    #[doc = " the browser content area. If |fullscreen| is false (0) the content will"]
    #[doc = " automatically return to its original size and position. The client is"]
    #[doc = " responsible for resizing the browser if desired."]
    #[doc = ""]
    pub on_fullscreen_mode_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            fullscreen: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser is about to display a tooltip. |text| contains the"]
    #[doc = " text that will be displayed in the tooltip. To handle the display of the"]
    #[doc = " tooltip yourself return true (1). Otherwise, you can optionally modify"]
    #[doc = " |text| and then return false (0) to allow the browser to display the"]
    #[doc = " tooltip. When window rendering is disabled the application is responsible"]
    #[doc = " for drawing tooltips and the return value is ignored."]
    #[doc = ""]
    pub on_tooltip: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            text: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the browser receives a status message. |value| contains the"]
    #[doc = " text that will be displayed in the status message."]
    #[doc = ""]
    pub on_status_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            value: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called to display a console message. Return true (1) to stop the message"]
    #[doc = " from being output to the console."]
    #[doc = ""]
    pub on_console_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            message: *const cef_string_t,
            source: *const cef_string_t,
            line: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to represent a download item."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_item_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the download is in progress."]
    #[doc = ""]
    pub is_in_progress: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the download is complete."]
    #[doc = ""]
    pub is_complete: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the download has been canceled or interrupted."]
    #[doc = ""]
    pub is_canceled: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a simple speed estimate in bytes/s."]
    #[doc = ""]
    pub get_current_speed:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = ""]
    #[doc = " Returns the rough percent complete or -1 if the receive total size is"]
    #[doc = " unknown."]
    #[doc = ""]
    pub get_percent_complete: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the total number of bytes."]
    #[doc = ""]
    pub get_total_bytes:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = ""]
    #[doc = " Returns the number of received bytes."]
    #[doc = ""]
    pub get_received_bytes:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = ""]
    #[doc = " Returns the time that the download started."]
    #[doc = ""]
    pub get_start_time:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_time_t>,
    #[doc = ""]
    #[doc = " Returns the time that the download ended."]
    #[doc = ""]
    pub get_end_time:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_time_t>,
    #[doc = ""]
    #[doc = " Returns the full path to the downloaded or downloading file."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_full_path: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the unique identifier for this download."]
    #[doc = ""]
    pub get_id:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> uint32>,
    #[doc = ""]
    #[doc = " Returns the URL."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the original URL before any redirections."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_original_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the suggested file name."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_suggested_file_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the content disposition."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_content_disposition: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the mime type."]
    #[doc = ""]
    #[doc = " The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_mime_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
}
#[doc = ""]
#[doc = " Callback structure used to asynchronously continue a download."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_before_download_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Call to continue the download. Set |download_path| to the full file path"]
    #[doc = " for the download including the file name or leave blank to use the"]
    #[doc = " suggested name and the default temp directory. Set |show_dialog| to true"]
    #[doc = " (1) if you do wish to show the default \"Save As\" dialog."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_before_download_callback_t,
            download_path: *const cef_string_t,
            show_dialog: ::std::os::raw::c_int,
        ),
    >,
}
#[doc = ""]
#[doc = " Callback structure used to asynchronously cancel a download."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_item_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Call to cancel the download."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
    #[doc = ""]
    #[doc = " Call to pause the download."]
    #[doc = ""]
    pub pause:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
    #[doc = ""]
    #[doc = " Call to resume the download."]
    #[doc = ""]
    pub resume:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
}
#[doc = ""]
#[doc = " Structure used to handle file downloads. The functions of this structure will"]
#[doc = " called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called before a download begins. |suggested_name| is the suggested name for"]
    #[doc = " the download file. By default the download will be canceled. Execute"]
    #[doc = " |callback| either asynchronously or in this function to continue the"]
    #[doc = " download if desired. Do not keep a reference to |download_item| outside of"]
    #[doc = " this function."]
    #[doc = ""]
    pub on_before_download: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_handler_t,
            browser: *mut _cef_browser_t,
            download_item: *mut _cef_download_item_t,
            suggested_name: *const cef_string_t,
            callback: *mut _cef_before_download_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a download's status or progress information has been updated."]
    #[doc = " This may be called multiple times before and after on_before_download()."]
    #[doc = " Execute |callback| either asynchronously or in this function to cancel the"]
    #[doc = " download if desired. Do not keep a reference to |download_item| outside of"]
    #[doc = " this function."]
    #[doc = ""]
    pub on_download_updated: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_handler_t,
            browser: *mut _cef_browser_t,
            download_item: *mut _cef_download_item_t,
            callback: *mut _cef_download_item_callback_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to dragging. The functions"]
#[doc = " of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_drag_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when an external drag event enters the browser window. |dragData|"]
    #[doc = " contains the drag event data and |mask| represents the type of drag"]
    #[doc = " operation. Return false (0) for default drag handling behavior or true (1)"]
    #[doc = " to cancel the drag event."]
    #[doc = ""]
    pub on_drag_enter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_handler_t,
            browser: *mut _cef_browser_t,
            dragData: *mut _cef_drag_data_t,
            mask: cef_drag_operations_mask_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called whenever draggable regions for the browser window change. These can"]
    #[doc = " be specified using the '-webkit-app-region: drag/no-drag' CSS-property. If"]
    #[doc = " draggable regions are never defined in a document this function will also"]
    #[doc = " never be called. If the last draggable region is removed from a document"]
    #[doc = " this function will be called with an NULL vector."]
    #[doc = ""]
    pub on_draggable_regions_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_handler_t,
            browser: *mut _cef_browser_t,
            regionsCount: usize,
            regions: *const cef_draggable_region_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to find results. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_find_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to report find results returned by cef_browser_host_t::find()."]
    #[doc = " |identifer| is the identifier passed to find(), |count| is the number of"]
    #[doc = " matches currently identified, |selectionRect| is the location of where the"]
    #[doc = " match was found (in window coordinates), |activeMatchOrdinal| is the"]
    #[doc = " current position in the search results, and |finalUpdate| is true (1) if"]
    #[doc = " this is the last find notification."]
    #[doc = ""]
    pub on_find_result: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_find_handler_t,
            browser: *mut _cef_browser_t,
            identifier: ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
            selectionRect: *const cef_rect_t,
            activeMatchOrdinal: ::std::os::raw::c_int,
            finalUpdate: ::std::os::raw::c_int,
        ),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to focus. The functions of"]
#[doc = " this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_focus_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when the browser component is about to loose focus. For instance, if"]
    #[doc = " focus was on the last HTML element and the user pressed the TAB key. |next|"]
    #[doc = " will be true (1) if the browser is giving focus to the next component and"]
    #[doc = " false (0) if the browser is giving focus to the previous component."]
    #[doc = ""]
    pub on_take_focus: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_focus_handler_t,
            browser: *mut _cef_browser_t,
            next: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser component is requesting focus. |source| indicates"]
    #[doc = " where the focus request is originating from. Return false (0) to allow the"]
    #[doc = " focus to be set or true (1) to cancel setting the focus."]
    #[doc = ""]
    pub on_set_focus: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_focus_handler_t,
            browser: *mut _cef_browser_t,
            source: cef_focus_source_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the browser component has received focus."]
    #[doc = ""]
    pub on_got_focus: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_focus_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of geolocation"]
#[doc = " permission requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_geolocation_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Call to allow or deny geolocation access."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_geolocation_callback_t, allow: ::std::os::raw::c_int),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to geolocation permission"]
#[doc = " requests. The functions of this structure will be called on the browser"]
#[doc = " process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_geolocation_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when a page requests permission to access geolocation information."]
    #[doc = " |requesting_url| is the URL requesting permission and |request_id| is the"]
    #[doc = " unique ID for the permission request. Return true (1) and call"]
    #[doc = " cef_geolocation_callback_t::cont() either in this function or at a later"]
    #[doc = " time to continue or cancel the request. Return false (0) to cancel the"]
    #[doc = " request immediately."]
    #[doc = ""]
    pub on_request_geolocation_permission: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_geolocation_handler_t,
            browser: *mut _cef_browser_t,
            requesting_url: *const cef_string_t,
            request_id: ::std::os::raw::c_int,
            callback: *mut _cef_geolocation_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when a geolocation access request is canceled. |request_id| is the"]
    #[doc = " unique ID for the permission request."]
    #[doc = ""]
    pub on_cancel_geolocation_permission: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_geolocation_handler_t,
            browser: *mut _cef_browser_t,
            request_id: ::std::os::raw::c_int,
        ),
    >,
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of JavaScript dialog"]
#[doc = " requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_jsdialog_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue the JS dialog request. Set |success| to true (1) if the OK button"]
    #[doc = " was pressed. The |user_input| value should be specified for prompt dialogs."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_callback_t,
            success: ::std::os::raw::c_int,
            user_input: *const cef_string_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to JavaScript dialogs. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_jsdialog_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be"]
    #[doc = " passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure"]
    #[doc = " and user-friendly display string. The |default_prompt_text| value will be"]
    #[doc = " specified for prompt dialogs only. Set |suppress_message| to true (1) and"]
    #[doc = " return false (0) to suppress the message (suppressing messages is"]
    #[doc = " preferable to immediately executing the callback as this is used to detect"]
    #[doc = " presumably malicious behavior like spamming alert messages in"]
    #[doc = " onbeforeunload). Set |suppress_message| to false (0) and return false (0)"]
    #[doc = " to use the default implementation (the default implementation will show one"]
    #[doc = " modal dialog at a time and suppress any additional dialog requests until"]
    #[doc = " the displayed dialog is dismissed). Return true (1) if the application will"]
    #[doc = " use a custom dialog or if the callback has been executed immediately."]
    #[doc = " Custom dialogs may be either modal or modeless. If a custom dialog is used"]
    #[doc = " the application must execute |callback| once the custom dialog is"]
    #[doc = " dismissed."]
    #[doc = ""]
    pub on_jsdialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_handler_t,
            browser: *mut _cef_browser_t,
            origin_url: *const cef_string_t,
            dialog_type: cef_jsdialog_type_t,
            message_text: *const cef_string_t,
            default_prompt_text: *const cef_string_t,
            callback: *mut _cef_jsdialog_callback_t,
            suppress_message: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to run a dialog asking the user if they want to leave a page. Return"]
    #[doc = " false (0) to use the default dialog implementation. Return true (1) if the"]
    #[doc = " application will use a custom dialog or if the callback has been executed"]
    #[doc = " immediately. Custom dialogs may be either modal or modeless. If a custom"]
    #[doc = " dialog is used the application must execute |callback| once the custom"]
    #[doc = " dialog is dismissed."]
    #[doc = ""]
    pub on_before_unload_dialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_handler_t,
            browser: *mut _cef_browser_t,
            message_text: *const cef_string_t,
            is_reload: ::std::os::raw::c_int,
            callback: *mut _cef_jsdialog_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to cancel any pending dialogs and reset any saved dialog state. Will"]
    #[doc = " be called due to events like page navigation irregardless of whether any"]
    #[doc = " dialogs are currently pending."]
    #[doc = ""]
    pub on_reset_dialog_state: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_jsdialog_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Called when the default implementation dialog is closed."]
    #[doc = ""]
    pub on_dialog_closed: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_jsdialog_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to keyboard input. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_keyboard_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called before a keyboard event is sent to the renderer. |event| contains"]
    #[doc = " information about the keyboard event. |os_event| is the operating system"]
    #[doc = " event message, if any. Return true (1) if the event was handled or false"]
    #[doc = " (0) otherwise. If the event will be handled in on_key_event() as a keyboard"]
    #[doc = " shortcut set |is_keyboard_shortcut| to true (1) and return false (0)."]
    #[doc = ""]
    pub on_pre_key_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_keyboard_handler_t,
            browser: *mut _cef_browser_t,
            event: *const _cef_key_event_t,
            os_event: *mut ::std::os::raw::c_void,
            is_keyboard_shortcut: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called after the renderer and JavaScript in the page has had a chance to"]
    #[doc = " handle the event. |event| contains information about the keyboard event."]
    #[doc = " |os_event| is the operating system event message, if any. Return true (1)"]
    #[doc = " if the keyboard event was handled or false (0) otherwise."]
    #[doc = ""]
    pub on_key_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_keyboard_handler_t,
            browser: *mut _cef_browser_t,
            event: *const _cef_key_event_t,
            os_event: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser life span. The"]
#[doc = " functions of this structure will be called on the UI thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_life_span_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the IO thread before a new popup browser is created. The"]
    #[doc = " |browser| and |frame| values represent the source of the popup request. The"]
    #[doc = " |target_url| and |target_frame_name| values indicate where the popup"]
    #[doc = " browser should navigate and may be NULL if not specified with the request."]
    #[doc = " The |target_disposition| value indicates where the user intended to open"]
    #[doc = " the popup (e.g. current tab, new tab, etc). The |user_gesture| value will"]
    #[doc = " be true (1) if the popup was opened via explicit user gesture (e.g."]
    #[doc = " clicking a link) or false (0) if the popup opened automatically (e.g. via"]
    #[doc = " the DomContentLoaded event). The |popupFeatures| structure contains"]
    #[doc = " additional information about the requested popup window. To allow creation"]
    #[doc = " of the popup browser optionally modify |windowInfo|, |client|, |settings|"]
    #[doc = " and |no_javascript_access| and return false (0). To cancel creation of the"]
    #[doc = " popup browser return true (1). The |client| and |settings| values will"]
    #[doc = " default to the source browser's values. If the |no_javascript_access| value"]
    #[doc = " is set to false (0) the new browser will not be scriptable and may not be"]
    #[doc = " hosted in the same renderer process as the source browser. Any"]
    #[doc = " modifications to |windowInfo| will be ignored if the parent browser is"]
    #[doc = " wrapped in a cef_browser_view_t. Popup browser creation will be canceled if"]
    #[doc = " the parent browser is destroyed before the popup browser creation completes"]
    #[doc = " (indicated by a call to OnAfterCreated for the popup browser)."]
    #[doc = ""]
    pub on_before_popup: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_life_span_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            target_url: *const cef_string_t,
            target_frame_name: *const cef_string_t,
            target_disposition: cef_window_open_disposition_t,
            user_gesture: ::std::os::raw::c_int,
            popupFeatures: *const _cef_popup_features_t,
            windowInfo: *mut _cef_window_info_t,
            client: *mut *mut _cef_client_t,
            settings: *mut _cef_browser_settings_t,
            no_javascript_access: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called after a new browser is created. This callback will be the first"]
    #[doc = " notification that references |browser|."]
    #[doc = ""]
    pub on_after_created: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_life_span_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Called when a browser has recieved a request to close. This may result"]
    #[doc = " directly from a call to cef_browser_host_t::*close_browser() or indirectly"]
    #[doc = " if the browser is parented to a top-level window created by CEF and the"]
    #[doc = " user attempts to close that window (by clicking the 'X', for example). The"]
    #[doc = " do_close() function will be called after the JavaScript 'onunload' event"]
    #[doc = " has been fired."]
    #[doc = ""]
    #[doc = " An application should handle top-level owner window close notifications by"]
    #[doc = " calling cef_browser_host_t::try_close_browser() or"]
    #[doc = " cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window"]
    #[doc = " to close immediately (see the examples below). This gives CEF an"]
    #[doc = " opportunity to process the 'onbeforeunload' event and optionally cancel the"]
    #[doc = " close before do_close() is called."]
    #[doc = ""]
    #[doc = " When windowed rendering is enabled CEF will internally create a window or"]
    #[doc = " view to host the browser. In that case returning false (0) from do_close()"]
    #[doc = " will send the standard close notification to the browser's top-level owner"]
    #[doc = " window (e.g. WM_CLOSE on Windows, performClose: on OS X, \"delete_event\" on"]
    #[doc = " Linux or cef_window_delegate_t::can_close() callback from Views). If the"]
    #[doc = " browser's host window/view has already been destroyed (via view hierarchy"]
    #[doc = " tear-down, for example) then do_close() will not be called for that browser"]
    #[doc = " since is no longer possible to cancel the close."]
    #[doc = ""]
    #[doc = " When windowed rendering is disabled returning false (0) from do_close()"]
    #[doc = " will cause the browser object to be destroyed immediately."]
    #[doc = ""]
    #[doc = " If the browser's top-level owner window requires a non-standard close"]
    #[doc = " notification then send that notification from do_close() and return true"]
    #[doc = " (1)."]
    #[doc = ""]
    #[doc = " The cef_life_span_handler_t::on_before_close() function will be called"]
    #[doc = " after do_close() (if do_close() is called) and immediately before the"]
    #[doc = " browser object is destroyed. The application should only exit after"]
    #[doc = " on_before_close() has been called for all existing browsers."]
    #[doc = ""]
    #[doc = " The below examples describe what should happen during window close when the"]
    #[doc = " browser is parented to an application-provided top-level window."]
    #[doc = ""]
    #[doc = " Example 1: Using cef_browser_host_t::try_close_browser(). This is"]
    #[doc = " recommended for clients using standard close handling and windows created"]
    #[doc = " on the browser process UI thread. 1.  User clicks the window close button"]
    #[doc = " which sends a close notification to"]
    #[doc = "     the application's top-level window."]
    #[doc = " 2.  Application's top-level window receives the close notification and"]
    #[doc = "     calls TryCloseBrowser() (which internally calls CloseBrowser(false))."]
    #[doc = "     TryCloseBrowser() returns false so the client cancels the window close."]
    #[doc = " 3.  JavaScript 'onbeforeunload' handler executes and shows the close"]
    #[doc = "     confirmation dialog (which can be overridden via"]
    #[doc = "     CefJSDialogHandler::OnBeforeUnloadDialog())."]
    #[doc = " 4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6."]
    #[doc = " CEF sends a close notification to the application's top-level window"]
    #[doc = "     (because DoClose() returned false by default)."]
    #[doc = " 7.  Application's top-level window receives the close notification and"]
    #[doc = "     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client"]
    #[doc = "     allows the window close."]
    #[doc = " 8.  Application's top-level window is destroyed. 9.  Application's"]
    #[doc = " on_before_close() handler is called and the browser object"]
    #[doc = "     is destroyed."]
    #[doc = " 10. Application exits by calling cef_quit_message_loop() if no other"]
    #[doc = " browsers"]
    #[doc = "     exist."]
    #[doc = ""]
    #[doc = " Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and"]
    #[doc = " implementing the do_close() callback. This is recommended for clients using"]
    #[doc = " non-standard close handling or windows that were not created on the browser"]
    #[doc = " process UI thread. 1.  User clicks the window close button which sends a"]
    #[doc = " close notification to"]
    #[doc = "     the application's top-level window."]
    #[doc = " 2.  Application's top-level window receives the close notification and:"]
    #[doc = "     A. Calls CefBrowserHost::CloseBrowser(false)."]
    #[doc = "     B. Cancels the window close."]
    #[doc = " 3.  JavaScript 'onbeforeunload' handler executes and shows the close"]
    #[doc = "     confirmation dialog (which can be overridden via"]
    #[doc = "     CefJSDialogHandler::OnBeforeUnloadDialog())."]
    #[doc = " 4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6."]
    #[doc = " Application's do_close() handler is called. Application will:"]
    #[doc = "     A. Set a flag to indicate that the next close attempt will be allowed."]
    #[doc = "     B. Return false."]
    #[doc = " 7.  CEF sends an close notification to the application's top-level window."]
    #[doc = " 8.  Application's top-level window receives the close notification and"]
    #[doc = "     allows the window to close based on the flag from #6B."]
    #[doc = " 9.  Application's top-level window is destroyed. 10. Application's"]
    #[doc = " on_before_close() handler is called and the browser object"]
    #[doc = "     is destroyed."]
    #[doc = " 11. Application exits by calling cef_quit_message_loop() if no other"]
    #[doc = " browsers"]
    #[doc = "     exist."]
    #[doc = ""]
    pub do_close: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_life_span_handler_t,
            browser: *mut _cef_browser_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called just before a browser is destroyed. Release all references to the"]
    #[doc = " browser object and do not attempt to execute any functions on the browser"]
    #[doc = " object after this callback returns. This callback will be the last"]
    #[doc = " notification that references |browser|. See do_close() documentation for"]
    #[doc = " additional usage information."]
    #[doc = ""]
    pub on_before_close: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_life_span_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to receive accessibility notification when"]
#[doc = " accessibility events have been registered. The functions of this structure"]
#[doc = " will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_accessibility_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called after renderer process sends accessibility tree changes to the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub on_accessibility_tree_change: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_accessibility_handler_t, value: *mut _cef_value_t),
    >,
    #[doc = ""]
    #[doc = " Called after renderer process sends accessibility location changes to the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub on_accessibility_location_change: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_accessibility_handler_t, value: *mut _cef_value_t),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events when window rendering is disabled."]
#[doc = " The functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_render_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Return the handler for accessibility notifications. If no handler is"]
    #[doc = " provided the default implementation will be used."]
    #[doc = ""]
    pub get_accessibility_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
        ) -> *mut _cef_accessibility_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve the root window rectangle in screen coordinates. Return"]
    #[doc = " true (1) if the rectangle was provided."]
    #[doc = ""]
    pub get_root_screen_rect: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *mut cef_rect_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve the view rectangle which is relative to screen"]
    #[doc = " coordinates. Return true (1) if the rectangle was provided."]
    #[doc = ""]
    pub get_view_rect: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *mut cef_rect_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve the translation from view coordinates to actual screen"]
    #[doc = " coordinates. Return true (1) if the screen coordinates were provided."]
    #[doc = ""]
    pub get_screen_point: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            viewX: ::std::os::raw::c_int,
            viewY: ::std::os::raw::c_int,
            screenX: *mut ::std::os::raw::c_int,
            screenY: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to allow the client to fill in the CefScreenInfo object with"]
    #[doc = " appropriate values. Return true (1) if the |screen_info| structure has been"]
    #[doc = " modified."]
    #[doc = ""]
    #[doc = " If the screen info rectangle is left NULL the rectangle from GetViewRect"]
    #[doc = " will be used. If the rectangle is still NULL or invalid popups may not be"]
    #[doc = " drawn correctly."]
    #[doc = ""]
    pub get_screen_info: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            screen_info: *mut _cef_screen_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the browser wants to show or hide the popup widget. The popup"]
    #[doc = " should be shown if |show| is true (1) and hidden if |show| is false (0)."]
    #[doc = ""]
    pub on_popup_show: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            show: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser wants to move or resize the popup widget. |rect|"]
    #[doc = " contains the new location and size in view coordinates."]
    #[doc = ""]
    pub on_popup_size: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *const cef_rect_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when an element should be painted. Pixel values passed to this"]
    #[doc = " function are scaled relative to view coordinates based on the value of"]
    #[doc = " CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|"]
    #[doc = " indicates whether the element is the view or the popup widget. |buffer|"]
    #[doc = " contains the pixel data for the whole image. |dirtyRects| contains the set"]
    #[doc = " of rectangles in pixel coordinates that need to be repainted. |buffer| will"]
    #[doc = " be |width|*|height|*4 bytes in size and represents a BGRA image with an"]
    #[doc = " upper-left origin."]
    #[doc = ""]
    pub on_paint: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            type_: cef_paint_element_type_t,
            dirtyRectsCount: usize,
            dirtyRects: *const cef_rect_t,
            buffer: *const ::std::os::raw::c_void,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser's cursor has changed. If |type| is CT_CUSTOM then"]
    #[doc = " |custom_cursor_info| will be populated with the custom cursor information."]
    #[doc = ""]
    pub on_cursor_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            cursor: *mut ::std::os::raw::c_void,
            type_: cef_cursor_type_t,
            custom_cursor_info: *const _cef_cursor_info_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the user starts dragging content in the web view. Contextual"]
    #[doc = " information about the dragged content is supplied by |drag_data|. (|x|,"]
    #[doc = " |y|) is the drag start location in screen coordinates. OS APIs that run a"]
    #[doc = " system message loop may be used within the StartDragging call."]
    #[doc = ""]
    #[doc = " Return false (0) to abort the drag operation. Don't call any of"]
    #[doc = " cef_browser_host_t::DragSource*Ended* functions after returning false (0)."]
    #[doc = ""]
    #[doc = " Return true (1) to handle the drag operation. Call"]
    #[doc = " cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either"]
    #[doc = " synchronously or asynchronously to inform the web view that the drag"]
    #[doc = " operation has ended."]
    #[doc = ""]
    pub start_dragging: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            drag_data: *mut _cef_drag_data_t,
            allowed_ops: cef_drag_operations_mask_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the web view wants to update the mouse cursor during a drag &"]
    #[doc = " drop operation. |operation| describes the allowed operation (none, move,"]
    #[doc = " copy, link)."]
    #[doc = ""]
    pub update_drag_cursor: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            operation: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the scroll offset has changed."]
    #[doc = ""]
    pub on_scroll_offset_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            x: f64,
            y: f64,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the IME composition range has changed. |selected_range| is the"]
    #[doc = " range of characters that have been selected. |character_bounds| is the"]
    #[doc = " bounds of each character in view coordinates."]
    #[doc = ""]
    pub on_ime_composition_range_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            selected_range: *const cef_range_t,
            character_boundsCount: usize,
            character_bounds: *const cef_rect_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of authentication"]
#[doc = " requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_auth_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue the authentication request."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_auth_callback_t,
            username: *const cef_string_t,
            password: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel the authentication request."]
    #[doc = ""]
    pub cancel: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_auth_callback_t)>,
}
#[doc = ""]
#[doc = " Implement this structure to filter resource response content. The functions"]
#[doc = " of this structure will be called on the browser process IO thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_response_filter_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Initialize the response filter. Will only be called a single time. The"]
    #[doc = " filter will not be installed if this function returns false (0)."]
    #[doc = ""]
    pub init_filter: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_filter_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to filter a chunk of data. Expected usage is as follows:"]
    #[doc = ""]
    #[doc = "  A. Read input data from |data_in| and set |data_in_read| to the number of"]
    #[doc = "     bytes that were read up to a maximum of |data_in_size|. |data_in| will"]
    #[doc = "     be NULL if |data_in_size| is zero."]
    #[doc = "  B. Write filtered output data to |data_out| and set |data_out_written| to"]
    #[doc = "     the number of bytes that were written up to a maximum of"]
    #[doc = "     |data_out_size|. If no output data was written then all data must be"]
    #[doc = "     read from |data_in| (user must set |data_in_read| = |data_in_size|)."]
    #[doc = "  C. Return RESPONSE_FILTER_DONE if all output data was written or"]
    #[doc = "     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending."]
    #[doc = ""]
    #[doc = " This function will be called repeatedly until the input buffer has been"]
    #[doc = " fully read (user sets |data_in_read| = |data_in_size|) and there is no more"]
    #[doc = " input data to filter (the resource response is complete). This function may"]
    #[doc = " then be called an additional time with an NULL input buffer if the user"]
    #[doc = " filled the output buffer (set |data_out_written| = |data_out_size|) and"]
    #[doc = " returned RESPONSE_FILTER_NEED_MORE_DATA to indicate that output data is"]
    #[doc = " still pending."]
    #[doc = ""]
    #[doc = " Calls to this function will stop when one of the following conditions is"]
    #[doc = " met:"]
    #[doc = ""]
    #[doc = "  A. There is no more input data to filter (the resource response is"]
    #[doc = "     complete) and the user sets |data_out_written| = 0 or returns"]
    #[doc = "     RESPONSE_FILTER_DONE to indicate that all data has been written, or;"]
    #[doc = "  B. The user returns RESPONSE_FILTER_ERROR to indicate an error."]
    #[doc = ""]
    #[doc = " Do not keep a reference to the buffers passed to this function."]
    #[doc = ""]
    pub filter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_response_filter_t,
            data_in: *mut ::std::os::raw::c_void,
            data_in_size: usize,
            data_in_read: *mut usize,
            data_out: *mut ::std::os::raw::c_void,
            data_out_size: usize,
            data_out_written: *mut usize,
        ) -> cef_response_filter_status_t,
    >,
}
#[doc = ""]
#[doc = " Structure representing SSL information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_sslinfo_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns a bitmask containing any and all problems verifying the server"]
    #[doc = " certificate."]
    #[doc = ""]
    pub get_cert_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslinfo_t) -> cef_cert_status_t,
    >,
    #[doc = ""]
    #[doc = " Returns the X.509 certificate."]
    #[doc = ""]
    pub get_x509certificate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslinfo_t) -> *mut _cef_x509certificate_t,
    >,
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns true (1) if the certificate status has any error, major or minor."]
    #[doc = ""]
    pub fn cef_is_cert_status_error(status: cef_cert_status_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns true (1) if the certificate status represents only minor errors (e.g."]
    #[doc = " failure to verify certificate revocation)."]
    #[doc = ""]
    pub fn cef_is_cert_status_minor_error(status: cef_cert_status_t) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of url requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue the url request. If |allow| is true (1) the request will be"]
    #[doc = " continued. Otherwise, the request will be canceled."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_callback_t, allow: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Cancel the url request."]
    #[doc = ""]
    pub cancel: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_request_callback_t)>,
}
#[doc = ""]
#[doc = " Callback structure used to select a client certificate for authentication."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_select_client_certificate_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Chooses the specified certificate for client certificate authentication."]
    #[doc = " NULL value means that no client certificate should be used."]
    #[doc = ""]
    pub select: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_select_client_certificate_callback_t,
            cert: *mut _cef_x509certificate_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser requests. The"]
#[doc = " functions of this structure will be called on the thread indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_request_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the UI thread before browser navigation. Return true (1) to"]
    #[doc = " cancel the navigation or false (0) to allow the navigation to proceed. The"]
    #[doc = " |request| object cannot be modified in this callback."]
    #[doc = " cef_load_handler_t::OnLoadingStateChange will be called twice in all cases."]
    #[doc = " If the navigation is allowed cef_load_handler_t::OnLoadStart and"]
    #[doc = " cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled"]
    #[doc = " cef_load_handler_t::OnLoadError will be called with an |errorCode| value of"]
    #[doc = " ERR_ABORTED."]
    #[doc = ""]
    pub on_before_browse: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            is_redirect: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the UI thread before OnBeforeBrowse in certain limited cases"]
    #[doc = " where navigating a new or different browser might be desirable. This"]
    #[doc = " includes user-initiated navigation that might open in a special way (e.g."]
    #[doc = " links clicked via middle-click or ctrl + left-click) and certain types of"]
    #[doc = " cross-origin navigation initiated from the renderer process (e.g."]
    #[doc = " navigating the top-level frame to/from a file URL). The |browser| and"]
    #[doc = " |frame| values represent the source of the navigation. The"]
    #[doc = " |target_disposition| value indicates where the user intended to navigate"]
    #[doc = " the browser based on standard Chromium behaviors (e.g. current tab, new"]
    #[doc = " tab, etc). The |user_gesture| value will be true (1) if the browser"]
    #[doc = " navigated via explicit user gesture (e.g. clicking a link) or false (0) if"]
    #[doc = " it navigated automatically (e.g. via the DomContentLoaded event). Return"]
    #[doc = " true (1) to cancel the navigation or false (0) to allow the navigation to"]
    #[doc = " proceed in the source browser's top-level frame."]
    #[doc = ""]
    pub on_open_urlfrom_tab: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            target_url: *const cef_string_t,
            target_disposition: cef_window_open_disposition_t,
            user_gesture: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread before a resource request is loaded. The |request|"]
    #[doc = " object may be modified. Return RV_CONTINUE to continue the request"]
    #[doc = " immediately. Return RV_CONTINUE_ASYNC and call cef_request_tCallback::"]
    #[doc = " cont() at a later time to continue or cancel the request asynchronously."]
    #[doc = " Return RV_CANCEL to cancel the request immediately."]
    #[doc = ""]
    #[doc = ""]
    pub on_before_resource_load: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            callback: *mut _cef_request_callback_t,
        ) -> cef_return_value_t,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread before a resource is loaded. To allow the resource"]
    #[doc = " to load normally return NULL. To specify a handler for the resource return"]
    #[doc = " a cef_resource_handler_t object. The |request| object should not be"]
    #[doc = " modified in this callback."]
    #[doc = ""]
    pub get_resource_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
        ) -> *mut _cef_resource_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when a resource load is redirected. The |request|"]
    #[doc = " parameter will contain the old URL and other request-related information."]
    #[doc = " The |response| parameter will contain the response that resulted in the"]
    #[doc = " redirect. The |new_url| parameter will contain the new URL and can be"]
    #[doc = " changed if desired. The |request| object cannot be modified in this"]
    #[doc = " callback."]
    #[doc = ""]
    pub on_resource_redirect: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
            new_url: *mut cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when a resource response is received. To allow the"]
    #[doc = " resource to load normally return false (0). To redirect or retry the"]
    #[doc = " resource modify |request| (url, headers or post body) and return true (1)."]
    #[doc = " The |response| object cannot be modified in this callback."]
    #[doc = ""]
    pub on_resource_response: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread to optionally filter resource response content."]
    #[doc = " |request| and |response| represent the request and response respectively"]
    #[doc = " and cannot be modified in this callback."]
    #[doc = ""]
    pub get_resource_response_filter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
        ) -> *mut _cef_response_filter_t,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when a resource load has completed. |request| and"]
    #[doc = " |response| represent the request and response respectively and cannot be"]
    #[doc = " modified in this callback. |status| indicates the load completion status."]
    #[doc = " |received_content_length| is the number of response bytes actually read."]
    #[doc = ""]
    pub on_resource_load_complete: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
            status: cef_urlrequest_status_t,
            received_content_length: int64,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when the browser needs credentials from the user."]
    #[doc = " |isProxy| indicates whether the host is a proxy server. |host| contains the"]
    #[doc = " hostname and |port| contains the port number. |realm| is the realm of the"]
    #[doc = " challenge and may be NULL. |scheme| is the authentication scheme used, such"]
    #[doc = " as \"basic\" or \"digest\", and will be NULL if the source of the request is an"]
    #[doc = " FTP server. Return true (1) to continue the request and call"]
    #[doc = " cef_auth_callback_t::cont() either in this function or at a later time when"]
    #[doc = " the authentication information is available. Return false (0) to cancel the"]
    #[doc = " request immediately."]
    #[doc = ""]
    pub get_auth_credentials: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            isProxy: ::std::os::raw::c_int,
            host: *const cef_string_t,
            port: ::std::os::raw::c_int,
            realm: *const cef_string_t,
            scheme: *const cef_string_t,
            callback: *mut _cef_auth_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when JavaScript requests a specific storage quota"]
    #[doc = " size via the webkitStorageInfo.requestQuota function. |origin_url| is the"]
    #[doc = " origin of the page making the request. |new_size| is the requested quota"]
    #[doc = " size in bytes. Return true (1) to continue the request and call"]
    #[doc = " cef_request_tCallback::cont() either in this function or at a later time to"]
    #[doc = " grant or deny the request. Return false (0) to cancel the request"]
    #[doc = " immediately."]
    #[doc = ""]
    pub on_quota_request: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            origin_url: *const cef_string_t,
            new_size: int64,
            callback: *mut _cef_request_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the UI thread to handle requests for URLs with an unknown"]
    #[doc = " protocol component. Set |allow_os_execution| to true (1) to attempt"]
    #[doc = " execution via the registered OS protocol handler, if any. SECURITY WARNING:"]
    #[doc = " YOU SHOULD USE THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR"]
    #[doc = " OTHER URL ANALYSIS BEFORE ALLOWING OS EXECUTION."]
    #[doc = ""]
    pub on_protocol_execution: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            url: *const cef_string_t,
            allow_os_execution: *mut ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the UI thread to handle requests for URLs with an invalid SSL"]
    #[doc = " certificate. Return true (1) and call cef_request_tCallback::cont() either"]
    #[doc = " in this function or at a later time to continue or cancel the request."]
    #[doc = " Return false (0) to cancel the request immediately. If"]
    #[doc = " CefSettings.ignore_certificate_errors is set all invalid certificates will"]
    #[doc = " be accepted without calling this function."]
    #[doc = ""]
    pub on_certificate_error: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            cert_error: cef_errorcode_t,
            request_url: *const cef_string_t,
            ssl_info: *mut _cef_sslinfo_t,
            callback: *mut _cef_request_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the UI thread when a client certificate is being requested for"]
    #[doc = " authentication. Return false (0) to use the default behavior and"]
    #[doc = " automatically select the first certificate available. Return true (1) and"]
    #[doc = " call cef_select_client_certificate_callback_t::Select either in this"]
    #[doc = " function or at a later time to select a certificate. Do not call Select or"]
    #[doc = " call it with NULL to continue without using any certificate. |isProxy|"]
    #[doc = " indicates whether the host is an HTTPS proxy or the origin server. |host|"]
    #[doc = " and |port| contains the hostname and port of the SSL server. |certificates|"]
    #[doc = " is the list of certificates to choose from; this list has already been"]
    #[doc = " pruned by Chromium so that it only contains certificates from issuers that"]
    #[doc = " the server trusts."]
    #[doc = ""]
    pub on_select_client_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            isProxy: ::std::os::raw::c_int,
            host: *const cef_string_t,
            port: ::std::os::raw::c_int,
            certificatesCount: usize,
            certificates: *const *mut _cef_x509certificate_t,
            callback: *mut _cef_select_client_certificate_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the browser process UI thread when a plugin has crashed."]
    #[doc = " |plugin_path| is the path of the plugin that crashed."]
    #[doc = ""]
    pub on_plugin_crashed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            plugin_path: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the browser process UI thread when the render view associated"]
    #[doc = " with |browser| is ready to receive/handle IPC messages in the render"]
    #[doc = " process."]
    #[doc = ""]
    pub on_render_view_ready: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Called on the browser process UI thread when the render process terminates"]
    #[doc = " unexpectedly. |status| indicates how the process terminated."]
    #[doc = ""]
    pub on_render_process_terminated: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            status: cef_termination_status_t,
        ),
    >,
}
#[doc = ""]
#[doc = " Implement this structure to provide handler implementations."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, FromJava)]
pub struct _cef_client_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Return the handler for context menus. If no handler is provided the default"]
    #[doc = " implementation will be used."]
    #[doc = ""]
    pub get_context_menu_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_context_menu_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for dialogs. If no handler is provided the default"]
    #[doc = " implementation will be used."]
    #[doc = ""]
    pub get_dialog_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_dialog_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser display state events."]
    #[doc = ""]
    pub get_display_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_display_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for download events. If no handler is returned downloads"]
    #[doc = " will not be allowed."]
    #[doc = ""]
    pub get_download_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_download_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for drag events."]
    #[doc = ""]
    pub get_drag_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_drag_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for find result events."]
    #[doc = ""]
    pub get_find_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_find_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for focus events."]
    #[doc = ""]
    pub get_focus_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_focus_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for geolocation permissions requests. If no handler is"]
    #[doc = " provided geolocation access will be denied by default."]
    #[doc = ""]
    pub get_geolocation_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_geolocation_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for JavaScript dialogs. If no handler is provided the"]
    #[doc = " default implementation will be used."]
    #[doc = ""]
    pub get_jsdialog_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_jsdialog_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for keyboard events."]
    #[doc = ""]
    pub get_keyboard_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_keyboard_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser life span events."]
    #[doc = ""]
    pub get_life_span_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_life_span_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser load status events."]
    #[doc = ""]
    pub get_load_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_load_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for off-screen rendering events."]
    #[doc = ""]
    pub get_render_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_render_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser request events."]
    #[doc = ""]
    pub get_request_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_request_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called when a new message is received from a different process. Return true"]
    #[doc = " (1) if the message was handled or false (0) otherwise. Do not keep a"]
    #[doc = " reference to or attempt to access the message outside of this callback."]
    #[doc = ""]
    pub on_process_message_received: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_client_t,
            browser: *mut _cef_browser_t,
            source_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = ""]
#[doc = " Structure used to make a URL request. URL requests are not associated with a"]
#[doc = " browser instance so no cef_client_t callbacks will be executed. URL requests"]
#[doc = " can be created on any valid CEF thread in either the browser or render"]
#[doc = " process. Once created the functions of the URL request object must be"]
#[doc = " accessed on the same thread that created it."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_urlrequest_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the request object used to create this URL request. The returned"]
    #[doc = " object is read-only and should not be modified."]
    #[doc = ""]
    pub get_request: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> *mut _cef_request_t,
    >,
    #[doc = ""]
    #[doc = " Returns the client."]
    #[doc = ""]
    pub get_client: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> *mut _cef_urlrequest_client_t,
    >,
    #[doc = ""]
    #[doc = " Returns the request status."]
    #[doc = ""]
    pub get_request_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> cef_urlrequest_status_t,
    >,
    #[doc = ""]
    #[doc = " Returns the request error if status is UR_CANCELED or UR_FAILED, or 0"]
    #[doc = " otherwise."]
    #[doc = ""]
    pub get_request_error: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> cef_errorcode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the response, or NULL if no response information is available."]
    #[doc = " Response information will only be available after the upload has completed."]
    #[doc = " The returned object is read-only and should not be modified."]
    #[doc = ""]
    pub get_response: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> *mut _cef_response_t,
    >,
    #[doc = ""]
    #[doc = " Cancel the request."]
    #[doc = ""]
    pub cancel: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_urlrequest_t)>,
}
#[doc = ""]
#[doc = " Structure used to make a URL request. URL requests are not associated with a"]
#[doc = " browser instance so no cef_client_t callbacks will be executed. URL requests"]
#[doc = " can be created on any valid CEF thread in either the browser or render"]
#[doc = " process. Once created the functions of the URL request object must be"]
#[doc = " accessed on the same thread that created it."]
#[doc = ""]
pub type cef_urlrequest_t = _cef_urlrequest_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new URL request. Only GET, POST, HEAD, DELETE and PUT request"]
    #[doc = " functions are supported. Multiple post data elements are not supported and"]
    #[doc = " elements of type PDE_TYPE_FILE are only supported for requests originating"]
    #[doc = " from the browser process. Requests originating from the render process will"]
    #[doc = " receive the same handling as requests originating from Web content -- if the"]
    #[doc = " response contains Content-Disposition or Mime-Type header values that would"]
    #[doc = " not normally be rendered then the response may receive special handling"]
    #[doc = " inside the browser (for example, via the file download code path instead of"]
    #[doc = " the URL request code path). The |request| object will be marked as read-only"]
    #[doc = " after calling this function. In the browser process if |request_context| is"]
    #[doc = " NULL the global request context will be used. In the render process"]
    #[doc = " |request_context| must be NULL and the context associated with the current"]
    #[doc = " renderer process' browser will be used."]
    #[doc = ""]
    pub fn cef_urlrequest_create(
        request: *mut _cef_request_t,
        client: *mut _cef_urlrequest_client_t,
        request_context: *mut _cef_request_context_t,
    ) -> *mut cef_urlrequest_t;
}
#[doc = ""]
#[doc = " Structure that should be implemented by the cef_urlrequest_t client. The"]
#[doc = " functions of this structure will be called on the same thread that created"]
#[doc = " the request unless otherwise documented."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_urlrequest_client_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Notifies the client that the request has completed. Use the"]
    #[doc = " cef_urlrequest_t::GetRequestStatus function to determine if the request was"]
    #[doc = " successful or not."]
    #[doc = ""]
    pub on_request_complete: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_client_t, request: *mut _cef_urlrequest_t),
    >,
    #[doc = ""]
    #[doc = " Notifies the client of upload progress. |current| denotes the number of"]
    #[doc = " bytes sent so far and |total| is the total size of uploading data (or -1 if"]
    #[doc = " chunked upload is enabled). This function will only be called if the"]
    #[doc = " UR_FLAG_REPORT_UPLOAD_PROGRESS flag is set on the request."]
    #[doc = ""]
    pub on_upload_progress: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_urlrequest_client_t,
            request: *mut _cef_urlrequest_t,
            current: int64,
            total: int64,
        ),
    >,
    #[doc = ""]
    #[doc = " Notifies the client of download progress. |current| denotes the number of"]
    #[doc = " bytes received up to the call and |total| is the expected total size of the"]
    #[doc = " response (or -1 if not determined)."]
    #[doc = ""]
    pub on_download_progress: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_urlrequest_client_t,
            request: *mut _cef_urlrequest_t,
            current: int64,
            total: int64,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when some part of the response is read. |data| contains the current"]
    #[doc = " bytes received since the last call. This function will not be called if the"]
    #[doc = " UR_FLAG_NO_DOWNLOAD_DATA flag is set on the request."]
    #[doc = ""]
    pub on_download_data: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_urlrequest_client_t,
            request: *mut _cef_urlrequest_t,
            data: *const ::std::os::raw::c_void,
            data_length: usize,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when the browser needs credentials from the user."]
    #[doc = " |isProxy| indicates whether the host is a proxy server. |host| contains the"]
    #[doc = " hostname and |port| contains the port number. Return true (1) to continue"]
    #[doc = " the request and call cef_auth_callback_t::cont() when the authentication"]
    #[doc = " information is available. Return false (0) to cancel the request. This"]
    #[doc = " function will only be called for requests initiated from the browser"]
    #[doc = " process."]
    #[doc = ""]
    pub get_auth_credentials: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_urlrequest_client_t,
            isProxy: ::std::os::raw::c_int,
            host: *const cef_string_t,
            port: ::std::os::raw::c_int,
            realm: *const cef_string_t,
            scheme: *const cef_string_t,
            callback: *mut _cef_auth_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
}
